<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>codeform: C:/DWK/C/projects/codeform/codeform.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.2 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="dirs.html">Directories</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a></div>
<div class="nav">
<a class="el" href="dir_000000.html">DWK</a>&nbsp;/&nbsp;<a class="el" href="dir_000001.html">C</a>&nbsp;/&nbsp;<a class="el" href="dir_000002.html">projects</a>&nbsp;/&nbsp;<a class="el" href="dir_000003.html">codeform</a></div>
<h1>codeform.c</h1><a href="codeform_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 <span class="comment">/*! \mainpage</span>
00002 <span class="comment"></span>
00003 <span class="comment">    codeform, a code formatter and colourer [intended] for C and C++ \n</span>
00004 <span class="comment">    Copyright (C) 2007 DWK</span>
00005 <span class="comment"></span>
00006 <span class="comment">    This program is free software; you can redistribute it and/or modify</span>
00007 <span class="comment">    it under the terms of the GNU General Public License as published by</span>
00008 <span class="comment">    the Free Software Foundation; either version 2 of the License, or</span>
00009 <span class="comment">    (at your option) any later version.</span>
00010 <span class="comment"></span>
00011 <span class="comment">    This program is distributed in the hope that it will be useful,</span>
00012 <span class="comment">    but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
00013 <span class="comment">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
00014 <span class="comment">    GNU General Public License for more details.</span>
00015 <span class="comment"></span>
00016 <span class="comment">    You should have received a copy of the GNU General Public License</span>
00017 <span class="comment">    along with this program; if not, write to the Free Software</span>
00018 <span class="comment">    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</span>
00019 <span class="comment"></span>
00020 <span class="comment">    The GNU General Public License version 2 is included in the file COPYING.</span>
00021 <span class="comment"></span>
00022 <span class="comment">    \author DWK</span>
00023 <span class="comment">        dwks@theprogrammingsite.com \n</span>
00024 <span class="comment">        http://dwks.theprogrammingsite.com/ \n</span>
00025 <span class="comment"></span>
00026 <span class="comment">    \version 1.2.0</span>
00027 <span class="comment"></span>
00028 <span class="comment">    At the time of this writing, codeform is available at:</span>
00029 <span class="comment">        http://dwks.theprogrammingsite.com/myprogs/codeform.htm</span>
00030 <span class="comment">*/</span>
00031 <span class="comment"></span>
00032 <span class="comment">/*! \file codeform.c</span>
00033 <span class="comment"></span>
00034 <span class="comment">    The one and only source file for codeform.</span>
00035 <span class="comment"></span>
00036 <span class="comment">    This source file compiles without warnings with GCC 2.95.2 and 3.3.3: \n</span>
00037 <span class="comment">        $ gcc -W -Wall -ansi -pedantic -O2 -g -o codeform codeform.c</span>
00038 <span class="comment">*/</span>
00039 
00040 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
00041 <span class="preprocessor">#include &lt;stddef.h&gt;</span>
00042 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
00043 <span class="preprocessor">#include &lt;string.h&gt;</span>
00044 <span class="preprocessor">#include &lt;ctype.h&gt;</span>
00045 <span class="comment"></span>
00046 <span class="comment">/*! Version of codeform. */</span>
<a name="l00047"></a><a class="code" href="codeform_8c.html#a0">00047</a> <span class="preprocessor">#define VERSION "codeform version 1.2.0 by DWK"</span>
00048 <span class="preprocessor"></span><span class="comment"></span>
00049 <span class="comment">/*! An array of strings. Stores the length of each string. */</span>
<a name="l00050"></a><a class="code" href="structstrings__t.html">00050</a> <span class="keyword">struct </span><a class="code" href="structstrings__t.html">strings_t</a> {
<a name="l00051"></a><a class="code" href="structstrings__t.html#o0">00051</a>     <span class="keywordtype">char</span> **<a class="code" href="structstrings__t.html#o0">data</a>;
<a name="l00052"></a><a class="code" href="structstrings__t.html#o1">00052</a>     size_t *<a class="code" href="structstrings__t.html#o1">len</a>;
<a name="l00053"></a><a class="code" href="structstrings__t.html#o2">00053</a>     size_t <a class="code" href="structstrings__t.html#o2">number</a>;
00054 };
00055 <span class="comment"></span>
00056 <span class="comment">/*! The type of a rule. */</span>
<a name="l00057"></a><a class="code" href="codeform_8c.html#a98">00057</a> <span class="keyword">enum</span> <a class="code" href="codeform_8c.html#a98">type_t</a> {
00058     <a class="code" href="codeform_8c.html#a98a1">TYPE_KEYWORD</a>,
00059     <a class="code" href="codeform_8c.html#a98a2">TYPE_MIDWORD</a>,
00060     <a class="code" href="codeform_8c.html#a98a3">TYPE_COMMENT</a>,
00061     <a class="code" href="codeform_8c.html#a98a4">TYPE_STRING</a>,
00062     <a class="code" href="codeform_8c.html#a98a5">TYPE_NESTCOM</a>,
00063     <a class="code" href="codeform_8c.html#a98a6">TYPE_NUMBER</a>,
00064     <a class="code" href="codeform_8c.html#a98a7">TYPE_FPNUMBER</a>,
00065     <a class="code" href="codeform_8c.html#a98a8">TYPE_START</a>,
00066     <a class="code" href="codeform_8c.html#a98a9">TYPE_END</a>,
00067     <a class="code" href="codeform_8c.html#a98a10">TYPES</a>,  <span class="comment">/*!&lt; Number of values for \c type_t (this enum). */</span>
00068     <a class="code" href="codeform_8c.html#a98a11">TYPE_ERROR</a> = -1
00069 };
00070 <span class="comment"></span>
00071 <span class="comment">/*! Flag values to indicate the position in the current file (can be OR'd</span>
00072 <span class="comment">    together).</span>
00073 <span class="comment">*/</span>
<a name="l00074"></a><a class="code" href="codeform_8c.html#a99">00074</a> <span class="keyword">enum</span> <a class="code" href="codeform_8c.html#a99">pos_t</a> {
00075     <a class="code" href="codeform_8c.html#a99a12">POS_START</a> = 1,
00076     <a class="code" href="codeform_8c.html#a99a13">POS_END</a> = 2
00077 };
00078 <span class="comment"></span>
00079 <span class="comment">/*! File names passed to the program on the command line. */</span>
<a name="l00080"></a><a class="code" href="structargument__t.html">00080</a> <span class="keyword">struct </span><a class="code" href="structargument__t.html">argument_t</a> {
<a name="l00081"></a><a class="code" href="structargument__t.html#o0">00081</a>     <span class="keyword">struct </span><a class="code" href="structstrings__t.html">strings_t</a> inputfn, outputfn, rulefn, ilrule;
00082 };
00083 <span class="comment"></span>
00084 <span class="comment">/*! A rule, containing sections and a type. */</span>
<a name="l00085"></a><a class="code" href="structonerule__t.html">00085</a> <span class="keyword">struct </span><a class="code" href="structonerule__t.html">onerule_t</a> {
<a name="l00086"></a><a class="code" href="structonerule__t.html#o0">00086</a>     <span class="keyword">struct </span><a class="code" href="structstrings__t.html">strings_t</a> data;  <span class="comment">/*!&lt; The data for the rule. */</span>
00087 
<a name="l00088"></a><a class="code" href="structonerule__t.html#o1">00088</a>     size_t <a class="code" href="structonerule__t.html#o1">type</a>;  <span class="comment">/*!&lt; Type of the rule (type_func number). */</span>
00089 
<a name="l00090"></a><a class="code" href="structonerule__t.html#o2">00090</a>     size_t <a class="code" href="structonerule__t.html#o2">prev</a>;  <span class="comment">/*!&lt; Rule starting with the same as this one. */</span>
00091 };
00092 <span class="comment"></span>
00093 <span class="comment">/*! A pointer to the previous rule parsed (for '*' sections). */</span>
<a name="l00094"></a><a class="code" href="structprevrule__t.html">00094</a> <span class="keyword">struct </span><a class="code" href="structprevrule__t.html">prevrule_t</a> {
<a name="l00095"></a><a class="code" href="structprevrule__t.html#o0">00095</a>     <span class="keyword">enum</span> <a class="code" href="codeform_8c.html#a98">type_t</a> <a class="code" href="structprevrule__t.html#o0">type</a>;        <span class="comment">/* The current header type. */</span>
<a name="l00096"></a><a class="code" href="structprevrule__t.html#o1">00096</a>     <span class="keyword">struct </span><a class="code" href="structonerule__t.html">onerule_t</a> *<a class="code" href="structprevrule__t.html#o1">one</a>;   <span class="comment">/* The current rule being parsed. */</span>
<a name="l00097"></a><a class="code" href="structprevrule__t.html#o2">00097</a>     <span class="keyword">struct </span><a class="code" href="structonerule__t.html">onerule_t</a> *<a class="code" href="structprevrule__t.html#o2">prev</a>;  <span class="comment">/* The previous rule. */</span>
00098     <span class="comment">/* True if prev is the only pointer to a dynamically allocated structure,</span>
00099 <span class="comment">        and so needs freeing. */</span>
<a name="l00100"></a><a class="code" href="structprevrule__t.html#o3">00100</a>     <span class="keywordtype">int</span> <a class="code" href="structprevrule__t.html#o3">freep</a>;
00101 };
00102 <span class="comment"></span>
00103 <span class="comment">/*! A variable. */</span>
<a name="l00104"></a><a class="code" href="structonevar__t.html">00104</a> <span class="keyword">struct </span><a class="code" href="structonevar__t.html">onevar_t</a> {
00105     <span class="comment">/* The name of the variable and the text to replace it with. */</span>
<a name="l00106"></a><a class="code" href="structonevar__t.html#o1">00106</a>     <span class="keywordtype">char</span> *<a class="code" href="structonevar__t.html#o0">from</a>, *<a class="code" href="structonevar__t.html#o1">to</a>;
<a name="l00107"></a><a class="code" href="structonevar__t.html#o3">00107</a>     size_t <a class="code" href="structonevar__t.html#o2">flen</a>, <a class="code" href="structonevar__t.html#o3">tlen</a>;  <span class="comment">/* The length of \c from and \c to. */</span>
00108 };
00109 <span class="comment"></span>
00110 <span class="comment">/*! Array of all the rules. */</span>
<a name="l00111"></a><a class="code" href="structruledata__t.html">00111</a> <span class="keyword">struct </span><a class="code" href="structruledata__t.html">ruledata_t</a> {
<a name="l00112"></a><a class="code" href="structruledata__t.html#o0">00112</a>     <span class="keyword">struct </span><a class="code" href="structonerule__t.html">onerule_t</a> **<a class="code" href="structruledata__t.html#o0">data</a>;
<a name="l00113"></a><a class="code" href="structruledata__t.html#o1">00113</a>     size_t <a class="code" href="structruledata__t.html#o1">number</a>;
00114 };
00115 <span class="comment"></span>
00116 <span class="comment">/*! List of type_func functions, representing which comments the parser is</span>
00117 <span class="comment">    inside. Since comments can be nested, it stores a list of function numbers.</span>
00118 <span class="comment">*/</span>
<a name="l00119"></a><a class="code" href="structfunclist__t.html">00119</a> <span class="keyword">struct </span><a class="code" href="structfunclist__t.html">funclist_t</a> {
<a name="l00120"></a><a class="code" href="structfunclist__t.html#o0">00120</a>     size_t *<a class="code" href="structfunclist__t.html#o0">which</a>;
00121     <span class="keyword">enum</span> <a class="code" href="codeform_8c.html#a98">type_t</a> *type;
00122     size_t number;
00123 
00124     <span class="comment">/* True if the current comment supports nesting of other comments inside it. */</span>
00125     <span class="keywordtype">int</span> nest;
00126 };
00127 <span class="comment"></span>
00128 <span class="comment">/*! The previous tag, its beginning and end. */</span>
<a name="l00129"></a><a class="code" href="structrulelist__t.html">00129</a> <span class="keyword">struct </span><a class="code" href="structrulelist__t.html">rulelist_t</a> {
<a name="l00130"></a><a class="code" href="structrulelist__t.html#o1">00130</a>     <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="structrulelist__t.html#o0">from</a>, *<a class="code" href="structrulelist__t.html#o1">to</a>;
<a name="l00131"></a><a class="code" href="structrulelist__t.html#o2">00131</a>     <span class="keywordtype">char</span> *<a class="code" href="structrulelist__t.html#o2">ws</a>;
<a name="l00132"></a><a class="code" href="structrulelist__t.html#o3">00132</a>     size_t <a class="code" href="structrulelist__t.html#o3">wslen</a>;
00133 };
00134 <span class="comment"></span>
00135 <span class="comment">/*! Structure passed to the type_func functions, containing all of the non-rule</span>
00136 <span class="comment">    related data they might need.</span>
00137 <span class="comment">*/</span>
<a name="l00138"></a><a class="code" href="structtypefunc__t.html">00138</a> <span class="keyword">struct </span><a class="code" href="structtypefunc__t.html">typefunc_t</a> {
<a name="l00139"></a><a class="code" href="structtypefunc__t.html#o0">00139</a>     FILE *<a class="code" href="structtypefunc__t.html#o0">out</a>;  <span class="comment">/* Output file stream to write data to. */</span>
<a name="l00140"></a><a class="code" href="structtypefunc__t.html#o1">00140</a>     <span class="keywordtype">char</span> **<a class="code" href="structtypefunc__t.html#o1">p</a>;  <span class="comment">/* Pointer to the current position in the string. */</span>
<a name="l00141"></a><a class="code" href="structtypefunc__t.html#o2">00141</a>     <span class="keywordtype">int</span> <a class="code" href="structtypefunc__t.html#o2">iw</a>;  <span class="comment">/* True if the previous character was a word character. */</span>
<a name="l00142"></a><a class="code" href="structtypefunc__t.html#o3">00142</a>     <span class="keyword">enum</span> <a class="code" href="codeform_8c.html#a99">pos_t</a> <a class="code" href="structtypefunc__t.html#o3">pos</a>;  <span class="comment">/* Flags for the beginning and end of the file. */</span>
<a name="l00143"></a><a class="code" href="structtypefunc__t.html#o4">00143</a>     size_t <a class="code" href="structtypefunc__t.html#o4">n</a>;  <span class="comment">/* Character count from the beginning of the string. */</span>
<a name="l00144"></a><a class="code" href="structtypefunc__t.html#o5">00144</a>     size_t <a class="code" href="structtypefunc__t.html#o5">number</a>;  <span class="comment">/* Element in ruledata_t that the rule is. */</span>
<a name="l00145"></a><a class="code" href="structtypefunc__t.html#o6">00145</a>     <span class="keyword">enum</span> <a class="code" href="codeform_8c.html#a98">type_t</a> <a class="code" href="structtypefunc__t.html#o6">type</a>;  <span class="comment">/* The type of rule. */</span>
00146 
<a name="l00147"></a><a class="code" href="structtypefunc__t.html#o7">00147</a>     <span class="keyword">struct </span><a class="code" href="structfunclist__t.html">funclist_t</a> func;  <span class="comment">/* List of nested comments. */</span>
<a name="l00148"></a><a class="code" href="structtypefunc__t.html#o8">00148</a>     <span class="keyword">struct </span><a class="code" href="structrulelist__t.html">rulelist_t</a> *<a class="code" href="structtypefunc__t.html#o8">list</a>;  <span class="comment">/* The previous tag. */</span>
00149 };
00150 <span class="comment"></span>
00151 <span class="comment">/*! A rule type. */</span>
<a name="l00152"></a><a class="code" href="structruletype__t.html">00152</a> <span class="keyword">struct </span><a class="code" href="structruletype__t.html">ruletype_t</a> {
<a name="l00153"></a><a class="code" href="structruletype__t.html#o0">00153</a>     <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="structruletype__t.html#o0">name</a>;  <span class="comment">/* The name of this type of rule. */</span>
<a name="l00154"></a><a class="code" href="structruletype__t.html#o1">00154</a>     size_t <a class="code" href="structruletype__t.html#o1">sort</a>;  <span class="comment">/* The part to sort by. */</span>
<a name="l00155"></a><a class="code" href="structruletype__t.html#o3">00155</a>     <span class="keywordtype">int</span> <a class="code" href="structruletype__t.html#o2">parts</a>, <a class="code" href="structruletype__t.html#o3">xparts</a>;  <span class="comment">/* Minimum parts, and optional extra parts. */</span>
00156 
00157     <span class="comment">/* A pointer to the function that handles this type of rule. */</span>
00158     int (*<a class="code" href="structruletype__t.html#o4">func</a>)(<span class="keyword">struct </span><a class="code" href="structonerule__t.html">onerule_t</a> *rule, <span class="keyword">struct </span><a class="code" href="structtypefunc__t.html">typefunc_t</a> *tf);
00159 };
00160 <span class="comment"></span>
00161 <span class="comment">/*! Array of variables. */</span>
<a name="l00162"></a><a class="code" href="structrulevars__t.html">00162</a> <span class="keyword">struct </span><a class="code" href="structrulevars__t.html">rulevars_t</a> {
<a name="l00163"></a><a class="code" href="structrulevars__t.html#o0">00163</a>     <span class="keyword">struct </span><a class="code" href="structonevar__t.html">onevar_t</a> **<a class="code" href="structrulevars__t.html#o0">data</a>;
<a name="l00164"></a><a class="code" href="structrulevars__t.html#o1">00164</a>     size_t <a class="code" href="structrulevars__t.html#o1">number</a>;
00165 };
00166 <span class="comment"></span>
00167 <span class="comment">/*! Base rules structure, containing types, rules, and variables. */</span>
<a name="l00168"></a><a class="code" href="structrules__t.html">00168</a> <span class="keyword">struct </span><a class="code" href="structrules__t.html">rules_t</a> {
<a name="l00169"></a><a class="code" href="structrules__t.html#o0">00169</a>     <span class="keyword">struct </span><a class="code" href="structruletype__t.html">ruletype_t</a> type[TYPES];
<a name="l00170"></a><a class="code" href="structrules__t.html#o1">00170</a>     <span class="keyword">struct </span><a class="code" href="structrulevars__t.html">rulevars_t</a> vars;
<a name="l00171"></a><a class="code" href="structrules__t.html#o2">00171</a>     <span class="keyword">struct </span><a class="code" href="structrulelist__t.html">rulelist_t</a> list;
<a name="l00172"></a><a class="code" href="structrules__t.html#o3">00172</a>     <span class="keyword">struct </span><a class="code" href="structruledata__t.html">ruledata_t</a> data;
<a name="l00173"></a><a class="code" href="structrules__t.html#o4">00173</a>     <span class="keyword">struct </span><a class="code" href="structonerule__t.html">onerule_t</a> *<a class="code" href="structrules__t.html#o4">cdat</a>[TYPES];
<a name="l00174"></a><a class="code" href="structrules__t.html#o5">00174</a>     <span class="keyword">struct </span><a class="code" href="structprevrule__t.html">prevrule_t</a> pr;
00175 };
00176 
00177 <span class="comment">/*----------------------*\</span>
00178 <span class="comment"> | Function prototypes. |</span>
00179 <span class="comment">\*----------------------*/</span>
00180 
00181 <span class="keywordtype">void</span> <a class="code" href="codeform_8c.html#a14">parse_arguments</a>(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[], <span class="keyword">struct</span> <a class="code" href="structargument__t.html">argument_t</a> *arg);
00182 <span class="keywordtype">void</span> <a class="code" href="codeform_8c.html#a15">add_string</a>(<span class="keyword">struct</span> <a class="code" href="structstrings__t.html">strings_t</a> *data, <span class="keyword">const</span> <span class="keywordtype">char</span> *str);
00183 <span class="keywordtype">void</span> <a class="code" href="codeform_8c.html#a16">add_string_len</a>(<span class="keyword">struct</span> <a class="code" href="structstrings__t.html">strings_t</a> *data, <span class="keyword">const</span> <span class="keywordtype">char</span> *str, size_t len);
00184 <span class="keywordtype">void</span> <a class="code" href="codeform_8c.html#a17">add_string_copy</a>(<span class="keyword">struct</span> <a class="code" href="structstrings__t.html">strings_t</a> *data, <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structstrings__t.html">strings_t</a> *<a class="code" href="structprevrule__t.html#o2">prev</a>);
00185 <span class="keywordtype">void</span> <a class="code" href="codeform_8c.html#a18">shrink_string</a>(<span class="keywordtype">char</span> **str, size_t len);
00186 <span class="keywordtype">int</span> <a class="code" href="codeform_8c.html#a19">check_usage</a>(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[]);
00187 <span class="keywordtype">void</span> <a class="code" href="codeform_8c.html#a20">print_usage</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *progname);
00188 <span class="keywordtype">void</span> <a class="code" href="codeform_8c.html#a21">print_version</a>(<span class="keywordtype">void</span>);
00189 <span class="keywordtype">void</span> <a class="code" href="codeform_8c.html#a22">out_of_memory</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *file, <span class="keywordtype">int</span> line);
00190 <span class="keywordtype">void</span> <a class="code" href="codeform_8c.html#a23">free_ruledata</a>(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structruledata__t.html">ruledata_t</a> *ruledata);
00191 <span class="keywordtype">void</span> <a class="code" href="codeform_8c.html#a24">free_rulecdat</a>(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structrules__t.html">rules_t</a> *rules);
00192 <span class="keywordtype">void</span> <a class="code" href="codeform_8c.html#a25">free_onerule</a>(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structruledata__t.html">ruledata_t</a> *ruledata, size_t which);
00193 <span class="keywordtype">void</span> <a class="code" href="codeform_8c.html#a26">free_strings</a>(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structstrings__t.html">strings_t</a> *strings);
00194 <span class="keywordtype">void</span> <a class="code" href="codeform_8c.html#a27">free_dup_onerule</a>(<span class="keyword">struct</span> <a class="code" href="structonerule__t.html">onerule_t</a> *rule, <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structonerule__t.html">onerule_t</a> *<a class="code" href="structprevrule__t.html#o2">prev</a>);
00195 <span class="keywordtype">void</span> <a class="code" href="codeform_8c.html#a28">free_rulevars</a>(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structrulevars__t.html">rulevars_t</a> *rulevars);
00196 <span class="keywordtype">void</span> <a class="code" href="codeform_8c.html#a29">free_onevar</a>(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structonevar__t.html">onevar_t</a> *var);
00197 <span class="keywordtype">void</span> <a class="code" href="codeform_8c.html#a30">free_argument</a>(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structargument__t.html">argument_t</a> *argument);
00198 <span class="keywordtype">void</span> <a class="code" href="codeform_8c.html#a31">free_prevrule</a>(<span class="keyword">struct</span> <a class="code" href="structprevrule__t.html">prevrule_t</a> *pr);
00199 
00200 FILE *<a class="code" href="codeform_8c.html#a32">open_file</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *fn, <span class="keyword">const</span> <span class="keywordtype">char</span> *mode);
00201 size_t <a class="code" href="codeform_8c.html#a33">get_string</a>(<span class="keywordtype">char</span> **line, size_t len, size_t *alen, FILE *fp);
00202 <span class="keywordtype">void</span> <a class="code" href="codeform_8c.html#a34">load_rules</a>(<span class="keyword">struct</span> <a class="code" href="structrules__t.html">rules_t</a> *rules, <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structstrings__t.html">strings_t</a> *rulefn);
00203 <span class="keywordtype">void</span> <a class="code" href="codeform_8c.html#a35">add_ilrules</a>(<span class="keyword">struct</span> <a class="code" href="structrules__t.html">rules_t</a> *rules, <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structstrings__t.html">strings_t</a> *ilrule);
00204 <span class="keywordtype">void</span> <a class="code" href="codeform_8c.html#a36">add_rules_file_dir</a>(<span class="keyword">struct</span> <a class="code" href="structrules__t.html">rules_t</a> *rules, <span class="keyword">const</span> <span class="keywordtype">char</span> *fn,
00205     <span class="keyword">const</span> <span class="keywordtype">char</span> *dir);
00206 <span class="keywordtype">void</span> <a class="code" href="codeform_8c.html#a37">add_rules_file</a>(<span class="keyword">struct</span> <a class="code" href="structrules__t.html">rules_t</a> *rules, <span class="keyword">const</span> <span class="keywordtype">char</span> *fn);
00207 <span class="keywordtype">void</span> <a class="code" href="codeform_8c.html#a38">add_rule_var</a>(<span class="keyword">struct</span> <a class="code" href="structrules__t.html">rules_t</a> *rules, <span class="keywordtype">char</span> *str, <span class="keyword">const</span> <span class="keywordtype">char</span> *file,
00208     <span class="keywordtype">int</span> line);
00209 <span class="keywordtype">void</span> <a class="code" href="codeform_8c.html#a39">add_var</a>(<span class="keyword">struct</span> <a class="code" href="structrulevars__t.html">rulevars_t</a> *vars, <span class="keywordtype">char</span> *str, <span class="keywordtype">char</span> *eq);
00210 <span class="keywordtype">int</span> <a class="code" href="codeform_8c.html#a40">find_var_pos</a>(<span class="keyword">struct</span> <a class="code" href="structrulevars__t.html">rulevars_t</a> *vars, <span class="keyword">const</span> <span class="keywordtype">char</span> *p, size_t *pos);
00211 <span class="keywordtype">int</span> <a class="code" href="codeform_8c.html#a41">add_rule_type</a>(<span class="keyword">struct</span> <a class="code" href="structrules__t.html">rules_t</a> *rules, <span class="keyword">enum</span> <a class="code" href="codeform_8c.html#a98">type_t</a> *t, <span class="keywordtype">char</span> **str,
00212     <span class="keyword">const</span> <span class="keywordtype">char</span> *file, <span class="keywordtype">int</span> line);
00213 <span class="keywordtype">int</span> <a class="code" href="codeform_8c.html#a42">add_rule_pos</a>(<span class="keyword">struct</span> <a class="code" href="structrules__t.html">rules_t</a> *rules, size_t rsort, <span class="keyword">struct</span> <a class="code" href="structonerule__t.html">onerule_t</a> *<a class="code" href="structprevrule__t.html#o1">one</a>);
00214 <span class="keyword">struct </span><a class="code" href="structonerule__t.html">onerule_t</a> *<a class="code" href="codeform_8c.html#a43">rule_new</a>(<span class="keywordtype">void</span>);
00215 <span class="keywordtype">void</span> <a class="code" href="codeform_8c.html#a44">add_rule_new</a>(<span class="keyword">struct</span> <a class="code" href="structruledata__t.html">ruledata_t</a> *rd);
00216 <span class="keywordtype">void</span> <a class="code" href="codeform_8c.html#a45">add_rule</a>(<span class="keyword">struct</span> <a class="code" href="structrules__t.html">rules_t</a> *rules, <span class="keywordtype">char</span> *str, <span class="keyword">const</span> <span class="keywordtype">char</span> *file, <span class="keywordtype">int</span> line);
00217 <span class="keywordtype">int</span> <a class="code" href="codeform_8c.html#a46">add_allocated_rule</a>(<span class="keyword">struct</span> <a class="code" href="structrules__t.html">rules_t</a> *rules, <span class="keyword">struct</span> <a class="code" href="structonerule__t.html">onerule_t</a> **cdat,
00218     size_t sort);
00219 <span class="keywordtype">void</span> <a class="code" href="codeform_8c.html#a47">add_parts</a>(<span class="keyword">struct</span> <a class="code" href="structstrings__t.html">strings_t</a> *<a class="code" href="structonerule__t.html#o0">data</a>, <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structstrings__t.html">strings_t</a> *<a class="code" href="structonerule__t.html#o2">prev</a>,
00220     <span class="keyword">const</span> <span class="keywordtype">char</span> *str);
00221 <span class="keywordtype">int</span> <a class="code" href="codeform_8c.html#a48">check_parts</a>(<span class="keywordtype">int</span> rparts, <span class="keywordtype">int</span> xparts, <span class="keyword">const</span> <span class="keywordtype">char</span> *str);
00222 <span class="keywordtype">void</span> <a class="code" href="codeform_8c.html#a49">process_escapes</a>(<span class="keyword">struct</span> <a class="code" href="structstrings__t.html">strings_t</a> *<a class="code" href="structonerule__t.html#o0">data</a>);
00223 <span class="keywordtype">void</span> <a class="code" href="codeform_8c.html#a50">remove_escapes</a>(<span class="keywordtype">char</span> **str, size_t *len);
00224 <span class="keywordtype">void</span> <a class="code" href="codeform_8c.html#a51">process_vars</a>(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structrulevars__t.html">rulevars_t</a> *vars, <span class="keyword">struct</span> <a class="code" href="structstrings__t.html">strings_t</a> *<a class="code" href="structonerule__t.html#o0">data</a>);
00225 <span class="keywordtype">void</span> <a class="code" href="codeform_8c.html#a52">replace_var_str</a>(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structrulevars__t.html">rulevars_t</a> *vars, <span class="keywordtype">char</span> **str);
00226 <span class="keywordtype">void</span> <a class="code" href="codeform_8c.html#a53">resize_var_string</a>(<span class="keywordtype">char</span> **str, <span class="keywordtype">char</span> **pos, size_t len);
00227 <span class="keywordtype">void</span> <a class="code" href="codeform_8c.html#a54">find_var_replace</a>(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structrulevars__t.html">rulevars_t</a> *vars, <span class="keywordtype">char</span> **str, <span class="keywordtype">char</span> **p,
00228     <span class="keywordtype">char</span> *end);
00229 <span class="keywordtype">int</span> <a class="code" href="codeform_8c.html#a55">replace_onevar</a>(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structonevar__t.html">onevar_t</a> *var, <span class="keywordtype">char</span> **str, <span class="keywordtype">char</span> **pos,
00230     <span class="keywordtype">char</span> *end);
00231 <span class="keywordtype">void</span> <a class="code" href="codeform_8c.html#a56">replace_novar</a>(size_t cp, <span class="keywordtype">char</span> **str, <span class="keywordtype">char</span> **pos);
00232 size_t <a class="code" href="codeform_8c.html#a57">get_type</a>(<span class="keyword">struct</span> <a class="code" href="structrules__t.html">rules_t</a> *rules, <span class="keyword">const</span> <span class="keywordtype">char</span> *str, <span class="keyword">enum</span> <a class="code" href="codeform_8c.html#a98">type_t</a> *<a class="code" href="structonerule__t.html#o1">type</a>);
00233 
00234 <span class="keywordtype">void</span> <a class="code" href="codeform_8c.html#a58">parse_files</a>(<span class="keyword">struct</span> <a class="code" href="structrules__t.html">rules_t</a> *rules, <span class="keyword">struct</span> <a class="code" href="structstrings__t.html">strings_t</a> *inputfn,
00235     <span class="keyword">struct</span> <a class="code" href="structstrings__t.html">strings_t</a> *outputfn);
00236 <span class="keywordtype">void</span> <a class="code" href="codeform_8c.html#a59">read_file</a>(<span class="keyword">struct</span> <a class="code" href="structrules__t.html">rules_t</a> *rules, <span class="keyword">const</span> <span class="keywordtype">char</span> *fn, FILE *out);
00237 <span class="keywordtype">void</span> <a class="code" href="codeform_8c.html#a60">parse_line</a>(<span class="keyword">struct</span> <a class="code" href="structrules__t.html">rules_t</a> *rules, <span class="keywordtype">char</span> *line, FILE *out,
00238     <span class="keyword">struct</span> <a class="code" href="structtypefunc__t.html">typefunc_t</a> *tf);
00239 <span class="keywordtype">int</span> <a class="code" href="codeform_8c.html#a61">call_one_type</a>(<span class="keyword">struct</span> <a class="code" href="structrules__t.html">rules_t</a> *rules, <span class="keyword">struct</span> <a class="code" href="structtypefunc__t.html">typefunc_t</a> *tf);
00240 <span class="keywordtype">int</span> <a class="code" href="codeform_8c.html#a62">call_type_cdat</a>(<span class="keyword">struct</span> <a class="code" href="structrules__t.html">rules_t</a> *rules, <span class="keyword">struct</span> <a class="code" href="structtypefunc__t.html">typefunc_t</a> *tf);
00241 <span class="keywordtype">int</span> <a class="code" href="codeform_8c.html#a63">call_type_funcs</a>(<span class="keyword">struct</span> <a class="code" href="structrules__t.html">rules_t</a> *rules, <span class="keyword">struct</span> <a class="code" href="structtypefunc__t.html">typefunc_t</a> *tf);
00242 <span class="keywordtype">void</span> <a class="code" href="codeform_8c.html#a64">set_rules_prev</a>(<span class="keyword">struct</span> <a class="code" href="structrules__t.html">rules_t</a> *rules);
00243 <span class="keywordtype">void</span> <a class="code" href="codeform_8c.html#a65">set_follow_prev</a>(<span class="keyword">struct</span> <a class="code" href="structrules__t.html">rules_t</a> *rules, size_t start);
00244 <span class="keywordtype">int</span> <a class="code" href="codeform_8c.html#a66">find_rule_match</a>(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structrules__t.html">rules_t</a> *rules, <span class="keyword">const</span> <span class="keywordtype">char</span> *p, size_t *pos);
00245 <span class="keywordtype">int</span> <a class="code" href="codeform_8c.html#a67">find_rule_new</a>(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structrules__t.html">rules_t</a> *rules, <span class="keyword">const</span> <span class="keywordtype">char</span> *p, size_t *pos);
00246 <span class="keywordtype">int</span> <a class="code" href="codeform_8c.html#a68">find_rule_prev</a>(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structrules__t.html">rules_t</a> *rules, <span class="keyword">const</span> <span class="keywordtype">char</span> *p, size_t *pos);
00247 <span class="keywordtype">void</span> <a class="code" href="codeform_8c.html#a69">copy_file</a>(FILE *from, <span class="keyword">const</span> <span class="keywordtype">char</span> *fn);
00248 
00249 <span class="keywordtype">int</span> <a class="code" href="codeform_8c.html#a70">is_number</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *p);
00250 <span class="keywordtype">int</span> <a class="code" href="codeform_8c.html#a71">is_fpnumber</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *p);
00251 <span class="keywordtype">void</span> <a class="code" href="codeform_8c.html#a72">print_number</a>(<span class="keywordtype">char</span> **p, FILE *out);
00252 <span class="keywordtype">int</span> <a class="code" href="codeform_8c.html#a73">is_word</a>(<span class="keywordtype">int</span> c);
00253 <span class="keywordtype">int</span> <a class="code" href="codeform_8c.html#a74">is_backslashed</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *start, <span class="keyword">const</span> <span class="keywordtype">char</span> *p);
00254 <span class="keywordtype">void</span> <a class="code" href="codeform_8c.html#a75">remove_char</a>(<span class="keywordtype">char</span> *p);
00255 <span class="keywordtype">int</span> <a class="code" href="codeform_8c.html#a73">is_word</a>(<span class="keywordtype">int</span> c);
00256 <span class="keywordtype">int</span> <a class="code" href="codeform_8c.html#a76">is_word_prev</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *line, <span class="keyword">const</span> <span class="keywordtype">char</span> *p);
00257 <span class="keywordtype">void</span> <a class="code" href="codeform_8c.html#a77">remove_comments</a>(<span class="keywordtype">char</span> *s);
00258 <span class="keywordtype">char</span> *<a class="code" href="codeform_8c.html#a78">is_var</a>(<span class="keywordtype">char</span> *s);
00259 <span class="keywordtype">int</span> <a class="code" href="codeform_8c.html#a79">is_current_dir</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *s);
00260 <span class="keywordtype">void</span> <a class="code" href="codeform_8c.html#a80">print_chars</a>(<span class="keywordtype">char</span> **p, size_t len, FILE *out);
00261 <span class="keywordtype">void</span> <a class="code" href="codeform_8c.html#a81">add_to_funclist</a>(<span class="keyword">struct</span> <a class="code" href="structfunclist__t.html">funclist_t</a> *func, size_t which, <span class="keyword">enum</span> <a class="code" href="codeform_8c.html#a98">type_t</a> <a class="code" href="structonerule__t.html#o1">type</a>);
00262 <span class="keywordtype">void</span> <a class="code" href="codeform_8c.html#a82">remove_from_funclist</a>(<span class="keyword">struct</span> <a class="code" href="structfunclist__t.html">funclist_t</a> *func);
00263 <span class="keywordtype">void</span> <a class="code" href="codeform_8c.html#a83">add_ws_rulelist</a>(<span class="keyword">struct</span> <a class="code" href="structrulelist__t.html">rulelist_t</a> *list, <span class="keywordtype">char</span> c);
00264 <span class="keywordtype">void</span> <a class="code" href="codeform_8c.html#a84">print_ws_rulelist</a>(<span class="keyword">struct</span> <a class="code" href="structrulelist__t.html">rulelist_t</a> *list, FILE *out);
00265 <span class="keywordtype">void</span> <a class="code" href="codeform_8c.html#a85">append_rulelist</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *from, <span class="keyword">const</span> <span class="keywordtype">char</span> *to, <span class="keyword">struct</span> <a class="code" href="structrulelist__t.html">rulelist_t</a> *list,
00266     FILE *out);
00267 <span class="keywordtype">void</span> <a class="code" href="codeform_8c.html#a86">chomp_newline</a>(<span class="keywordtype">char</span> *str, size_t *flen);
00268 
00269 <span class="keywordtype">int</span> <a class="code" href="codeform_8c.html#a87">type_keyword</a>(<span class="keyword">struct</span> <a class="code" href="structonerule__t.html">onerule_t</a> *rule, <span class="keyword">struct</span> <a class="code" href="structtypefunc__t.html">typefunc_t</a> *tf);
00270 <span class="keywordtype">int</span> <a class="code" href="codeform_8c.html#a88">type_midword</a>(<span class="keyword">struct</span> <a class="code" href="structonerule__t.html">onerule_t</a> *rule, <span class="keyword">struct</span> <a class="code" href="structtypefunc__t.html">typefunc_t</a> *tf);
00271 <span class="keywordtype">int</span> <a class="code" href="codeform_8c.html#a89">type_comment_end</a>(<span class="keyword">struct</span> <a class="code" href="structonerule__t.html">onerule_t</a> *rule, <span class="keyword">struct</span> <a class="code" href="structtypefunc__t.html">typefunc_t</a> *tf);
00272 <span class="keywordtype">int</span> <a class="code" href="codeform_8c.html#a90">type_comment</a>(<span class="keyword">struct</span> <a class="code" href="structonerule__t.html">onerule_t</a> *rule, <span class="keyword">struct</span> <a class="code" href="structtypefunc__t.html">typefunc_t</a> *tf);
00273 <span class="keywordtype">int</span> <a class="code" href="codeform_8c.html#a91">type_string</a>(<span class="keyword">struct</span> <a class="code" href="structonerule__t.html">onerule_t</a> *rule, <span class="keyword">struct</span> <a class="code" href="structtypefunc__t.html">typefunc_t</a> *tf);
00274 <span class="keywordtype">int</span> <a class="code" href="codeform_8c.html#a92">type_nestcom</a>(<span class="keyword">struct</span> <a class="code" href="structonerule__t.html">onerule_t</a> *rule, <span class="keyword">struct</span> <a class="code" href="structtypefunc__t.html">typefunc_t</a> *tf);
00275 <span class="keywordtype">int</span> <a class="code" href="codeform_8c.html#a93">type_number</a>(<span class="keyword">struct</span> <a class="code" href="structonerule__t.html">onerule_t</a> *rule, <span class="keyword">struct</span> <a class="code" href="structtypefunc__t.html">typefunc_t</a> *tf);
00276 <span class="keywordtype">int</span> <a class="code" href="codeform_8c.html#a94">type_fpnumber</a>(<span class="keyword">struct</span> <a class="code" href="structonerule__t.html">onerule_t</a> *rule, <span class="keyword">struct</span> <a class="code" href="structtypefunc__t.html">typefunc_t</a> *tf);
00277 <span class="keywordtype">int</span> <a class="code" href="codeform_8c.html#a95">type_start</a>(<span class="keyword">struct</span> <a class="code" href="structonerule__t.html">onerule_t</a> *rule, <span class="keyword">struct</span> <a class="code" href="structtypefunc__t.html">typefunc_t</a> *tf);
00278 <span class="keywordtype">int</span> <a class="code" href="codeform_8c.html#a96">type_end</a>(<span class="keyword">struct</span> <a class="code" href="structonerule__t.html">onerule_t</a> *rule, <span class="keyword">struct</span> <a class="code" href="structtypefunc__t.html">typefunc_t</a> *tf);
00279 
00280 <span class="comment">/*------------*\</span>
00281 <span class="comment"> | Functions. |</span>
00282 <span class="comment">\*------------*/</span>
00283 <span class="comment"></span>
00284 <span class="comment">/*! Program entry point. Acts as a driver function, calling other functions.</span>
00285 <span class="comment">    \param argc Number of arguments passed to the program.</span>
00286 <span class="comment">    \param argv Array of command-line arguments, including program name.</span>
00287 <span class="comment">    \return Always returns 0, indicating success.</span>
00288 <span class="comment">*/</span>
<a name="l00289"></a><a class="code" href="codeform_8c.html#a97">00289</a> <span class="keywordtype">int</span> <a class="code" href="codeform_8c.html#a97">main</a>(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[]) {
00290     <span class="keyword">struct </span><a class="code" href="structargument__t.html">argument_t</a> arg = {
00291         {0, 0, 0},
00292         {0, 0, 0},
00293         {0, 0, 0},
00294         {0, 0, 0}
00295     };
00296     <span class="keyword">struct </span><a class="code" href="structrules__t.html">rules_t</a> rules = {
00297         {
00298             {<span class="stringliteral">"keyword"</span>, 0, 3, 1, <a class="code" href="codeform_8c.html#a87">type_keyword</a>},
00299             {<span class="stringliteral">"midword"</span>, 0, 3, 1, <a class="code" href="codeform_8c.html#a88">type_midword</a>},
00300             {<span class="stringliteral">"comment"</span>, 0, 3, 1, <a class="code" href="codeform_8c.html#a90">type_comment</a>},
00301             {<span class="stringliteral">"string"</span>, 0, 3, 1, <a class="code" href="codeform_8c.html#a91">type_string</a>},
00302             {<span class="stringliteral">"nestcom"</span>, 0, 3, 1, <a class="code" href="codeform_8c.html#a92">type_nestcom</a>},
00303             {<span class="stringliteral">"number"</span>, (size_t)-1, 2, 0, <a class="code" href="codeform_8c.html#a93">type_number</a>},
00304             {<span class="stringliteral">"fpnumber"</span>, (size_t)-1, 2, 0, <a class="code" href="codeform_8c.html#a94">type_fpnumber</a>},
00305             {<span class="stringliteral">"start"</span>, (size_t)-1, 1, 0, <a class="code" href="codeform_8c.html#a95">type_start</a>},
00306             {<span class="stringliteral">"end"</span>, (size_t)-1, 1, 0, <a class="code" href="codeform_8c.html#a96">type_end</a>},
00307         },
00308         {0, 0},
00309         {0, 0, 0, 0},
00310         {0, 0},
00311         {0},
00312         {<a class="code" href="codeform_8c.html#a98a11">TYPE_ERROR</a>, 0, 0, 0}
00313     };  <span class="comment">/* The only instance of the structure \c rules_t. */</span>
00314 
00315     <span class="keywordflow">if</span>(<a class="code" href="codeform_8c.html#a19">check_usage</a>(argc, argv)) <span class="keywordflow">return</span> 0;
00316 
00317     <a class="code" href="codeform_8c.html#a14">parse_arguments</a>(argc, argv, &amp;arg);
00318 
00319     <a class="code" href="codeform_8c.html#a35">add_ilrules</a>(&amp;rules, &amp;arg.<a class="code" href="structargument__t.html#o0">ilrule</a>);
00320     <a class="code" href="codeform_8c.html#a34">load_rules</a>(&amp;rules, &amp;arg.rulefn);
00321     <a class="code" href="codeform_8c.html#a64">set_rules_prev</a>(&amp;rules);
00322 
00323     <a class="code" href="codeform_8c.html#a58">parse_files</a>(&amp;rules, &amp;arg.inputfn, &amp;arg.outputfn);
00324 
00325     <span class="comment">/* Free all allocated memory. */</span>
00326 
00327     <a class="code" href="codeform_8c.html#a23">free_ruledata</a>(&amp;rules.<a class="code" href="structrules__t.html#o3">data</a>);
00328     <a class="code" href="codeform_8c.html#a24">free_rulecdat</a>(&amp;rules);
00329     <a class="code" href="codeform_8c.html#a28">free_rulevars</a>(&amp;rules.<a class="code" href="structrules__t.html#o1">vars</a>);
00330     <a class="code" href="codeform_8c.html#a31">free_prevrule</a>(&amp;rules.<a class="code" href="structrules__t.html#o5">pr</a>);
00331     <a class="code" href="codeform_8c.html#a30">free_argument</a>(&amp;arg);
00332 
00333     <span class="keywordflow">return</span> 0;
00334 }
00335 <span class="comment"></span>
00336 <span class="comment">/*! Parses the command-line parameters passed to codeform on the command line.</span>
00337 <span class="comment">    Stores the results in \a arg.</span>
00338 <span class="comment">    \param argc Number of arguments passed to the program.</span>
00339 <span class="comment">    \param argv Array of command-line arguments, including executable name.</span>
00340 <span class="comment">    \param arg The structure to store the arguments in.</span>
00341 <span class="comment">*/</span>
<a name="l00342"></a><a class="code" href="codeform_8c.html#a14">00342</a> <span class="keywordtype">void</span> <a class="code" href="codeform_8c.html#a14">parse_arguments</a>(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[], <span class="keyword">struct</span> <a class="code" href="structargument__t.html">argument_t</a> *arg) {
00343     <span class="keyword">struct </span><a class="code" href="structstrings__t.html">strings_t</a> *p;
00344     <span class="keywordtype">int</span> x;
00345 
00346     <span class="comment">/* Parse command-line parameters. */</span>
00347     <span class="keywordflow">for</span>(x = 1; x &lt; argc; x ++) {
00348         <span class="keywordflow">if</span>(!strcmp(argv[x], <span class="stringliteral">"--"</span>)) {  <span class="comment">/* End of arguments. */</span>
00349             x ++;
00350             <span class="keywordflow">break</span>;
00351         }
00352         <span class="keywordflow">else</span> <span class="keywordflow">if</span>(!strcmp(argv[x], <span class="stringliteral">"-e"</span>)) p = &amp;arg-&gt;<a class="code" href="structargument__t.html#o0">ilrule</a>;  <span class="comment">/* Inline rule. */</span>
00353         <span class="keywordflow">else</span> <span class="keywordflow">if</span>(!strcmp(argv[x], <span class="stringliteral">"-f"</span>)) p = &amp;arg-&gt;rulefn;  <span class="comment">/* Rules file. */</span>
00354         <span class="keywordflow">else</span> <span class="keywordflow">if</span>(!strcmp(argv[x], <span class="stringliteral">"-o"</span>)) p = &amp;arg-&gt;outputfn;  <span class="comment">/* Output file. */</span>
00355         <span class="keywordflow">else</span> <span class="keywordflow">break</span>;  <span class="comment">/* End of arguments. */</span>
00356 
00357         <a class="code" href="codeform_8c.html#a15">add_string</a>(p, argv[++x]);
00358     }
00359     
00360     <span class="comment">/* Make the first non-command-line-argument argument an input file if there</span>
00361 <span class="comment">        are no rules, much like sed. */</span>
00362     <span class="keywordflow">if</span>(x &lt; argc &amp;&amp; !arg-&gt;rulefn.number &amp;&amp; !arg-&gt;<a class="code" href="structargument__t.html#o0">ilrule</a>.<a class="code" href="structstrings__t.html#o2">number</a>) {
00363         <a class="code" href="codeform_8c.html#a15">add_string</a>(&amp;arg-&gt;rulefn, argv[x++]);
00364     }
00365 
00366     <span class="comment">/* Parse remaining command-line parameters; rules or input files. */</span>
00367     <span class="keywordflow">for</span>( ; x &lt; argc; x ++) {
00368         <a class="code" href="codeform_8c.html#a15">add_string</a>(&amp;arg-&gt;inputfn, argv[x]);
00369     }
00370 }
00371 <span class="comment"></span>
00372 <span class="comment">/*! Adds a string to a strings_t structure. Calls add_string_len().</span>
00373 <span class="comment">    \param data The structure to add the string \a str to.</span>
00374 <span class="comment">    \param str The string to add to \a data.</span>
00375 <span class="comment">*/</span>
<a name="l00376"></a><a class="code" href="codeform_8c.html#a15">00376</a> <span class="keywordtype">void</span> <a class="code" href="codeform_8c.html#a15">add_string</a>(<span class="keyword">struct</span> <a class="code" href="structstrings__t.html">strings_t</a> *<a class="code" href="structstrings__t.html#o0">data</a>, <span class="keyword">const</span> <span class="keywordtype">char</span> *str) {
00377     <a class="code" href="codeform_8c.html#a16">add_string_len</a>(data, str, (size_t)-1);
00378 }
00379 <span class="comment"></span>
00380 <span class="comment">/*! Adds a string of specified length to a strings_t structure.</span>
00381 <span class="comment">    \param data The structure to add the string to.</span>
00382 <span class="comment">    \param str The string to add to the structure, \a data. Only \a len</span>
00383 <span class="comment">        characters are copied.</span>
00384 <span class="comment">    \param len Number of characters to copy from the string \a str.</span>
00385 <span class="comment">*/</span>
<a name="l00386"></a><a class="code" href="codeform_8c.html#a16">00386</a> <span class="keywordtype">void</span> <a class="code" href="codeform_8c.html#a16">add_string_len</a>(<span class="keyword">struct</span> <a class="code" href="structstrings__t.html">strings_t</a> *<a class="code" href="structstrings__t.html#o0">data</a>, <span class="keyword">const</span> <span class="keywordtype">char</span> *str, size_t <a class="code" href="structstrings__t.html#o1">len</a>) {
00387     <span class="keywordtype">char</span> **p;
00388     size_t slen, *tlen;
00389 
00390     slen = (len == (size_t)-1 ? strlen(str) : len);
00391 
00392     p = realloc(data-&gt;<a class="code" href="structstrings__t.html#o0">data</a>, (data-&gt;<a class="code" href="structstrings__t.html#o2">number</a> + 1) * <span class="keyword">sizeof</span>(<span class="keywordtype">char</span> *));
00393 
00394     <span class="keywordflow">if</span>(!p) <a class="code" href="codeform_8c.html#a22">out_of_memory</a>(__FILE__, __LINE__);
00395 
00396     data-&gt;<a class="code" href="structstrings__t.html#o0">data</a> = p;
00397     data-&gt;<a class="code" href="structstrings__t.html#o0">data</a>[data-&gt;<a class="code" href="structstrings__t.html#o2">number</a>] = malloc(slen + 1);
00398     <span class="keywordflow">if</span>(!data-&gt;<a class="code" href="structstrings__t.html#o0">data</a>[data-&gt;<a class="code" href="structstrings__t.html#o2">number</a>]) <a class="code" href="codeform_8c.html#a22">out_of_memory</a>(__FILE__, __LINE__);
00399 
00400     <span class="keywordflow">if</span>(len == (size_t)-1) {
00401         strcpy(data-&gt;<a class="code" href="structstrings__t.html#o0">data</a>[data-&gt;<a class="code" href="structstrings__t.html#o2">number</a>], str);
00402     }
00403     <span class="keywordflow">else</span> {
00404         strncpy(data-&gt;<a class="code" href="structstrings__t.html#o0">data</a>[data-&gt;<a class="code" href="structstrings__t.html#o2">number</a>], str, len);
00405         data-&gt;<a class="code" href="structstrings__t.html#o0">data</a>[data-&gt;<a class="code" href="structstrings__t.html#o2">number</a>][len] = 0;
00406     }
00407 
00408     tlen = realloc(data-&gt;<a class="code" href="structstrings__t.html#o1">len</a>, (data-&gt;<a class="code" href="structstrings__t.html#o2">number</a> + 1) * <span class="keyword">sizeof</span>(size_t));
00409 
00410     <span class="keywordflow">if</span>(!tlen) <a class="code" href="codeform_8c.html#a22">out_of_memory</a>(__FILE__, __LINE__);
00411 
00412     data-&gt;<a class="code" href="structstrings__t.html#o1">len</a> = tlen;
00413     data-&gt;<a class="code" href="structstrings__t.html#o1">len</a>[data-&gt;<a class="code" href="structstrings__t.html#o2">number</a>] = slen;
00414 
00415     data-&gt;<a class="code" href="structstrings__t.html#o2">number</a> ++;
00416 }
00417 <span class="comment"></span>
00418 <span class="comment">/*! Adds a string to \a data, the equivalent string in \a prev. The string</span>
00419 <span class="comment">    itself isn't copied, the pointer is just set to the same position in</span>
00420 <span class="comment">    (dynamically-allocated) memory.</span>
00421 <span class="comment">    \param data The strings_t structure to add a string to.</span>
00422 <span class="comment">    \param prev The structure to get the pointer to the string from.</span>
00423 <span class="comment">*/</span>
<a name="l00424"></a><a class="code" href="codeform_8c.html#a17">00424</a> <span class="keywordtype">void</span> <a class="code" href="codeform_8c.html#a17">add_string_copy</a>(<span class="keyword">struct</span> <a class="code" href="structstrings__t.html">strings_t</a> *<a class="code" href="structstrings__t.html#o0">data</a>, <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structstrings__t.html">strings_t</a> *prev) {
00425     <span class="keywordtype">char</span> **p;
00426     size_t *tlen;
00427 
00428     p = realloc(data-&gt;<a class="code" href="structstrings__t.html#o0">data</a>, (data-&gt;<a class="code" href="structstrings__t.html#o2">number</a> + 1) * <span class="keyword">sizeof</span>(<span class="keywordtype">char</span> *));
00429 
00430     <span class="keywordflow">if</span>(!p) <a class="code" href="codeform_8c.html#a22">out_of_memory</a>(__FILE__, __LINE__);
00431 
00432     data-&gt;<a class="code" href="structstrings__t.html#o0">data</a> = p;
00433 
00434     data-&gt;<a class="code" href="structstrings__t.html#o0">data</a>[data-&gt;<a class="code" href="structstrings__t.html#o2">number</a>] = prev-&gt;<a class="code" href="structstrings__t.html#o0">data</a>[data-&gt;<a class="code" href="structstrings__t.html#o2">number</a>];
00435 
00436     tlen = realloc(data-&gt;<a class="code" href="structstrings__t.html#o1">len</a>, (data-&gt;<a class="code" href="structstrings__t.html#o2">number</a> + 1) * <span class="keyword">sizeof</span>(size_t));
00437 
00438     <span class="keywordflow">if</span>(!tlen) <a class="code" href="codeform_8c.html#a22">out_of_memory</a>(__FILE__, __LINE__);
00439 
00440     data-&gt;<a class="code" href="structstrings__t.html#o1">len</a> = tlen;
00441     data-&gt;<a class="code" href="structstrings__t.html#o1">len</a>[data-&gt;<a class="code" href="structstrings__t.html#o2">number</a>] = prev-&gt;<a class="code" href="structstrings__t.html#o1">len</a>[data-&gt;<a class="code" href="structstrings__t.html#o2">number</a>];
00442 
00443     data-&gt;<a class="code" href="structstrings__t.html#o2">number</a> ++;
00444 }
00445 <span class="comment"></span>
00446 <span class="comment">/*! Reallocates the memory for the string \c str to be just enough. Used when</span>
00447 <span class="comment">    some characters have been removed from the string (eg by remove_escapes()).</span>
00448 <span class="comment">    \param str The string to shrink to the right size.</span>
00449 <span class="comment">    \param len The new length of the string.</span>
00450 <span class="comment">*/</span>
<a name="l00451"></a><a class="code" href="codeform_8c.html#a18">00451</a> <span class="keywordtype">void</span> <a class="code" href="codeform_8c.html#a18">shrink_string</a>(<span class="keywordtype">char</span> **str, size_t <a class="code" href="structstrings__t.html#o1">len</a>) {
00452     <span class="keywordtype">char</span> *p = realloc(*str, len + 1);
00453 
00454     <span class="keywordflow">if</span>(!p) <a class="code" href="codeform_8c.html#a22">out_of_memory</a>(__FILE__, __LINE__);
00455 
00456     *str = p;
00457 }
00458 <span class="comment"></span>
00459 <span class="comment">/*! Returns true if any of the command-line parameters are usage, help, or</span>
00460 <span class="comment">    version requests. Called before parsing the rest of the arguments.</span>
00461 <span class="comment">    \param argc Number of command-line parameters.</span>
00462 <span class="comment">    \param argv Array of command-line parameters.</span>
00463 <span class="comment">*/</span>
<a name="l00464"></a><a class="code" href="codeform_8c.html#a19">00464</a> <span class="keywordtype">int</span> <a class="code" href="codeform_8c.html#a19">check_usage</a>(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[]) {
00465     <span class="keywordtype">int</span> x;
00466     
00467     <span class="keywordflow">for</span>(x = 1; x &lt; argc; x ++) {
00468         <span class="keywordflow">if</span>(!strcmp(argv[x], <span class="stringliteral">"--help"</span>) || !strcmp(argv[x], <span class="stringliteral">"-h"</span>)
00469             || !strcmp(argv[x], <span class="stringliteral">"--usage"</span>)) {
00470 
00471             <a class="code" href="codeform_8c.html#a20">print_usage</a>(argv[0]);
00472             <span class="keywordflow">return</span> 1;
00473         }
00474         <span class="keywordflow">else</span> <span class="keywordflow">if</span>(!strcmp(argv[x], <span class="stringliteral">"--version"</span>) || !strcmp(argv[x], <span class="stringliteral">"-v"</span>)) {
00475             <a class="code" href="codeform_8c.html#a21">print_version</a>();
00476             <span class="keywordflow">return</span> 1;
00477         }
00478     }
00479 
00480     <span class="keywordflow">return</span> 0;
00481 }
00482 <span class="comment"></span>
00483 <span class="comment">/*! Prints codeform's usage to the screen.</span>
00484 <span class="comment">    \param progname The executable path of codeform (argv[0] in main()).</span>
00485 <span class="comment">*/</span>
<a name="l00486"></a><a class="code" href="codeform_8c.html#a20">00486</a> <span class="keywordtype">void</span> <a class="code" href="codeform_8c.html#a20">print_usage</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *progname) {
00487     fprintf(stderr, <span class="stringliteral">"\n"</span> <a class="code" href="codeform_8c.html#a0">VERSION</a>
00488         <span class="stringliteral">"\nExecutable path: %s\n"</span>
00489         <span class="stringliteral">"\nusage: codeform [-f rule-file] [-e inline-rule] [-o output]"</span>
00490         <span class="stringliteral">"\n                [--help] [-h] [--usage] [--version] [-v]"</span>
00491         <span class="stringliteral">"\n                [--] [rule-file-if-no-other-rules] [files...]\n"</span>
00492         <span class="stringliteral">"\nThe arguments are very similar to sed's (and -o is from GCC).\n"</span>
00493         <span class="stringliteral">"\nOutput can go to multiple files -- just specify more than one -o"</span>
00494         <span class="stringliteral">" argument. With\nno -o arguments (or if none of the output files"</span>
00495         <span class="stringliteral">" could be opened), stdout is\nused instead.\n"</span>, progname);
00496     fprintf(stderr,  <span class="comment">/* Two fprintf()s to avoid strings over 509 chars long. */</span>
00497         <span class="stringliteral">"\nIf no rules are specified, the first argument that isn't preceded"</span>
00498         <span class="stringliteral">" by an option\nis taken as a rules file instead of an input file."</span>
00499         <span class="stringliteral">" With no input files, stdin\nis used.\n"</span>
00500         <span class="stringliteral">"\nA simple usage of codeform might look like the following:"</span>
00501         <span class="stringliteral">"\n    $ ./codeform -o codeform.htm rules/c_1_html codeform.c"</span>
00502         <span class="stringliteral">"\nThis formats codeform.c according to the rules in rules/c_1_html,"</span>
00503         <span class="stringliteral">" storing the\noutput in codeform.htm.\n"</span>);
00504 }
00505 <span class="comment"></span>
00506 <span class="comment">/*! Prints the version of codeform, including time and date of compilation</span>
00507 <span class="comment">    (__TIME__ and __DATE__).</span>
00508 <span class="comment">*/</span>
<a name="l00509"></a><a class="code" href="codeform_8c.html#a21">00509</a> <span class="keywordtype">void</span> <a class="code" href="codeform_8c.html#a21">print_version</a>(<span class="keywordtype">void</span>) {
00510     fprintf(stderr, <span class="stringliteral">"\n"</span> <a class="code" href="codeform_8c.html#a0">VERSION</a> <span class="stringliteral">" ("</span> __TIME__ <span class="stringliteral">" "</span> __DATE__ <span class="stringliteral">")"</span>
00511         <span class="stringliteral">"\nCopyright (C) 2007 DWK\n"</span>
00512         <span class="stringliteral">"\nThis is free software; see the source for copying conditions. "</span>
00513             <span class="stringliteral">" There is NO"</span>
00514         <span class="stringliteral">"\nwarranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR"</span>
00515             <span class="stringliteral">" PURPOSE,"</span>
00516         <span class="stringliteral">"\nto the extent permitted by law.\n"</span>
00517         <span class="stringliteral">"\nSee the file history that comes with the distribution for a"</span>
00518         <span class="stringliteral">" complete history\nlist of versions of codeform.\n"</span>);
00519 }
00520 <span class="comment"></span>
00521 <span class="comment">/*! Prints an error and exits due to an out-of-memory condition.</span>
00522 <span class="comment">    \param file The file in which the condition occured (__FILE__).</span>
00523 <span class="comment">    \param line The line at which the condition occured (__LINE__).</span>
00524 <span class="comment">*/</span>
<a name="l00525"></a><a class="code" href="codeform_8c.html#a22">00525</a> <span class="keywordtype">void</span> <a class="code" href="codeform_8c.html#a22">out_of_memory</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *file, <span class="keywordtype">int</span> line) {
00526     fprintf(stderr, <span class="stringliteral">"codeform: (%s:%i): Out of memory\n"</span>, file, line);
00527     exit(1);
00528 }
00529 <span class="comment"></span>
00530 <span class="comment">/*! Frees the memory allocated in a ruledata_t structure. Frees data only once,</span>
00531 <span class="comment">    even if two rules reference the same memory.</span>
00532 <span class="comment">    \param ruledata The ruledata_t structure to free the contents of.</span>
00533 <span class="comment">*/</span>
<a name="l00534"></a><a class="code" href="codeform_8c.html#a23">00534</a> <span class="keywordtype">void</span> <a class="code" href="codeform_8c.html#a23">free_ruledata</a>(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structruledata__t.html">ruledata_t</a> *ruledata) {
00535     size_t x;
00536 
00537     <span class="keywordflow">for</span>(x = 0; x &lt; ruledata-&gt;<a class="code" href="structruledata__t.html#o1">number</a>; x ++) {
00538         <a class="code" href="codeform_8c.html#a25">free_onerule</a>(ruledata, x);
00539 
00540         free(ruledata-&gt;<a class="code" href="structruledata__t.html#o0">data</a>[x]);
00541     }
00542 
00543     free(ruledata-&gt;<a class="code" href="structruledata__t.html#o0">data</a>);
00544 }
00545 <span class="comment"></span>
00546 <span class="comment">/*! Frees the memory allocated for the cdat[] array of rules in \a rules.</span>
00547 <span class="comment">    \param rules The structure containing the array of rules to free.</span>
00548 <span class="comment">*/</span>
<a name="l00549"></a><a class="code" href="codeform_8c.html#a24">00549</a> <span class="keywordtype">void</span> <a class="code" href="codeform_8c.html#a24">free_rulecdat</a>(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structrules__t.html">rules_t</a> *rules) {
00550     <span class="keyword">enum</span> <a class="code" href="codeform_8c.html#a98">type_t</a> x;
00551     size_t y;
00552 
00553     <span class="keywordflow">for</span>(x = 0; x &lt; <a class="code" href="codeform_8c.html#a98a10">TYPES</a>; x ++) {
00554         <span class="keywordflow">if</span>(rules-&gt;<a class="code" href="structrules__t.html#o4">cdat</a>[x]) {
00555             <span class="keywordflow">for</span>(y = 0; y &lt; rules-&gt;<a class="code" href="structrules__t.html#o4">cdat</a>[x]-&gt;<a class="code" href="structonerule__t.html#o0">data</a>.<a class="code" href="structstrings__t.html#o2">number</a>; y ++) {
00556                 free(rules-&gt;<a class="code" href="structrules__t.html#o4">cdat</a>[x]-&gt;<a class="code" href="structonerule__t.html#o0">data</a>.<a class="code" href="structstrings__t.html#o0">data</a>[y]);
00557             }
00558 
00559             free(rules-&gt;<a class="code" href="structrules__t.html#o4">cdat</a>[x]-&gt;<a class="code" href="structonerule__t.html#o0">data</a>.<a class="code" href="structstrings__t.html#o0">data</a>);
00560             free(rules-&gt;<a class="code" href="structrules__t.html#o4">cdat</a>[x]-&gt;<a class="code" href="structonerule__t.html#o0">data</a>.<a class="code" href="structstrings__t.html#o1">len</a>);
00561             free(rules-&gt;<a class="code" href="structrules__t.html#o4">cdat</a>[x]);
00562         }
00563     }
00564 }
00565 <span class="comment"></span>
00566 <span class="comment">/*! Frees the allocated memory for a strings_t structure contained in a</span>
00567 <span class="comment">    one_rule structure. Sets any pointers in \a ruledata to the same memory to</span>
00568 <span class="comment">    NULL.</span>
00569 <span class="comment">    \param ruledata The structure containing structures with allocated memory.</span>
00570 <span class="comment">    \param which The strings_t structure to free the contents of.</span>
00571 <span class="comment">*/</span>
<a name="l00572"></a><a class="code" href="codeform_8c.html#a25">00572</a> <span class="keywordtype">void</span> <a class="code" href="codeform_8c.html#a25">free_onerule</a>(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structruledata__t.html">ruledata_t</a> *ruledata, size_t which) {
00573     size_t x, y;
00574 
00575     <span class="keywordflow">for</span>(x = 0; x &lt; ruledata-&gt;<a class="code" href="structruledata__t.html#o0">data</a>[which]-&gt;<a class="code" href="structonerule__t.html#o0">data</a>.<a class="code" href="structstrings__t.html#o2">number</a>; x ++) {
00576         <span class="keywordflow">if</span>(ruledata-&gt;<a class="code" href="structruledata__t.html#o0">data</a>[which]-&gt;<a class="code" href="structonerule__t.html#o0">data</a>.<a class="code" href="structstrings__t.html#o0">data</a>[x]) {
00577             <span class="keywordflow">for</span>(y = which + 1; y &lt; ruledata-&gt;<a class="code" href="structruledata__t.html#o1">number</a>; y ++) {
00578                 <span class="keywordflow">if</span>(y != which &amp;&amp; x &lt; ruledata-&gt;<a class="code" href="structruledata__t.html#o0">data</a>[y]-&gt;<a class="code" href="structonerule__t.html#o0">data</a>.<a class="code" href="structstrings__t.html#o2">number</a>  <span class="comment">/* !!!?*/</span>
00579                     &amp;&amp; ruledata-&gt;<a class="code" href="structruledata__t.html#o0">data</a>[which]-&gt;<a class="code" href="structonerule__t.html#o0">data</a>.<a class="code" href="structstrings__t.html#o0">data</a>[x]
00580                     == ruledata-&gt;<a class="code" href="structruledata__t.html#o0">data</a>[y]-&gt;<a class="code" href="structonerule__t.html#o0">data</a>.<a class="code" href="structstrings__t.html#o0">data</a>[x]) {
00581 
00582                     ruledata-&gt;<a class="code" href="structruledata__t.html#o0">data</a>[y]-&gt;<a class="code" href="structonerule__t.html#o0">data</a>.<a class="code" href="structstrings__t.html#o0">data</a>[x] = 0;
00583                 }
00584             }
00585 
00586             free(ruledata-&gt;<a class="code" href="structruledata__t.html#o0">data</a>[which]-&gt;<a class="code" href="structonerule__t.html#o0">data</a>.<a class="code" href="structstrings__t.html#o0">data</a>[x]);
00587         }
00588     }
00589 
00590     free(ruledata-&gt;<a class="code" href="structruledata__t.html#o0">data</a>[which]-&gt;<a class="code" href="structonerule__t.html#o0">data</a>.<a class="code" href="structstrings__t.html#o0">data</a>);
00591     free(ruledata-&gt;<a class="code" href="structruledata__t.html#o0">data</a>[which]-&gt;<a class="code" href="structonerule__t.html#o0">data</a>.<a class="code" href="structstrings__t.html#o1">len</a>);
00592 }
00593 <span class="comment"></span>
00594 <span class="comment">/*! Frees the memory allocated for a strings_t structure. All members are freed</span>
00595 <span class="comment">    except for the structure itself and non-pointer members.</span>
00596 <span class="comment">    \param strings The strings_t structure to free allocated memory from.</span>
00597 <span class="comment">*/</span>
<a name="l00598"></a><a class="code" href="codeform_8c.html#a26">00598</a> <span class="keywordtype">void</span> <a class="code" href="codeform_8c.html#a26">free_strings</a>(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structstrings__t.html">strings_t</a> *strings) {
00599     size_t x;
00600 
00601     <span class="keywordflow">for</span>(x = 0; x &lt; strings-&gt;<a class="code" href="structstrings__t.html#o2">number</a>; x ++) {
00602         free(strings-&gt;<a class="code" href="structstrings__t.html#o0">data</a>[x]);
00603     }
00604 
00605     free(strings-&gt;<a class="code" href="structstrings__t.html#o0">data</a>);
00606     free(strings-&gt;<a class="code" href="structstrings__t.html#o1">len</a>);
00607 }
00608 <span class="comment"></span>
00609 <span class="comment">/*! Frees the rule \a rule and its parts that are not present in \a prev.</span>
00610 <span class="comment">    \param rule The structure to free, including all non-duplicate parts.</span>
00611 <span class="comment">    \param prev The structure containing parts that could possibly be</span>
00612 <span class="comment">        duplicates of \a rule's parts.</span>
00613 <span class="comment">*/</span>
<a name="l00614"></a><a class="code" href="codeform_8c.html#a27">00614</a> <span class="keywordtype">void</span> <a class="code" href="codeform_8c.html#a27">free_dup_onerule</a>(<span class="keyword">struct</span> <a class="code" href="structonerule__t.html">onerule_t</a> *rule, <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structonerule__t.html">onerule_t</a> *prev) {
00615     size_t x;
00616 
00617     <span class="keywordflow">for</span>(x = 0; x &lt; rule-&gt;<a class="code" href="structonerule__t.html#o0">data</a>.<a class="code" href="structstrings__t.html#o2">number</a>; x ++) {
00618         <span class="keywordflow">if</span>(!prev || x &gt;= prev-&gt;<a class="code" href="structonerule__t.html#o0">data</a>.<a class="code" href="structstrings__t.html#o2">number</a>
00619             || rule-&gt;<a class="code" href="structonerule__t.html#o0">data</a>.<a class="code" href="structstrings__t.html#o0">data</a>[x] != prev-&gt;<a class="code" href="structonerule__t.html#o0">data</a>.<a class="code" href="structstrings__t.html#o0">data</a>[x]) {
00620 
00621             free(rule-&gt;<a class="code" href="structonerule__t.html#o0">data</a>.<a class="code" href="structstrings__t.html#o0">data</a>[x]);
00622         }
00623     }
00624 
00625     free(rule-&gt;<a class="code" href="structonerule__t.html#o0">data</a>.<a class="code" href="structstrings__t.html#o0">data</a>);
00626     free(rule-&gt;<a class="code" href="structonerule__t.html#o0">data</a>.<a class="code" href="structstrings__t.html#o1">len</a>);
00627     free(rule);
00628 }
00629 <span class="comment"></span>
00630 <span class="comment">/*! Frees the memory allocated in a rulevars_t structure.</span>
00631 <span class="comment">    \param rulevars The rulevars_t structure to free the contents of.</span>
00632 <span class="comment">*/</span>
<a name="l00633"></a><a class="code" href="codeform_8c.html#a28">00633</a> <span class="keywordtype">void</span> <a class="code" href="codeform_8c.html#a28">free_rulevars</a>(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structrulevars__t.html">rulevars_t</a> *rulevars) {
00634     size_t x;
00635 
00636     <span class="keywordflow">for</span>(x = 0; x &lt; rulevars-&gt;<a class="code" href="structrulevars__t.html#o1">number</a>; x ++) {
00637         <a class="code" href="codeform_8c.html#a29">free_onevar</a>(rulevars-&gt;<a class="code" href="structrulevars__t.html#o0">data</a>[x]);
00638 
00639         free(rulevars-&gt;<a class="code" href="structrulevars__t.html#o0">data</a>[x]);
00640     }
00641 
00642     free(rulevars-&gt;<a class="code" href="structrulevars__t.html#o0">data</a>);
00643 }
00644 <span class="comment"></span>
00645 <span class="comment">/*! Frees the memory allocated for a onevar_t structure.</span>
00646 <span class="comment">    \param var The structure to free the contents of.</span>
00647 <span class="comment">*/</span>
<a name="l00648"></a><a class="code" href="codeform_8c.html#a29">00648</a> <span class="keywordtype">void</span> <a class="code" href="codeform_8c.html#a29">free_onevar</a>(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structonevar__t.html">onevar_t</a> *var) {
00649     free(var-&gt;<a class="code" href="structonevar__t.html#o0">from</a>);
00650     free(var-&gt;<a class="code" href="structonevar__t.html#o1">to</a>);
00651 }
00652 <span class="comment"></span>
00653 <span class="comment">/*! Frees the memory allocated while parsing command-line arguments:</span>
00654 <span class="comment">    the input, output, and rules file names and any inline rules.</span>
00655 <span class="comment">    \param argument The structure containing the comment-line data to free.</span>
00656 <span class="comment">*/</span>
<a name="l00657"></a><a class="code" href="codeform_8c.html#a30">00657</a> <span class="keywordtype">void</span> <a class="code" href="codeform_8c.html#a30">free_argument</a>(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structargument__t.html">argument_t</a> *argument) {
00658     <a class="code" href="codeform_8c.html#a26">free_strings</a>(&amp;argument-&gt;inputfn);
00659     <a class="code" href="codeform_8c.html#a26">free_strings</a>(&amp;argument-&gt;outputfn);
00660     <a class="code" href="codeform_8c.html#a26">free_strings</a>(&amp;argument-&gt;rulefn);
00661     <a class="code" href="codeform_8c.html#a26">free_strings</a>(&amp;argument-&gt;<a class="code" href="structargument__t.html#o0">ilrule</a>);
00662 }
00663 <span class="comment"></span>
00664 <span class="comment">/*! Frees the rule pointed to in the \c prevrule_t structure by the member</span>
00665 <span class="comment">    \c prev if it is the only pointer to the allocated memory.</span>
00666 <span class="comment">    \param pr The \c prevrule_t structure containing a pointer to the previous</span>
00667 <span class="comment">        rule parsed.</span>
00668 <span class="comment">*/</span>
<a name="l00669"></a><a class="code" href="codeform_8c.html#a31">00669</a> <span class="keywordtype">void</span> <a class="code" href="codeform_8c.html#a31">free_prevrule</a>(<span class="keyword">struct</span> <a class="code" href="structprevrule__t.html">prevrule_t</a> *pr) {
00670     <span class="keywordflow">if</span>(pr-&gt;<a class="code" href="structprevrule__t.html#o3">freep</a>) {
00671         <a class="code" href="codeform_8c.html#a27">free_dup_onerule</a>(pr-&gt;<a class="code" href="structprevrule__t.html#o2">prev</a>, pr-&gt;<a class="code" href="structprevrule__t.html#o1">one</a>);
00672     }
00673 }
00674 <span class="comment"></span>
00675 <span class="comment">/*! Opens the file \a fn in mode \a mode, returning the file pointer on success</span>
00676 <span class="comment">    or NULL on error. Prints an error message on error before returning.</span>
00677 <span class="comment">    \param fn The name of the file to open.</span>
00678 <span class="comment">    \param mode The mode to open the file in.</span>
00679 <span class="comment">    \return The newly opened file, or NULL on error.</span>
00680 <span class="comment">*/</span>
<a name="l00681"></a><a class="code" href="codeform_8c.html#a32">00681</a> FILE *<a class="code" href="codeform_8c.html#a32">open_file</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *fn, <span class="keyword">const</span> <span class="keywordtype">char</span> *mode) {
00682     FILE *fp;
00683 
00684     <span class="keywordflow">if</span>(!strcmp(fn, <span class="stringliteral">"-"</span>)) {
00685         <span class="keywordflow">return</span> strchr(mode, <span class="charliteral">'r'</span>) ? stdin : stdout;
00686     }
00687 
00688     <span class="keywordflow">if</span>(!(fp = fopen(fn, mode))) {
00689         fprintf(stderr, <span class="stringliteral">"codeform: Can't open file \"%s\" for mode \"%s\"\n"</span>,
00690             fn, mode);
00691     }
00692 
00693     <span class="keywordflow">return</span> fp;
00694 }
00695 <span class="comment"></span>
00696 <span class="comment">/*! A dynamic-memory allocating clone of fgets(). Reads characters from fp,</span>
00697 <span class="comment">    storing them in \a line starting with (*line)[len].</span>
00698 <span class="comment">    \param line The resizeable string to store characters in.</span>
00699 <span class="comment">    \param len The position in \a line to start storing characters at.</span>
00700 <span class="comment">    \param alen The amount of memory currently allocated (multiple of BUFSIZ).</span>
00701 <span class="comment">    \param fp The file to read the characters from.</span>
00702 <span class="comment">    \return The new length of the string (\a len modified). It will be the same</span>
00703 <span class="comment">    as \a len if no characters were read before EOF was encountered.</span>
00704 <span class="comment">*/</span>
<a name="l00705"></a><a class="code" href="codeform_8c.html#a33">00705</a> size_t <a class="code" href="codeform_8c.html#a33">get_string</a>(<span class="keywordtype">char</span> **line, size_t <a class="code" href="structstrings__t.html#o1">len</a>, size_t *alen, FILE *fp) {
00706     <span class="keywordtype">char</span> *p;
00707     <span class="keywordtype">int</span> c = 0;
00708 
00709     <span class="keywordflow">do</span> {
00710         <span class="keywordflow">if</span>(c == <span class="charliteral">'\n'</span>) c = 0;
00711         <span class="keywordflow">else</span> c = getc(fp);
00712 
00713         <span class="keywordflow">if</span>(c == EOF) {
00714             c = 0;
00715         }
00716 
00717         <span class="keywordflow">if</span>(len &gt;= *alen) {
00718             <span class="keywordflow">if</span>(*alen) *alen *= 2;
00719             <span class="keywordflow">else</span> *alen = BUFSIZ;
00720 
00721             p = realloc(*line, *alen);
00722 
00723             <span class="keywordflow">if</span>(!p) <a class="code" href="codeform_8c.html#a22">out_of_memory</a>(__FILE__, __LINE__);
00724 
00725             *line = p;
00726         }
00727 
00728         (*line)[len++] = c;
00729     } <span class="keywordflow">while</span>(c);
00730 
00731     <span class="keywordflow">return</span> len - 1;
00732 }
00733 <span class="comment"></span>
00734 <span class="comment">/*! Loads all the rules files in \a rulefn by calling add_rules_file() for each</span>
00735 <span class="comment">    one. Stores the rules read into \a rules.</span>
00736 <span class="comment">    \param rules The structure to store all the rules read in into.</span>
00737 <span class="comment">    \param rulefn The names of rules files to parse.</span>
00738 <span class="comment">*/</span>
<a name="l00739"></a><a class="code" href="codeform_8c.html#a34">00739</a> <span class="keywordtype">void</span> <a class="code" href="codeform_8c.html#a34">load_rules</a>(<span class="keyword">struct</span> <a class="code" href="structrules__t.html">rules_t</a> *rules, <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structstrings__t.html">strings_t</a> *rulefn) {
00740     size_t x;
00741 
00742     <span class="keywordflow">for</span>(x = 0; x &lt; rulefn-&gt;<a class="code" href="structstrings__t.html#o2">number</a>; x ++) {
00743         <a class="code" href="codeform_8c.html#a37">add_rules_file</a>(rules, rulefn-&gt;<a class="code" href="structstrings__t.html#o0">data</a>[x]);
00744     }
00745 }
00746 <span class="comment"></span>
00747 <span class="comment">/*! Adds the inline rules in \c ilrule to \c rules by calling add_rule_var()</span>
00748 <span class="comment">    for each rule.</span>
00749 <span class="comment">    \param rules The structure to add the rules to.</span>
00750 <span class="comment">    \param ilrule The inline rules to add.</span>
00751 <span class="comment">*/</span>
<a name="l00752"></a><a class="code" href="codeform_8c.html#a35">00752</a> <span class="keywordtype">void</span> <a class="code" href="codeform_8c.html#a35">add_ilrules</a>(<span class="keyword">struct</span> <a class="code" href="structrules__t.html">rules_t</a> *rules, <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structstrings__t.html">strings_t</a> *ilrule) {
00753     size_t x;
00754 
00755     <span class="keywordflow">for</span>(x = 0; x &lt; ilrule-&gt;<a class="code" href="structstrings__t.html#o2">number</a>; x ++) {
00756         <a class="code" href="codeform_8c.html#a38">add_rule_var</a>(rules, ilrule-&gt;<a class="code" href="structstrings__t.html#o0">data</a>[x], NULL, x + 1);
00757     }
00758 }
00759 <span class="comment"></span>
00760 <span class="comment">/*! Sources a rules file, prepending the location of the containing rules file</span>
00761 <span class="comment">    if it does not start with "./" or ".\\".</span>
00762 <span class="comment">    \param rules The rules read from rules files so far.</span>
00763 <span class="comment">    \param fn The name of the rules file to read.</span>
00764 <span class="comment">    \param dir The name of the containing rules file to extract the path from.</span>
00765 <span class="comment">*/</span>
<a name="l00766"></a><a class="code" href="codeform_8c.html#a36">00766</a> <span class="keywordtype">void</span> <a class="code" href="codeform_8c.html#a36">add_rules_file_dir</a>(<span class="keyword">struct</span> <a class="code" href="structrules__t.html">rules_t</a> *rules, <span class="keyword">const</span> <span class="keywordtype">char</span> *fn,
00767     <span class="keyword">const</span> <span class="keywordtype">char</span> *dir) {
00768 
00769     <span class="keywordtype">char</span> *last = strrchr(dir, <span class="charliteral">'/'</span>), *p = strrchr(dir, <span class="charliteral">'\\'</span>);
00770 
00771     <span class="keywordflow">if</span>(p &gt; last) last = p;
00772 
00773     <span class="keywordflow">if</span>(fn &amp;&amp; !<a class="code" href="codeform_8c.html#a79">is_current_dir</a>(fn) &amp;&amp; last ++) {
00774         p = malloc(strlen(fn) + last - dir + 1);
00775         <span class="keywordflow">if</span>(!p) <a class="code" href="codeform_8c.html#a22">out_of_memory</a>(__FILE__, __LINE__);
00776 
00777         strncpy(p, dir, last - dir);
00778         strcpy(p + (last - dir), fn);
00779 
00780         <a class="code" href="codeform_8c.html#a37">add_rules_file</a>(rules, p);
00781 
00782         free(p);
00783     }
00784     <span class="keywordflow">else</span> <a class="code" href="codeform_8c.html#a37">add_rules_file</a>(rules, fn);
00785 }
00786 <span class="comment"></span>
00787 <span class="comment">/*! Reads the file \a fn, passing each rule to add_rule_var() for parsing.</span>
00788 <span class="comment">    \param rules The rules that have already been parsed, to add new rules to.</span>
00789 <span class="comment">    \param fn The name of the file containing the new rules.</span>
00790 <span class="comment">*/</span>
<a name="l00791"></a><a class="code" href="codeform_8c.html#a37">00791</a> <span class="keywordtype">void</span> <a class="code" href="codeform_8c.html#a37">add_rules_file</a>(<span class="keyword">struct</span> <a class="code" href="structrules__t.html">rules_t</a> *rules, <span class="keyword">const</span> <span class="keywordtype">char</span> *fn) {
00792     FILE *fp = <a class="code" href="codeform_8c.html#a32">open_file</a>(fn, <span class="stringliteral">"r"</span>);
00793     <span class="keywordtype">char</span> *str = 0;
00794     <span class="keywordtype">int</span> line = 0, isb;
00795     size_t tlen, <a class="code" href="structstrings__t.html#o1">len</a>, flen = 0, alen = 0;
00796 
00797     <span class="keywordflow">if</span>(!fp) <span class="keywordflow">return</span>;
00798 
00799     <span class="keywordflow">do</span> {
00800         len = 0;
00801 
00802         isb = 1;
00803         <span class="keywordflow">while</span>(isb &amp;&amp; (tlen = <a class="code" href="codeform_8c.html#a33">get_string</a>(&amp;str, len, &amp;alen, fp)) != len) {
00804             flen = tlen;
00805 
00806             <a class="code" href="codeform_8c.html#a86">chomp_newline</a>(str, &amp;flen);
00807 
00808             isb = <a class="code" href="codeform_8c.html#a74">is_backslashed</a>(str+len, str+flen);
00809 
00810             len = flen;
00811             line ++;
00812 
00813             <span class="keywordflow">if</span>(len &amp;&amp; str[len-1] == <span class="charliteral">'\\'</span>) str[--len] = 0;
00814         }
00815 
00816         <a class="code" href="codeform_8c.html#a38">add_rule_var</a>(rules, str, fn, line);
00817     } <span class="keywordflow">while</span>(tlen != len);
00818 
00819     <span class="keywordflow">if</span>(fp != stdin) fclose(fp);
00820 
00821     free(str);
00822 }
00823 <span class="comment"></span>
00824 <span class="comment">/*! Adds a rule/variable specified by \c str into \c rules.</span>
00825 <span class="comment">    \param rules The structure to add the variable/rule to.</span>
00826 <span class="comment">    \param str The string representing the rule/variable.</span>
00827 <span class="comment">    \param file The file that the string \c str came from.</span>
00828 <span class="comment">    \param line The line of the file \c file from which \c str came.</span>
00829 <span class="comment">*/</span>
<a name="l00830"></a><a class="code" href="codeform_8c.html#a38">00830</a> <span class="keywordtype">void</span> <a class="code" href="codeform_8c.html#a38">add_rule_var</a>(<span class="keyword">struct</span> <a class="code" href="structrules__t.html">rules_t</a> *rules, <span class="keywordtype">char</span> *str, <span class="keyword">const</span> <span class="keywordtype">char</span> *file,
00831     <span class="keywordtype">int</span> line) {
00832 
00833     <span class="keywordtype">char</span> *p;
00834 
00835     <a class="code" href="codeform_8c.html#a77">remove_comments</a>(str);
00836 
00837     <span class="keywordflow">if</span>(*str == <span class="charliteral">'.'</span>) {
00838         <span class="keywordflow">if</span>(file &amp;&amp; !strcmp(file, str+1)) {
00839             fprintf(stderr, <span class="stringliteral">"codeform: Error in rule (%s:%i):"</span>
00840                 <span class="stringliteral">" Recursive sourcing: \"%s\"\n"</span>,
00841                 file ? file : <span class="stringliteral">"-e"</span>, line, str);
00842         }
00843         <span class="keywordflow">else</span> {
00844             <span class="keywordflow">if</span>(file &amp;&amp; !strchr(str+1, <span class="charliteral">'/'</span>) &amp;&amp; !strchr(str+1, <span class="charliteral">'\\'</span>)) {
00845                 <a class="code" href="codeform_8c.html#a36">add_rules_file_dir</a>(rules, str+1, file);
00846             }
00847             <span class="keywordflow">else</span> <a class="code" href="codeform_8c.html#a37">add_rules_file</a>(rules, str+1);
00848         }
00849     }
00850     <span class="keywordflow">else</span> <span class="keywordflow">if</span>((p = <a class="code" href="codeform_8c.html#a78">is_var</a>(str))) <a class="code" href="codeform_8c.html#a39">add_var</a>(&amp;rules-&gt;<a class="code" href="structrules__t.html#o1">vars</a>, str, p);
00851     <span class="keywordflow">else</span> <span class="keywordflow">if</span>(*str) <a class="code" href="codeform_8c.html#a45">add_rule</a>(rules, str, file, line);
00852 }
00853 <span class="comment"></span>
00854 <span class="comment">/*! Adds a variable to the list of variables. The variable starts with \a str,</span>
00855 <span class="comment">    and the position of the '=' is at \a eq.</span>
00856 <span class="comment">    \param vars The structure of variables to store the new variable in.</span>
00857 <span class="comment">    \param str The string representing the variable.</span>
00858 <span class="comment">    \param eq The position in string of the '=' sign separating the name of the</span>
00859 <span class="comment">        variable from the variable's value.</span>
00860 <span class="comment">*/</span>
<a name="l00861"></a><a class="code" href="codeform_8c.html#a39">00861</a> <span class="keywordtype">void</span> <a class="code" href="codeform_8c.html#a39">add_var</a>(<span class="keyword">struct</span> <a class="code" href="structrulevars__t.html">rulevars_t</a> *vars, <span class="keywordtype">char</span> *str, <span class="keywordtype">char</span> *eq) {
00862     <span class="keyword">struct </span><a class="code" href="structonevar__t.html">onevar_t</a> **p;
00863     size_t eqlen = strlen(eq), pos;
00864 
00865     *eq = 0;
00866 
00867     <span class="keywordflow">if</span>(<a class="code" href="codeform_8c.html#a40">find_var_pos</a>(vars, str, &amp;pos)) <span class="keywordflow">return</span>;
00868     <span class="keywordflow">if</span>(pos == (size_t)-1) pos = 0;
00869 
00870     p = realloc(vars-&gt;<a class="code" href="structrulevars__t.html#o0">data</a>, (vars-&gt;<a class="code" href="structrulevars__t.html#o1">number</a> + 1) * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structonevar__t.html">onevar_t</a> *));
00871 
00872     <span class="keywordflow">if</span>(!p) <a class="code" href="codeform_8c.html#a22">out_of_memory</a>(__FILE__, __LINE__);
00873 
00874     vars-&gt;<a class="code" href="structrulevars__t.html#o0">data</a> = p;
00875 
00876     memmove(vars-&gt;<a class="code" href="structrulevars__t.html#o0">data</a> + pos + 1, vars-&gt;<a class="code" href="structrulevars__t.html#o0">data</a> + pos,
00877         (vars-&gt;<a class="code" href="structrulevars__t.html#o1">number</a> - pos) * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> onevar_t *));
00878 
00879     vars-&gt;<a class="code" href="structrulevars__t.html#o0">data</a>[pos] = malloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> onevar_t));
00880     <span class="keywordflow">if</span>(!vars-&gt;<a class="code" href="structrulevars__t.html#o0">data</a>[pos]) <a class="code" href="codeform_8c.html#a22">out_of_memory</a>(__FILE__, __LINE__);
00881 
00882     vars-&gt;<a class="code" href="structrulevars__t.html#o0">data</a>[pos]-&gt;<a class="code" href="structonevar__t.html#o0">from</a> = malloc(eq - str + 1);
00883     <span class="keywordflow">if</span>(!vars-&gt;<a class="code" href="structrulevars__t.html#o0">data</a>[pos]-&gt;<a class="code" href="structonevar__t.html#o0">from</a>) <a class="code" href="codeform_8c.html#a22">out_of_memory</a>(__FILE__, __LINE__);
00884     <span class="comment">/*strncpy(vars-&gt;data[pos]-&gt;from, str, eq - str);*/</span>
00885     strcpy(vars-&gt;<a class="code" href="structrulevars__t.html#o0">data</a>[pos]-&gt;<a class="code" href="structonevar__t.html#o0">from</a>, str);  <span class="comment">/* will not overflow */</span>
00886     <span class="comment">/*vars-&gt;data[pos]-&gt;from[eq - str] = 0;*/</span>
00887     vars-&gt;<a class="code" href="structrulevars__t.html#o0">data</a>[pos]-&gt;<a class="code" href="structonevar__t.html#o2">flen</a> = eq - str;
00888 
00889     vars-&gt;<a class="code" href="structrulevars__t.html#o0">data</a>[pos]-&gt;<a class="code" href="structonevar__t.html#o1">to</a> = malloc(eqlen);
00890     <span class="keywordflow">if</span>(!vars-&gt;<a class="code" href="structrulevars__t.html#o0">data</a>[pos]-&gt;<a class="code" href="structonevar__t.html#o1">to</a>) <a class="code" href="codeform_8c.html#a22">out_of_memory</a>(__FILE__, __LINE__);
00891     strcpy(vars-&gt;<a class="code" href="structrulevars__t.html#o0">data</a>[pos]-&gt;<a class="code" href="structonevar__t.html#o1">to</a>, eq+1);
00892     vars-&gt;<a class="code" href="structrulevars__t.html#o0">data</a>[pos]-&gt;<a class="code" href="structonevar__t.html#o3">tlen</a> = eqlen - 1;
00893 
00894     vars-&gt;<a class="code" href="structrulevars__t.html#o1">number</a> ++;
00895 }
00896 <span class="comment"></span>
00897 <span class="comment">/*! Binary searches through the existing variables in \a rt for the position</span>
00898 <span class="comment">    that the variable \a p should be in, putting the result in \a pos.</span>
00899 <span class="comment">    \param vars The existing variables to search through.</span>
00900 <span class="comment">    \param p The text representing the new variable to search for.</span>
00901 <span class="comment">    \param pos The variable to store the position found in. Set to (size_t)-1</span>
00902 <span class="comment">        if no match was found.</span>
00903 <span class="comment">    \return 1 if an exact match (to the shortest length) was found, 0</span>
00904 <span class="comment">        otherwise.</span>
00905 <span class="comment">*/</span>
<a name="l00906"></a><a class="code" href="codeform_8c.html#a40">00906</a> <span class="keywordtype">int</span> <a class="code" href="codeform_8c.html#a40">find_var_pos</a>(<span class="keyword">struct</span> <a class="code" href="structrulevars__t.html">rulevars_t</a> *vars, <span class="keyword">const</span> <span class="keywordtype">char</span> *p, size_t *pos) {
00907     size_t mid = (size_t)-1, first = 0, last = vars-&gt;<a class="code" href="structrulevars__t.html#o1">number</a>-1;
00908     <span class="keywordtype">int</span> v = 0;
00909 
00910     *pos = (size_t)-1;
00911 
00912     <span class="keywordflow">if</span>(!vars-&gt;<a class="code" href="structrulevars__t.html#o1">number</a>) <span class="keywordflow">return</span> 0;
00913 
00914     <span class="keywordflow">while</span>(first &lt;= last &amp;&amp; last != (size_t)-1) {
00915         mid = (first + last) / 2;
00916 
00917         v = strcmp(p, vars-&gt;<a class="code" href="structrulevars__t.html#o0">data</a>[mid]-&gt;<a class="code" href="structonevar__t.html#o0">from</a>);
00918 
00919         <span class="keywordflow">if</span>(first == last &amp;&amp; v) <span class="keywordflow">break</span>;
00920 
00921         <span class="keywordflow">if</span>(v &lt; 0) last = mid-1;
00922         <span class="keywordflow">else</span> <span class="keywordflow">if</span>(v &gt; 0) first = mid+1;
00923         <span class="keywordflow">else</span> {
00924             *pos = mid;
00925             first = mid+1;
00926         }
00927     }
00928 
00929     <span class="keywordflow">if</span>(*pos != (size_t)-1) <span class="keywordflow">return</span> 1;
00930 
00931     <span class="keywordflow">if</span>(v &lt; 0) *pos = mid;
00932     <span class="keywordflow">else</span> *pos = mid+1;
00933 
00934     <span class="keywordflow">return</span> 0;
00935 }
00936 <span class="comment"></span>
00937 <span class="comment">/*! Called by add_rule() to determine the type of the rule \a str.</span>
00938 <span class="comment">    \param rules The array of rules that have been parsed so far.</span>
00939 <span class="comment">    \param t The pointer to store the type of the current rule.</span>
00940 <span class="comment">    \param str The rule itself.</span>
00941 <span class="comment">    \param file The file which the rule \a str came from.</span>
00942 <span class="comment">    \param line The line of the file from which the rule came.</span>
00943 <span class="comment">    \return 0 if no errors occured and str is an ordinary rule; nonzero if the</span>
00944 <span class="comment">        rule is a header, an invalid header, or not under a header. If \a str</span>
00945 <span class="comment">        is an inline header, positions \a str past the header and returns 0 so</span>
00946 <span class="comment">        that \a str may be treated as an ordinary rule.</span>
00947 <span class="comment">*/</span>
<a name="l00948"></a><a class="code" href="codeform_8c.html#a41">00948</a> <span class="keywordtype">int</span> <a class="code" href="codeform_8c.html#a41">add_rule_type</a>(<span class="keyword">struct</span> <a class="code" href="structrules__t.html">rules_t</a> *rules, <span class="keyword">enum</span> <a class="code" href="codeform_8c.html#a98">type_t</a> *t, <span class="keywordtype">char</span> **str,
00949     <span class="keyword">const</span> <span class="keywordtype">char</span> *file, <span class="keywordtype">int</span> line) {
00950 
00951     size_t v = <a class="code" href="codeform_8c.html#a57">get_type</a>(rules, *str, t);
00952 
00953     <span class="keywordflow">if</span>(!v) {
00954         <span class="keywordflow">if</span>(rules-&gt;<a class="code" href="structrules__t.html#o5">pr</a>.<a class="code" href="structprevrule__t.html#o0">type</a> == <a class="code" href="codeform_8c.html#a98a11">TYPE_ERROR</a>) {
00955             fprintf(stderr, <span class="stringliteral">"codeform: Error in rule (%s:%i):"</span>
00956                 <span class="stringliteral">" Rule not under a header: \"%s\"\n"</span>,
00957                 file ? file : <span class="stringliteral">"-e"</span>, line, *str);
00958             <span class="keywordflow">return</span> 1;
00959         }
00960         <span class="keywordflow">else</span> {
00961             *t = rules-&gt;<a class="code" href="structrules__t.html#o5">pr</a>.<a class="code" href="structprevrule__t.html#o0">type</a>;
00962         }
00963     }
00964     <span class="keywordflow">else</span> <span class="keywordflow">if</span>(v == (size_t)-1) {
00965         rules-&gt;<a class="code" href="structrules__t.html#o5">pr</a>.<a class="code" href="structprevrule__t.html#o0">type</a> = <a class="code" href="codeform_8c.html#a98a11">TYPE_ERROR</a>;
00966         fprintf(stderr, <span class="stringliteral">"codeform: Error in rule (%s:%i):"</span>
00967             <span class="stringliteral">" Invalid header: \"%s\"\n"</span>,
00968             file ? file : <span class="stringliteral">"-e"</span>, line, *str);
00969         <span class="keywordflow">return</span> 1;
00970     }
00971     <span class="keywordflow">else</span> {
00972         rules-&gt;<a class="code" href="structrules__t.html#o5">pr</a>.<a class="code" href="structprevrule__t.html#o0">type</a> = *t;
00973 
00974         <span class="keywordflow">if</span>(v != 1) {
00975             *str += v;
00976         }
00977         <span class="keywordflow">else</span> <span class="keywordflow">return</span> 1;
00978     }
00979 
00980     <span class="keywordflow">return</span> 0;
00981 }
00982 <span class="comment"></span>
00983 <span class="comment">/*! Adds the rule \a one to the correct place, keeping the list of rules</span>
00984 <span class="comment">    sorted.</span>
00985 <span class="comment">    \param rules The array of rules collected so far.</span>
00986 <span class="comment">    \param rsort The index to sort this rule by.</span>
00987 <span class="comment">    \param one The rule to add to \a rd.</span>
00988 <span class="comment">    \return Same as find_rule_new(): 1 if an exact match was found, 0</span>
00989 <span class="comment">        otherwise. 2 if \a one is already an existing rule.</span>
00990 <span class="comment">*/</span>
<a name="l00991"></a><a class="code" href="codeform_8c.html#a42">00991</a> <span class="keywordtype">int</span> <a class="code" href="codeform_8c.html#a42">add_rule_pos</a>(<span class="keyword">struct</span> <a class="code" href="structrules__t.html">rules_t</a> *rules, size_t rsort, <span class="keyword">struct</span> <a class="code" href="structonerule__t.html">onerule_t</a> *one) {
00992     size_t sort;
00993     <span class="keywordtype">int</span> r;
00994 
00995     r = <a class="code" href="codeform_8c.html#a67">find_rule_new</a>(rules, one-&gt;<a class="code" href="structonerule__t.html#o0">data</a>.<a class="code" href="structstrings__t.html#o0">data</a>[rsort], &amp;sort);
00996 
00997     <span class="keywordflow">if</span>(r == 2) <span class="keywordflow">return</span> 2;  <span class="comment">/* \a one is already an existing rule. */</span>
00998 
00999     <a class="code" href="codeform_8c.html#a44">add_rule_new</a>(&amp;rules-&gt;<a class="code" href="structrules__t.html#o3">data</a>);
01000 
01001     <span class="keywordflow">if</span>(r) {
01002         <span class="keywordflow">if</span>(sort+1 == rules-&gt;<a class="code" href="structrules__t.html#o3">data</a>.<a class="code" href="structruledata__t.html#o1">number</a>) {
01003             rules-&gt;<a class="code" href="structrules__t.html#o3">data</a>.<a class="code" href="structruledata__t.html#o0">data</a>[rules-&gt;<a class="code" href="structrules__t.html#o3">data</a>.<a class="code" href="structruledata__t.html#o1">number</a>] = one;
01004         }
01005         <span class="keywordflow">else</span> {
01006             memmove(rules-&gt;<a class="code" href="structrules__t.html#o3">data</a>.<a class="code" href="structruledata__t.html#o0">data</a>+sort+2, rules-&gt;<a class="code" href="structrules__t.html#o3">data</a>.<a class="code" href="structruledata__t.html#o0">data</a>+sort+1,
01007                 (rules-&gt;<a class="code" href="structrules__t.html#o3">data</a>.<a class="code" href="structruledata__t.html#o1">number</a> - sort - 1) * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structonerule__t.html">onerule_t</a> *));
01008             rules-&gt;<a class="code" href="structrules__t.html#o3">data</a>.<a class="code" href="structruledata__t.html#o0">data</a>[sort+1] = one;
01009         }
01010     }
01011     <span class="keywordflow">else</span> {
01012         <span class="keywordflow">if</span>(sort == (size_t)-1) {
01013             rules-&gt;<a class="code" href="structrules__t.html#o3">data</a>.<a class="code" href="structruledata__t.html#o0">data</a>[rules-&gt;<a class="code" href="structrules__t.html#o3">data</a>.<a class="code" href="structruledata__t.html#o1">number</a>] = one;
01014         }
01015         <span class="keywordflow">else</span> {
01016             memmove(rules-&gt;<a class="code" href="structrules__t.html#o3">data</a>.<a class="code" href="structruledata__t.html#o0">data</a>+sort+1, rules-&gt;<a class="code" href="structrules__t.html#o3">data</a>.<a class="code" href="structruledata__t.html#o0">data</a>+sort,
01017                 (rules-&gt;<a class="code" href="structrules__t.html#o3">data</a>.<a class="code" href="structruledata__t.html#o1">number</a> - sort) * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structonerule__t.html">onerule_t</a> *));
01018             rules-&gt;<a class="code" href="structrules__t.html#o3">data</a>.<a class="code" href="structruledata__t.html#o0">data</a>[sort] = one;
01019         }
01020     }
01021 
01022     <span class="keywordflow">return</span> r;
01023 }
01024 <span class="comment"></span>
01025 <span class="comment">/*! Allocates a new rule and sets all of its fields to an appropriate value.</span>
01026 <span class="comment">    \return The newly allocated and initialized rule.</span>
01027 <span class="comment">*/</span>
<a name="l01028"></a><a class="code" href="codeform_8c.html#a43">01028</a> <span class="keyword">struct </span><a class="code" href="structonerule__t.html">onerule_t</a> *<a class="code" href="codeform_8c.html#a43">rule_new</a>(<span class="keywordtype">void</span>) {
01029     <span class="keyword">struct </span><a class="code" href="structonerule__t.html">onerule_t</a> *one = malloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structonerule__t.html">onerule_t</a>));
01030     <span class="keywordflow">if</span>(!one) <a class="code" href="codeform_8c.html#a22">out_of_memory</a>(__FILE__, __LINE__);
01031 
01032     one-&gt;<a class="code" href="structonerule__t.html#o2">prev</a> = (size_t)-1;
01033     one-&gt;<a class="code" href="structonerule__t.html#o0">data</a>.<a class="code" href="structstrings__t.html#o0">data</a> = 0;
01034     one-&gt;<a class="code" href="structonerule__t.html#o0">data</a>.<a class="code" href="structstrings__t.html#o1">len</a> = 0;
01035     one-&gt;<a class="code" href="structonerule__t.html#o0">data</a>.<a class="code" href="structstrings__t.html#o2">number</a> = 0;
01036 
01037     <span class="keywordflow">return</span> one;
01038 }
01039 <span class="comment"></span>
01040 <span class="comment">/*! Increments the size of the array of structures in \a rd to accommodate a</span>
01041 <span class="comment">    new rule.</span>
01042 <span class="comment">    \param rd The current array of rules.</span>
01043 <span class="comment">    \return The newly allocated rule.</span>
01044 <span class="comment">*/</span>
<a name="l01045"></a><a class="code" href="codeform_8c.html#a44">01045</a> <span class="keywordtype">void</span> <a class="code" href="codeform_8c.html#a44">add_rule_new</a>(<span class="keyword">struct</span> <a class="code" href="structruledata__t.html">ruledata_t</a> *rd) {
01046     <span class="keyword">struct </span><a class="code" href="structonerule__t.html">onerule_t</a> **p;
01047 
01048     p = realloc(rd-&gt;<a class="code" href="structruledata__t.html#o0">data</a>, (rd-&gt;<a class="code" href="structruledata__t.html#o1">number</a> + 1) * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structonerule__t.html">onerule_t</a> *));
01049 
01050     <span class="keywordflow">if</span>(!p) <a class="code" href="codeform_8c.html#a22">out_of_memory</a>(__FILE__, __LINE__);
01051 
01052     rd-&gt;<a class="code" href="structruledata__t.html#o0">data</a> = p;
01053 }
01054 <span class="comment"></span>
01055 <span class="comment">/*! Adds the rule \a str to the structure \a rules containing the array of</span>
01056 <span class="comment">    rules. In doing so, it separates the parts of the rule, extracts variables</span>
01057 <span class="comment">    and processes escapes; and does a search on the existing rules to find the</span>
01058 <span class="comment">    position of the current one. If the rule is a header it is handled, too.</span>
01059 <span class="comment">    \param rules The structure containing the rules parsed so far, to add the</span>
01060 <span class="comment">        latest rule \a str to.</span>
01061 <span class="comment">    \param str The string representing the rule to add to \a rules.</span>
01062 <span class="comment">    \param file The file that the rule \a str came from.</span>
01063 <span class="comment">    \param line The line of the file that the rule \a str came from.</span>
01064 <span class="comment">*/</span>
<a name="l01065"></a><a class="code" href="codeform_8c.html#a45">01065</a> <span class="keywordtype">void</span> <a class="code" href="codeform_8c.html#a45">add_rule</a>(<span class="keyword">struct</span> <a class="code" href="structrules__t.html">rules_t</a> *rules, <span class="keywordtype">char</span> *str, <span class="keyword">const</span> <span class="keywordtype">char</span> *file, <span class="keywordtype">int</span> line) {
01066     <span class="keyword">enum</span> <a class="code" href="codeform_8c.html#a98">type_t</a> t;
01067     <span class="keywordtype">int</span> r;
01068 
01069     <span class="keywordflow">if</span>(<a class="code" href="codeform_8c.html#a41">add_rule_type</a>(rules, &amp;t, &amp;str, file, line)) <span class="keywordflow">return</span>;
01070 
01071     <span class="keywordflow">if</span>(!<a class="code" href="codeform_8c.html#a48">check_parts</a>(rules-&gt;<a class="code" href="structrules__t.html#o0">type</a>[t].<a class="code" href="structruletype__t.html#o2">parts</a>, rules-&gt;<a class="code" href="structrules__t.html#o0">type</a>[t].<a class="code" href="structruletype__t.html#o3">xparts</a>, str)) {
01072         fprintf(stderr, <span class="stringliteral">"codeform: Error in rule (%s:%i):"</span>
01073             <span class="stringliteral">" Incorrect number of parts (must be %i-%i): \"%s\"\n"</span>,
01074             file ? file : <span class="stringliteral">"-e"</span>, line, rules-&gt;<a class="code" href="structrules__t.html#o0">type</a>[t].<a class="code" href="structruletype__t.html#o2">parts</a>,
01075             rules-&gt;<a class="code" href="structrules__t.html#o0">type</a>[t].<a class="code" href="structruletype__t.html#o2">parts</a> + rules-&gt;<a class="code" href="structrules__t.html#o0">type</a>[t].<a class="code" href="structruletype__t.html#o3">xparts</a>, str);
01076         <span class="keywordflow">return</span>;
01077     }
01078 
01079     rules-&gt;<a class="code" href="structrules__t.html#o5">pr</a>.<a class="code" href="structprevrule__t.html#o1">one</a> = <a class="code" href="codeform_8c.html#a43">rule_new</a>();
01080 
01081     rules-&gt;<a class="code" href="structrules__t.html#o5">pr</a>.<a class="code" href="structprevrule__t.html#o1">one</a>-&gt;<a class="code" href="structonerule__t.html#o1">type</a> = t;
01082 
01083     <a class="code" href="codeform_8c.html#a47">add_parts</a>(&amp;rules-&gt;<a class="code" href="structrules__t.html#o5">pr</a>.<a class="code" href="structprevrule__t.html#o1">one</a>-&gt;<a class="code" href="structonerule__t.html#o0">data</a>,
01084         rules-&gt;<a class="code" href="structrules__t.html#o3">data</a>.<a class="code" href="structruledata__t.html#o1">number</a> ? &amp;rules-&gt;<a class="code" href="structrules__t.html#o5">pr</a>.<a class="code" href="structprevrule__t.html#o2">prev</a>-&gt;<a class="code" href="structonerule__t.html#o0">data</a> : 0, str);
01085     <a class="code" href="codeform_8c.html#a51">process_vars</a>(&amp;rules-&gt;<a class="code" href="structrules__t.html#o1">vars</a>, &amp;rules-&gt;<a class="code" href="structrules__t.html#o5">pr</a>.<a class="code" href="structprevrule__t.html#o1">one</a>-&gt;<a class="code" href="structonerule__t.html#o0">data</a>);
01086     <a class="code" href="codeform_8c.html#a49">process_escapes</a>(&amp;rules-&gt;<a class="code" href="structrules__t.html#o5">pr</a>.<a class="code" href="structprevrule__t.html#o1">one</a>-&gt;<a class="code" href="structonerule__t.html#o0">data</a>);
01087 
01088     rules-&gt;<a class="code" href="structrules__t.html#o5">pr</a>.<a class="code" href="structprevrule__t.html#o0">type</a> = t;
01089 
01090     r = <a class="code" href="codeform_8c.html#a46">add_allocated_rule</a>(rules, &amp;rules-&gt;<a class="code" href="structrules__t.html#o4">cdat</a>[t], rules-&gt;<a class="code" href="structrules__t.html#o0">type</a>[t].<a class="code" href="structruletype__t.html#o1">sort</a>);
01091 
01092     <a class="code" href="codeform_8c.html#a31">free_prevrule</a>(&amp;rules-&gt;<a class="code" href="structrules__t.html#o5">pr</a>);
01093 
01094     rules-&gt;<a class="code" href="structrules__t.html#o5">pr</a>.<a class="code" href="structprevrule__t.html#o2">prev</a> = rules-&gt;<a class="code" href="structrules__t.html#o5">pr</a>.<a class="code" href="structprevrule__t.html#o1">one</a>;
01095     rules-&gt;<a class="code" href="structrules__t.html#o5">pr</a>.<a class="code" href="structprevrule__t.html#o1">one</a> = 0;
01096 
01097     rules-&gt;<a class="code" href="structrules__t.html#o5">pr</a>.<a class="code" href="structprevrule__t.html#o3">freep</a> = r;
01098 }
01099 <span class="comment"></span>
01100 <span class="comment">/*! Add a pre-allocated rule to the list of rules, setting \a prev to \a one.</span>
01101 <span class="comment">    \param rules The array of existing rules.</span>
01102 <span class="comment">    \param cdat The pointer to the cdat structure for \a one's type.</span>
01103 <span class="comment">    \param sort The element to sort \a one by.</span>
01104 <span class="comment">    \return 1 if everything is taken care of and add_rule() may return. !!!</span>
01105 <span class="comment">*/</span>
<a name="l01106"></a><a class="code" href="codeform_8c.html#a46">01106</a> <span class="keywordtype">int</span> <a class="code" href="codeform_8c.html#a46">add_allocated_rule</a>(<span class="keyword">struct</span> <a class="code" href="structrules__t.html">rules_t</a> *rules, <span class="keyword">struct</span> <a class="code" href="structonerule__t.html">onerule_t</a> **cdat,
01107     size_t sort) {
01108 
01109     <span class="keywordflow">if</span>(sort == (size_t)-1) {
01110         <span class="keywordflow">if</span>(!*cdat) *cdat = rules-&gt;<a class="code" href="structrules__t.html#o5">pr</a>.<a class="code" href="structprevrule__t.html#o1">one</a>;
01111         <span class="keywordflow">else</span> <span class="keywordflow">return</span> 1;
01112     }
01113     <span class="keywordflow">else</span> {
01114         <span class="keywordflow">if</span>(<a class="code" href="codeform_8c.html#a42">add_rule_pos</a>(rules, sort, rules-&gt;<a class="code" href="structrules__t.html#o5">pr</a>.<a class="code" href="structprevrule__t.html#o1">one</a>) == 2) {
01115             <span class="keywordflow">return</span> 1;
01116         }
01117 
01118         rules-&gt;<a class="code" href="structrules__t.html#o3">data</a>.<a class="code" href="structruledata__t.html#o1">number</a> ++;
01119     }
01120 
01121     <span class="keywordflow">return</span> 0;
01122 }
01123 <span class="comment"></span>
01124 <span class="comment">/*! Separates the parts of the rule \a str and adds them to \a data, which is a</span>
01125 <span class="comment">    structure containing an array of strings. If a part is "*", it is assigned</span>
01126 <span class="comment">    the value of the same section of the previous rule (determined from</span>
01127 <span class="comment">    \a prev).</span>
01128 <span class="comment">    \param data The structure to add the parts of the rule \a str to.</span>
01129 <span class="comment">    \param prev The structure containing the parts of the previous rule (or</span>
01130 <span class="comment">        NULL if this is the first rule).</span>
01131 <span class="comment">    \param str The string representing the current rule, with all its parts.</span>
01132 <span class="comment">*/</span>
<a name="l01133"></a><a class="code" href="codeform_8c.html#a47">01133</a> <span class="keywordtype">void</span> <a class="code" href="codeform_8c.html#a47">add_parts</a>(<span class="keyword">struct</span> <a class="code" href="structstrings__t.html">strings_t</a> *<a class="code" href="structonerule__t.html#o0">data</a>, <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structstrings__t.html">strings_t</a> *<a class="code" href="structonerule__t.html#o2">prev</a>,
01134     <span class="keyword">const</span> <span class="keywordtype">char</span> *str) {
01135 
01136     <span class="keyword">const</span> <span class="keywordtype">char</span> *p = str;
01137 
01138     <span class="keywordflow">do</span> {
01139         p = strchr(p, <span class="charliteral">':'</span>);
01140 
01141         <span class="keywordflow">if</span>(!p) {  <span class="comment">/* No more ':'s */</span>
01142             <span class="keywordflow">if</span>(prev &amp;&amp; *str == <span class="charliteral">'*'</span> &amp;&amp; !str[1] &amp;&amp; data-&gt;<a class="code" href="structstrings__t.html#o2">number</a> &lt; prev-&gt;<a class="code" href="structstrings__t.html#o2">number</a>) {
01143                 <a class="code" href="codeform_8c.html#a17">add_string_copy</a>(data, prev);
01144             }
01145             <span class="keywordflow">else</span> <a class="code" href="codeform_8c.html#a15">add_string</a>(data, str);
01146         }
01147         <span class="keywordflow">else</span> {
01148             <span class="keywordflow">if</span>(!<a class="code" href="codeform_8c.html#a74">is_backslashed</a>(str, p)) {
01149                 <span class="keywordflow">if</span>(prev &amp;&amp; *str == <span class="charliteral">'*'</span> &amp;&amp; str[1] == <span class="charliteral">':'</span>) {
01150                     <a class="code" href="codeform_8c.html#a17">add_string_copy</a>(data, prev);
01151                 }
01152                 <span class="keywordflow">else</span> <a class="code" href="codeform_8c.html#a16">add_string_len</a>(data, str, p-str);
01153 
01154                 str = p+1;
01155             }
01156 
01157             p ++;
01158         }
01159     } <span class="keywordflow">while</span>(p);
01160 }
01161 <span class="comment"></span>
01162 <span class="comment">/*! Checks to see if the number of parts in the rule \a str has at least</span>
01163 <span class="comment">    \a rparts (required parts) with an optional up to \a xparts extra parts.</span>
01164 <span class="comment">    \param rparts Minimum number of required parts for the rule \a str to have.</span>
01165 <span class="comment">    \param xparts Optional number of extra parts in addition to \a rparts.</span>
01166 <span class="comment">    \param str The string to check the parts of.</span>
01167 <span class="comment">    \return True if the number of parts is in the range rparts to</span>
01168 <span class="comment">        rparts+xparts.</span>
01169 <span class="comment">*/</span>
<a name="l01170"></a><a class="code" href="codeform_8c.html#a48">01170</a> <span class="keywordtype">int</span> <a class="code" href="codeform_8c.html#a48">check_parts</a>(<span class="keywordtype">int</span> rparts, <span class="keywordtype">int</span> xparts, <span class="keyword">const</span> <span class="keywordtype">char</span> *str) {
01171     <span class="keyword">const</span> <span class="keywordtype">char</span> *s = str, *p;
01172     <span class="keywordtype">int</span> parts = 0;
01173 
01174     <span class="keywordflow">do</span> {
01175         p = strchr(s, <span class="charliteral">':'</span>);
01176         <span class="keywordflow">if</span>(!p &amp;&amp; *s) {
01177             parts ++;
01178         }
01179         <span class="keywordflow">else</span> {
01180             <span class="keywordflow">if</span>(!<a class="code" href="codeform_8c.html#a74">is_backslashed</a>(str, p)) {
01181                 parts ++;
01182                 str = s = p+1;
01183             }
01184             <span class="keywordflow">else</span> s ++;
01185         }
01186     } <span class="keywordflow">while</span>(p);
01187 
01188     <span class="keywordflow">return</span> parts &gt;= rparts &amp;&amp; parts &lt;= rparts+xparts;
01189 }
01190 <span class="comment"></span>
01191 <span class="comment">/*! Calls remove_escapes() for every string in the strings structure \a data.</span>
01192 <span class="comment">    \param data The structure containing strings to remove escapes from.</span>
01193 <span class="comment">*/</span>
<a name="l01194"></a><a class="code" href="codeform_8c.html#a49">01194</a> <span class="keywordtype">void</span> <a class="code" href="codeform_8c.html#a49">process_escapes</a>(<span class="keyword">struct</span> <a class="code" href="structstrings__t.html">strings_t</a> *<a class="code" href="structonerule__t.html#o0">data</a>) {
01195     size_t x;
01196 
01197     <span class="keywordflow">for</span>(x = 0; x &lt; data-&gt;<a class="code" href="structstrings__t.html#o2">number</a>; x ++) {
01198         <a class="code" href="codeform_8c.html#a50">remove_escapes</a>(&amp;data-&gt;<a class="code" href="structstrings__t.html#o0">data</a>[x], &amp;data-&gt;<a class="code" href="structstrings__t.html#o1">len</a>[x]);
01199     }
01200 }
01201 <span class="comment"></span>
01202 <span class="comment">/*! Removes characters in \a str, replacing them with what they represent. "\n"</span>
01203 <span class="comment">    turns into a newline. (To do this, a character must be removed, for "\n" is</span>
01204 <span class="comment">    two characters and a newline one; remove_char() is called to this end.)</span>
01205 <span class="comment">    \param str The string to remove escaped characters from.</span>
01206 <span class="comment">    \param len The length of the string, decremented for each escape sequence</span>
01207 <span class="comment">        replaced.</span>
01208 <span class="comment">*/</span>
<a name="l01209"></a><a class="code" href="codeform_8c.html#a50">01209</a> <span class="keywordtype">void</span> <a class="code" href="codeform_8c.html#a50">remove_escapes</a>(<span class="keywordtype">char</span> **str, size_t *len) {
01210     <span class="keywordtype">char</span> *p;
01211     size_t olen = *len;
01212 
01213     <span class="keywordflow">for</span>(p = *str; (p = strchr(p, <span class="charliteral">'\\'</span>)); p ++) {
01214         <a class="code" href="codeform_8c.html#a75">remove_char</a>(p);
01215 
01216         <span class="keywordflow">switch</span>(*p) {
01217         <span class="keywordflow">case</span> <span class="charliteral">'n'</span>:
01218             *p = <span class="charliteral">'\n'</span>;
01219             <span class="keywordflow">break</span>;
01220         <span class="keywordflow">case</span> <span class="charliteral">'t'</span>:
01221             *p = <span class="charliteral">'\t'</span>;
01222             <span class="keywordflow">break</span>;
01223         <span class="keywordflow">default</span>: <span class="keywordflow">break</span>;
01224         }
01225 
01226         (*len) --;
01227     }
01228 
01229     <span class="keywordflow">if</span>(*len != olen) <a class="code" href="codeform_8c.html#a18">shrink_string</a>(str, *len);
01230 }
01231 <span class="comment"></span>
01232 <span class="comment">/*! Calls replace_var_str() for every string in \a data.</span>
01233 <span class="comment">    \param vars A structure containing an array of variables.</span>
01234 <span class="comment">    \param data The data to apply the variables to.</span>
01235 <span class="comment">*/</span>
<a name="l01236"></a><a class="code" href="codeform_8c.html#a51">01236</a> <span class="keywordtype">void</span> <a class="code" href="codeform_8c.html#a51">process_vars</a>(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structrulevars__t.html">rulevars_t</a> *vars, <span class="keyword">struct</span> <a class="code" href="structstrings__t.html">strings_t</a> *<a class="code" href="structonerule__t.html#o0">data</a>) {
01237     size_t x;
01238 
01239     <span class="keywordflow">for</span>(x = 0; x &lt; data-&gt;<a class="code" href="structstrings__t.html#o2">number</a>; x ++) {
01240         <a class="code" href="codeform_8c.html#a52">replace_var_str</a>(vars, &amp;data-&gt;<a class="code" href="structstrings__t.html#o0">data</a>[x]);
01241         data-&gt;<a class="code" href="structstrings__t.html#o1">len</a>[x] = strlen(data-&gt;<a class="code" href="structstrings__t.html#o0">data</a>[x]);  <span class="comment">/* !!! can be determined */</span>
01242     }
01243 }
01244 <span class="comment"></span>
01245 <span class="comment">/*! For every '$' sign in \a str, calls replace_onevar() with every variable,</span>
01246 <span class="comment">    looking for a match.</span>
01247 <span class="comment">    \param vars The structure containing the array of variables.</span>
01248 <span class="comment">    \param str The string to replace occurences of $variable_name with the</span>
01249 <span class="comment">        value of the variable variable_name.</span>
01250 <span class="comment">*/</span>
<a name="l01251"></a><a class="code" href="codeform_8c.html#a52">01251</a> <span class="keywordtype">void</span> <a class="code" href="codeform_8c.html#a52">replace_var_str</a>(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structrulevars__t.html">rulevars_t</a> *vars, <span class="keywordtype">char</span> **str) {
01252     <span class="keywordtype">char</span> *p, *end;
01253 
01254     <span class="keywordflow">for</span>(p = *str; (p = strchr(p, <span class="charliteral">'$'</span>)); p ++) {
01255         <span class="keywordflow">if</span>(!<a class="code" href="codeform_8c.html#a74">is_backslashed</a>(*str, p) &amp;&amp; p[1] == <span class="charliteral">'('</span>
01256             &amp;&amp; (end = strchr(p+2, <span class="charliteral">')'</span>))) {
01257 
01258             <a class="code" href="codeform_8c.html#a54">find_var_replace</a>(vars, str, &amp;p, end);
01259         }
01260     }
01261 }
01262 <span class="comment"></span>
01263 <span class="comment">/*! Resizes the string str to len characters in size. If the memory block was</span>
01264 <span class="comment">    moved, points pos to the same position relative to the new memory block as</span>
01265 <span class="comment">    it was relative to str.</span>
01266 <span class="comment">    \param str The string to resize to \a len characters long.</span>
01267 <span class="comment">    \param pos The position to move if str changes.</span>
01268 <span class="comment">    \param len The new size of the string.</span>
01269 <span class="comment">*/</span>
<a name="l01270"></a><a class="code" href="codeform_8c.html#a53">01270</a> <span class="keywordtype">void</span> <a class="code" href="codeform_8c.html#a53">resize_var_string</a>(<span class="keywordtype">char</span> **str, <span class="keywordtype">char</span> **pos, size_t len) {
01271     <span class="keywordtype">char</span> *p = realloc(*str, len);
01272 
01273     <span class="keywordflow">if</span>(!p) {
01274         <a class="code" href="codeform_8c.html#a22">out_of_memory</a>(__FILE__, __LINE__);
01275     }
01276 
01277     *pos = *pos-*str + p;
01278     *str = p;
01279 }
01280 <span class="comment"></span>
01281 <span class="comment">/*! Binary searches through the existing variables in \a rt for the variable</span>
01282 <span class="comment">    matching the string \a str, calling the function to replace the variable</span>
01283 <span class="comment">    with the text for that variable.</span>
01284 <span class="comment">    \param vars The existing variables to search through.</span>
01285 <span class="comment">    \param str The string containing the variable to search for.</span>
01286 <span class="comment">    \param p The start of the variable to look for (position of the '$').</span>
01287 <span class="comment">    \param end The end of the variable to look for (position of the ')').</span>
01288 <span class="comment">*/</span>
<a name="l01289"></a><a class="code" href="codeform_8c.html#a54">01289</a> <span class="keywordtype">void</span> <a class="code" href="codeform_8c.html#a54">find_var_replace</a>(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structrulevars__t.html">rulevars_t</a> *vars, <span class="keywordtype">char</span> **str, <span class="keywordtype">char</span> **p,
01290     <span class="keywordtype">char</span> *end) {
01291 
01292     size_t mid = (size_t)-1, first = 0, last = vars-&gt;<a class="code" href="structrulevars__t.html#o1">number</a>-1;
01293     size_t pos = (size_t)-1;
01294     <span class="keywordtype">int</span> v = 0;
01295 
01296     pos = (size_t)-1;
01297 
01298     <span class="keywordflow">if</span>(!vars-&gt;<a class="code" href="structrulevars__t.html#o1">number</a>) <span class="keywordflow">return</span>;
01299 
01300     <span class="keywordflow">while</span>(first &lt;= last &amp;&amp; last != (size_t)-1) {
01301         mid = (first + last) / 2;
01302 
01303         v = <a class="code" href="codeform_8c.html#a55">replace_onevar</a>(vars-&gt;<a class="code" href="structrulevars__t.html#o0">data</a>[mid], str, p, end);
01304 
01305         <span class="keywordflow">if</span>(v &lt; 0) last = mid-1;
01306         <span class="keywordflow">else</span> <span class="keywordflow">if</span>(v &gt; 0) first = mid+1;
01307         <span class="keywordflow">else</span> {
01308             pos = mid;
01309             first = mid+1;
01310 
01311             *p = *str-1;
01312             <span class="keywordflow">break</span>;
01313         }
01314     }
01315 
01316     <span class="keywordflow">if</span>(pos == (size_t)-1) {
01317         <a class="code" href="codeform_8c.html#a56">replace_novar</a>(end-*p-2, str, p);
01318         (*p) --;
01319     }
01320     <span class="keywordflow">else</span> {
01321         <span class="keywordflow">if</span>(v &lt; 0) pos = mid;
01322         <span class="keywordflow">else</span> pos = mid+1;
01323     }
01324 }
01325 <span class="comment"></span>
01326 <span class="comment">/*! Replaces the position \a pos in the string \a str (if it matches a '$' and</span>
01327 <span class="comment">    the variable's name) with the text the variable is replaced with.</span>
01328 <span class="comment">    \param var A structure containing the variable's name and text to replace</span>
01329 <span class="comment">        with.</span>
01330 <span class="comment">    \param str The string containing the variable.</span>
01331 <span class="comment">    \param pos The start of the string to do the replacing in (dynamically</span>
01332 <span class="comment">        reallocated to the new size).</span>
01333 <span class="comment">    \param end The position in \a str of the '$' in a variable name.</span>
01334 <span class="comment">    \return Nonzero if a text substitution was made.</span>
01335 <span class="comment">*/</span>
<a name="l01336"></a><a class="code" href="codeform_8c.html#a55">01336</a> <span class="keywordtype">int</span> <a class="code" href="codeform_8c.html#a55">replace_onevar</a>(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structonevar__t.html">onevar_t</a> *var, <span class="keywordtype">char</span> **str, <span class="keywordtype">char</span> **pos,
01337     <span class="keywordtype">char</span> *end) {
01338 
01339     size_t olen, plen;
01340     <span class="keywordtype">int</span> v;
01341 
01342     <span class="keywordflow">if</span>(!(v = strncmp(*pos+2, var-&gt;<a class="code" href="structonevar__t.html#o0">from</a>, end - *pos - 2))) {
01343         <span class="keywordflow">if</span>(var-&gt;<a class="code" href="structonevar__t.html#o0">from</a>[end - *pos - 2]) <span class="keywordflow">return</span> -1;
01344 
01345         olen = strlen(*str);
01346         plen = olen + *str - *pos;
01347 
01348         <span class="keywordflow">if</span>(var-&gt;<a class="code" href="structonevar__t.html#o2">flen</a>+2 &lt; var-&gt;<a class="code" href="structonevar__t.html#o3">tlen</a>) {
01349             <a class="code" href="codeform_8c.html#a53">resize_var_string</a>(str, pos, olen - var-&gt;<a class="code" href="structonevar__t.html#o2">flen</a> + var-&gt;<a class="code" href="structonevar__t.html#o3">tlen</a> - 2);
01350 
01351             memmove(*pos + var-&gt;<a class="code" href="structonevar__t.html#o3">tlen</a>, *pos + var-&gt;<a class="code" href="structonevar__t.html#o2">flen</a>+3, plen - var-&gt;<a class="code" href="structonevar__t.html#o2">flen</a>-2);
01352         }
01353         <span class="keywordflow">else</span> {
01354             memmove(*pos + var-&gt;<a class="code" href="structonevar__t.html#o3">tlen</a>, *pos + var-&gt;<a class="code" href="structonevar__t.html#o2">flen</a>+3, plen - var-&gt;<a class="code" href="structonevar__t.html#o2">flen</a>-2);
01355 
01356             <a class="code" href="codeform_8c.html#a53">resize_var_string</a>(str, pos, olen - var-&gt;<a class="code" href="structonevar__t.html#o2">flen</a> + var-&gt;<a class="code" href="structonevar__t.html#o3">tlen</a> - 2);
01357         }
01358 
01359         memmove(*pos, var-&gt;<a class="code" href="structonevar__t.html#o1">to</a>, var-&gt;<a class="code" href="structonevar__t.html#o3">tlen</a>);
01360     }
01361 
01362     <span class="keywordflow">return</span> v;
01363 }
01364 <span class="comment"></span>
01365 <span class="comment">/*! Replaces the variable at \a pos in the string \a str with a null value, "".</span>
01366 <span class="comment">    \param cp The length of the variable.</span>
01367 <span class="comment">    \param str The start of the string to do the replacing in (dynamically</span>
01368 <span class="comment">        reallocated to the new size).</span>
01369 <span class="comment">    \param pos The position in \a str of the variable.</span>
01370 <span class="comment">*/</span>
<a name="l01371"></a><a class="code" href="codeform_8c.html#a56">01371</a> <span class="keywordtype">void</span> <a class="code" href="codeform_8c.html#a56">replace_novar</a>(size_t cp, <span class="keywordtype">char</span> **str, <span class="keywordtype">char</span> **pos) {
01372     size_t olen, plen;
01373 
01374     olen = strlen(*str);
01375     plen = olen + *str - *pos;
01376 
01377     memmove(*pos, *pos + cp+3, plen - cp-2);
01378 
01379     <a class="code" href="codeform_8c.html#a53">resize_var_string</a>(str, pos, olen - cp-2);
01380 }
01381 <span class="comment"></span>
01382 <span class="comment">/*! Returns the number of the header that the rule \a str represents.</span>
01383 <span class="comment">    \param rules The rules structure that holds the types.</span>
01384 <span class="comment">    \param str The string representing the rule that may be a header.</span>
01385 <span class="comment">    \param type A pointer to set to the type of the header.</span>
01386 <span class="comment">    \return Zero if \a str is not a header; (size_t)-1 if it is a nonexistent</span>
01387 <span class="comment">        header; 1 if it is a header; and the position of the end of the header</span>
01388 <span class="comment">        (&gt;= 2) if it is an inline header.</span>
01389 <span class="comment">*/</span>
<a name="l01390"></a><a class="code" href="codeform_8c.html#a57">01390</a> size_t <a class="code" href="codeform_8c.html#a57">get_type</a>(<span class="keyword">struct</span> <a class="code" href="structrules__t.html">rules_t</a> *rules, <span class="keyword">const</span> <span class="keywordtype">char</span> *str, <span class="keyword">enum</span> <a class="code" href="codeform_8c.html#a98">type_t</a> *<a class="code" href="structonerule__t.html#o1">type</a>) {
01391     <span class="keyword">enum</span> <a class="code" href="codeform_8c.html#a98">type_t</a> x;
01392     <span class="keyword">const</span> <span class="keywordtype">char</span> *p;
01393     size_t len = (size_t)-1;
01394 
01395     <span class="keywordflow">if</span>(*str != <span class="charliteral">'='</span>) <span class="keywordflow">return</span> 0;
01396     <span class="keywordflow">if</span>((p = strchr(str, <span class="charliteral">':'</span>))) len = p-str-1;
01397 
01398     <span class="keywordflow">for</span>(x = 0; x &lt; <a class="code" href="codeform_8c.html#a98a10">TYPES</a>; x ++) {
01399         <span class="keywordflow">if</span>(!strncmp(rules-&gt;<a class="code" href="structrules__t.html#o0">type</a>[x].<a class="code" href="structruletype__t.html#o0">name</a>, str+1, len)) {
01400             *type = x;
01401             <span class="keywordflow">return</span> (p ? len+2 : 1);
01402         }
01403     }
01404 
01405     <span class="keywordflow">return</span> (size_t)-1;
01406 }
01407 <span class="comment"></span>
01408 <span class="comment">/*! Opens all the input files and pass them on to read_file(). Copies the other</span>
01409 <span class="comment">    output files from the first output file with copy_file().</span>
01410 <span class="comment">    \param rules The structure containing all the rules.</span>
01411 <span class="comment">    \param inputfn The strings_t structure with all the input file names.</span>
01412 <span class="comment">    \param outputfn The files to write to. All the data is written to the first</span>
01413 <span class="comment">        one, and that file is then copied to all the others.</span>
01414 <span class="comment">*/</span>
<a name="l01415"></a><a class="code" href="codeform_8c.html#a58">01415</a> <span class="keywordtype">void</span> <a class="code" href="codeform_8c.html#a58">parse_files</a>(<span class="keyword">struct</span> <a class="code" href="structrules__t.html">rules_t</a> *rules, <span class="keyword">struct</span> <a class="code" href="structstrings__t.html">strings_t</a> *inputfn,
01416     <span class="keyword">struct</span> <a class="code" href="structstrings__t.html">strings_t</a> *outputfn) {
01417 
01418     FILE *out = 0;
01419     size_t x, y;
01420 
01421     <span class="keywordflow">for</span>(x = 0; x &lt; outputfn-&gt;<a class="code" href="structstrings__t.html#o2">number</a>
01422         &amp;&amp; !(out = <a class="code" href="codeform_8c.html#a32">open_file</a>(outputfn-&gt;<a class="code" href="structstrings__t.html#o0">data</a>[x], <span class="stringliteral">"w+"</span>)); x ++);
01423 
01424     <span class="keywordflow">if</span>(!out) {
01425         <span class="keywordflow">if</span>(x) fprintf(stderr, <span class="stringliteral">"codeform: No output files could be opened,"</span>
01426             <span class="stringliteral">" using stdout\n"</span>);
01427         out = stdout;
01428     }
01429 
01430     <span class="keywordflow">for</span>(y = 0; y &lt; inputfn-&gt;<a class="code" href="structstrings__t.html#o2">number</a>; y ++) {
01431         <a class="code" href="codeform_8c.html#a59">read_file</a>(rules, inputfn-&gt;<a class="code" href="structstrings__t.html#o0">data</a>[y], out);
01432     }
01433 
01434     <span class="keywordflow">if</span>(!inputfn-&gt;<a class="code" href="structstrings__t.html#o2">number</a>) <a class="code" href="codeform_8c.html#a59">read_file</a>(rules, <span class="stringliteral">"-"</span>, out);
01435 
01436     <span class="keywordflow">for</span>(y = 1; y &lt; outputfn-&gt;<a class="code" href="structstrings__t.html#o2">number</a>; y ++) {
01437         <a class="code" href="codeform_8c.html#a69">copy_file</a>(out, outputfn-&gt;<a class="code" href="structstrings__t.html#o0">data</a>[y]);
01438     }
01439 
01440     <span class="keywordflow">if</span>(out != stdout) fclose(out);
01441 }
01442 <span class="comment"></span>
01443 <span class="comment">/*! Reads from the file \a fn, passing each line read to parse_line().</span>
01444 <span class="comment">    Determines when the end or the start of the file \a fn has been reached,</span>
01445 <span class="comment">    passing this information on to parse_line().</span>
01446 <span class="comment">    \param rules Used only to pass on to parse_line().</span>
01447 <span class="comment">    \param fn The filename to read from.</span>
01448 <span class="comment">    \param out Used only to pass on to parse_line().</span>
01449 <span class="comment">*/</span>
<a name="l01450"></a><a class="code" href="codeform_8c.html#a59">01450</a> <span class="keywordtype">void</span> <a class="code" href="codeform_8c.html#a59">read_file</a>(<span class="keyword">struct</span> <a class="code" href="structrules__t.html">rules_t</a> *rules, <span class="keyword">const</span> <span class="keywordtype">char</span> *fn, FILE *out) {
01451     FILE *in = <a class="code" href="codeform_8c.html#a32">open_file</a>(fn, <span class="stringliteral">"r"</span>);
01452     <span class="keywordtype">char</span> *line = malloc(BUFSIZ);
01453     <span class="keyword">struct </span><a class="code" href="structtypefunc__t.html">typefunc_t</a> tf;
01454     size_t len, alen = BUFSIZ;
01455     <span class="keywordtype">int</span> quit = 0;
01456 
01457     <span class="keywordflow">if</span>(!in) <span class="keywordflow">return</span>;
01458 
01459     <span class="keywordflow">if</span>(!line) <a class="code" href="codeform_8c.html#a22">out_of_memory</a>(__FILE__, __LINE__);
01460     *line = 0;
01461 
01462     tf.<a class="code" href="structtypefunc__t.html#o7">func</a>.<a class="code" href="structfunclist__t.html#o0">which</a> = 0;
01463     tf.<a class="code" href="structtypefunc__t.html#o7">func</a>.type = 0;
01464     tf.<a class="code" href="structtypefunc__t.html#o7">func</a>.number = 0;
01465     tf.<a class="code" href="structtypefunc__t.html#o7">func</a>.nest = 1;
01466     tf.<a class="code" href="structtypefunc__t.html#o3">pos</a> = <a class="code" href="codeform_8c.html#a99a12">POS_START</a>;
01467     tf.<a class="code" href="structtypefunc__t.html#o8">list</a> = &amp;rules-&gt;<a class="code" href="structrules__t.html#o2">list</a>;
01468 
01469     tf.<a class="code" href="structtypefunc__t.html#o0">out</a> = out;
01470     <a class="code" href="codeform_8c.html#a60">parse_line</a>(rules, line, out, &amp;tf);
01471 
01472     <span class="keywordflow">do</span> {
01473         len = 0;
01474 
01475         <span class="keywordflow">if</span>(!<a class="code" href="codeform_8c.html#a33">get_string</a>(&amp;line, 0, &amp;alen, in)) {
01476             tf.<a class="code" href="structtypefunc__t.html#o3">pos</a> |= <a class="code" href="codeform_8c.html#a99a13">POS_END</a>;
01477             quit = 1;
01478         }
01479 
01480         tf.<a class="code" href="structtypefunc__t.html#o0">out</a> = out;
01481         <a class="code" href="codeform_8c.html#a60">parse_line</a>(rules, line, out, &amp;tf);
01482 
01483         tf.<a class="code" href="structtypefunc__t.html#o3">pos</a> = 0;
01484     } <span class="keywordflow">while</span>(!quit);
01485 
01486     <span class="keywordflow">if</span>(in != stdin) fclose(in);
01487 
01488     free(line);
01489 }
01490 <span class="comment"></span>
01491 <span class="comment">/*! Parses a line from an input file, calling type_funcs for every character.</span>
01492 <span class="comment">    If one call is successful, calls each type_func again.</span>
01493 <span class="comment">    \param rules The structure containing all the rules for parsing.</span>
01494 <span class="comment">    \param line The line from the input file to parse.</span>
01495 <span class="comment">    \param out The output file stream to write the results to.</span>
01496 <span class="comment">    \param tf The structure that is passed to all the type_func functions,</span>
01497 <span class="comment">        along with the rule_t structure appropriate for it.</span>
01498 <span class="comment">*/</span>
<a name="l01499"></a><a class="code" href="codeform_8c.html#a60">01499</a> <span class="keywordtype">void</span> <a class="code" href="codeform_8c.html#a60">parse_line</a>(<span class="keyword">struct</span> <a class="code" href="structrules__t.html">rules_t</a> *rules, <span class="keywordtype">char</span> *line, FILE *<a class="code" href="structtypefunc__t.html#o0">out</a>,
01500     <span class="keyword">struct</span> <a class="code" href="structtypefunc__t.html">typefunc_t</a> *tf) {
01501 
01502     <span class="keywordtype">char</span> *<a class="code" href="structtypefunc__t.html#o1">p</a> = line;
01503     <span class="keywordtype">int</span> <a class="code" href="structtypefunc__t.html#o2">iw</a> = 0, redo;
01504 
01505     tf-&gt;<a class="code" href="structtypefunc__t.html#o1">p</a> = &amp;p;
01506 
01507     <span class="keywordflow">do</span> {
01508         <span class="keywordflow">do</span> {
01509             redo = 0;
01510 
01511             tf-&gt;<a class="code" href="structtypefunc__t.html#o2">iw</a> = iw;
01512             tf-&gt;<a class="code" href="structtypefunc__t.html#o4">n</a> = p - line;
01513 
01514             <span class="keywordflow">if</span>(tf-&gt;<a class="code" href="structtypefunc__t.html#o7">func</a>.number) {
01515                 <span class="keywordflow">if</span>(<a class="code" href="codeform_8c.html#a61">call_one_type</a>(rules, tf) || <a class="code" href="codeform_8c.html#a62">call_type_cdat</a>(rules, tf)) {
01516                     redo = 1;
01517                 }
01518             }
01519 
01520             <span class="keywordflow">if</span>(!redo &amp;&amp; <a class="code" href="codeform_8c.html#a63">call_type_funcs</a>(rules, tf)) redo = 1;
01521 
01522             <span class="keywordflow">if</span>(!redo) {
01523                 <span class="keywordflow">if</span>(*p) {
01524                     <span class="keywordflow">if</span>(!isspace(*p)) {
01525                         <a class="code" href="codeform_8c.html#a85">append_rulelist</a>(0, 0, &amp;rules-&gt;<a class="code" href="structrules__t.html#o2">list</a>, out);
01526                         putc(*p, out);
01527                     }
01528                     <span class="keywordflow">else</span> <span class="keywordflow">if</span>(rules-&gt;<a class="code" href="structrules__t.html#o2">list</a>.<a class="code" href="structrulelist__t.html#o1">to</a>) {
01529                         <a class="code" href="codeform_8c.html#a83">add_ws_rulelist</a>(&amp;rules-&gt;<a class="code" href="structrules__t.html#o2">list</a>, *p);
01530                     }
01531                     <span class="keywordflow">else</span> putc(*p, out);
01532                 }
01533 
01534                 iw = <a class="code" href="codeform_8c.html#a73">is_word</a>(*p);
01535             }
01536             <span class="keywordflow">else</span> iw = <a class="code" href="codeform_8c.html#a76">is_word_prev</a>(line, p);
01537         } <span class="keywordflow">while</span>(redo);
01538     } <span class="keywordflow">while</span>(*p++);
01539 
01540     <a class="code" href="codeform_8c.html#a85">append_rulelist</a>(0, 0, &amp;rules-&gt;<a class="code" href="structrules__t.html#o2">list</a>, out);
01541 }
01542 <span class="comment"></span>
01543 <span class="comment">/*! Calls the type_func function that may end the latest comment.</span>
01544 <span class="comment">    \param rules The structure containing the rules and types.</span>
01545 <span class="comment">    \param tf The structure that is passed to the type_func function.</span>
01546 <span class="comment">    \return Nonzero if the type_func function ended the comment.</span>
01547 <span class="comment">*/</span>
<a name="l01548"></a><a class="code" href="codeform_8c.html#a61">01548</a> <span class="keywordtype">int</span> <a class="code" href="codeform_8c.html#a61">call_one_type</a>(<span class="keyword">struct</span> <a class="code" href="structrules__t.html">rules_t</a> *rules, <span class="keyword">struct</span> <a class="code" href="structtypefunc__t.html">typefunc_t</a> *tf) {
01549     <span class="keywordtype">int</span> r;
01550 
01551     tf-&gt;<a class="code" href="structtypefunc__t.html#o5">number</a> = tf-&gt;<a class="code" href="structtypefunc__t.html#o7">func</a>.<a class="code" href="structfunclist__t.html#o0">which</a>[tf-&gt;<a class="code" href="structtypefunc__t.html#o7">func</a>.number-1];
01552     tf-&gt;<a class="code" href="structtypefunc__t.html#o6">type</a> = tf-&gt;<a class="code" href="structtypefunc__t.html#o7">func</a>.type[tf-&gt;<a class="code" href="structtypefunc__t.html#o7">func</a>.number-1];
01553 
01554     r = (*rules-&gt;<a class="code" href="structrules__t.html#o0">type</a>[tf-&gt;<a class="code" href="structtypefunc__t.html#o6">type</a>].<a class="code" href="structruletype__t.html#o4">func</a>)
01555         (rules-&gt;<a class="code" href="structrules__t.html#o3">data</a>.<a class="code" href="structruledata__t.html#o0">data</a>[tf-&gt;<a class="code" href="structtypefunc__t.html#o5">number</a>], tf);
01556 
01557     <span class="keywordflow">if</span>(r &lt; 0) <a class="code" href="codeform_8c.html#a82">remove_from_funclist</a>(&amp;tf-&gt;<a class="code" href="structtypefunc__t.html#o7">func</a>);
01558 
01559     <span class="keywordflow">return</span> r;
01560 }
01561 <span class="comment"></span>
01562 <span class="comment">/*! Calls the type_func functions that have a sort of \c (size_t)-1, which have</span>
01563 <span class="comment">    only one rule, stored in the cdat[] array in \a rules.</span>
01564 <span class="comment">    \param rules The structure containing the cdat array and sorts for the</span>
01565 <span class="comment">        type_func functions.</span>
01566 <span class="comment">    \param tf The structure that is passed to the type_func functions.</span>
01567 <span class="comment">    \return True if one of the functions called returned true.</span>
01568 <span class="comment">*/</span>
<a name="l01569"></a><a class="code" href="codeform_8c.html#a62">01569</a> <span class="keywordtype">int</span> <a class="code" href="codeform_8c.html#a62">call_type_cdat</a>(<span class="keyword">struct</span> <a class="code" href="structrules__t.html">rules_t</a> *rules, <span class="keyword">struct</span> <a class="code" href="structtypefunc__t.html">typefunc_t</a> *tf) {
01570     <span class="keyword">enum</span> <a class="code" href="codeform_8c.html#a98">type_t</a> x;
01571 
01572     <span class="keywordflow">for</span>(x = 0; x &lt; <a class="code" href="codeform_8c.html#a98a10">TYPES</a>; x ++) {
01573         <span class="keywordflow">if</span>(rules-&gt;<a class="code" href="structrules__t.html#o0">type</a>[x].<a class="code" href="structruletype__t.html#o1">sort</a> == (size_t)-1 &amp;&amp; rules-&gt;<a class="code" href="structrules__t.html#o4">cdat</a>[x]) {
01574             tf-&gt;<a class="code" href="structtypefunc__t.html#o5">number</a> = (size_t)-1;
01575             tf-&gt;<a class="code" href="structtypefunc__t.html#o6">type</a> = x;
01576 
01577             <span class="keywordflow">if</span>((*rules-&gt;<a class="code" href="structrules__t.html#o0">type</a>[x].<a class="code" href="structruletype__t.html#o4">func</a>)(rules-&gt;<a class="code" href="structrules__t.html#o4">cdat</a>[x], tf)) {
01578                 <span class="keywordflow">return</span> 1;
01579             }
01580         }
01581     }
01582 
01583     <span class="keywordflow">return</span> 0;
01584 }
01585 <span class="comment"></span>
01586 <span class="comment">/*! Calls the appropriate type_func function for a rule if a match to the</span>
01587 <span class="comment">    current position in the line was found.</span>
01588 <span class="comment">    \param rules The structure containing the rules to search through.</span>
01589 <span class="comment">    \param tf The structure passed to the type_func functions.</span>
01590 <span class="comment">    \return True if a function was called.</span>
01591 <span class="comment">*/</span>
<a name="l01592"></a><a class="code" href="codeform_8c.html#a63">01592</a> <span class="keywordtype">int</span> <a class="code" href="codeform_8c.html#a63">call_type_funcs</a>(<span class="keyword">struct</span> <a class="code" href="structrules__t.html">rules_t</a> *rules, <span class="keyword">struct</span> <a class="code" href="structtypefunc__t.html">typefunc_t</a> *tf) {
01593     size_t match;
01594 
01595     <span class="keywordflow">if</span>(<a class="code" href="codeform_8c.html#a62">call_type_cdat</a>(rules, tf)) <span class="keywordflow">return</span> 1;
01596 
01597     <span class="keywordflow">if</span>(<a class="code" href="codeform_8c.html#a66">find_rule_match</a>(rules, *tf-&gt;<a class="code" href="structtypefunc__t.html#o1">p</a>, &amp;match)) {
01598         tf-&gt;<a class="code" href="structtypefunc__t.html#o5">number</a> = match;
01599         tf-&gt;<a class="code" href="structtypefunc__t.html#o6">type</a> = rules-&gt;<a class="code" href="structrules__t.html#o3">data</a>.<a class="code" href="structruledata__t.html#o0">data</a>[match]-&gt;<a class="code" href="structonerule__t.html#o1">type</a>;
01600 
01601         <span class="keywordflow">if</span>((*rules-&gt;<a class="code" href="structrules__t.html#o0">type</a>[tf-&gt;<a class="code" href="structtypefunc__t.html#o6">type</a>].<a class="code" href="structruletype__t.html#o4">func</a>)(rules-&gt;<a class="code" href="structrules__t.html#o3">data</a>.<a class="code" href="structruledata__t.html#o0">data</a>[match], tf)) {
01602             <span class="keywordflow">return</span> 1;
01603         }
01604     }
01605 
01606     <span class="keywordflow">return</span> 0;
01607 }
01608 <span class="comment"></span>
01609 <span class="comment">/*! Sets the prev members of every rule in \a rules, calling set_follow_prev()</span>
01610 <span class="comment">    for each rule.</span>
01611 <span class="comment">    \param rules The structure containing the rules to set the prev member of.</span>
01612 <span class="comment">*/</span>
<a name="l01613"></a><a class="code" href="codeform_8c.html#a64">01613</a> <span class="keywordtype">void</span> <a class="code" href="codeform_8c.html#a64">set_rules_prev</a>(<span class="keyword">struct</span> <a class="code" href="structrules__t.html">rules_t</a> *rules) {
01614     size_t x, y;
01615 
01616     <span class="keywordflow">for</span>(x = 0; x &lt; <a class="code" href="codeform_8c.html#a98a10">TYPES</a>; x ++) {
01617         <span class="keywordflow">for</span>(y = 0; y &lt; rules-&gt;<a class="code" href="structrules__t.html#o3">data</a>.<a class="code" href="structruledata__t.html#o1">number</a>; y ++) {
01618             <span class="keywordflow">if</span>(rules-&gt;<a class="code" href="structrules__t.html#o0">type</a>[x].<a class="code" href="structruletype__t.html#o1">sort</a> != (size_t)-1) {
01619                 <a class="code" href="codeform_8c.html#a65">set_follow_prev</a>(rules, y);
01620             }
01621         }
01622     }
01623 }
01624 <span class="comment"></span>
01625 <span class="comment">/*! Sets the prev members of the structures following the rule \a start to</span>
01626 <span class="comment">    \a start if their first characters (the length of the rule \a start) match</span>
01627 <span class="comment">    the characters in the rule \a start.</span>
01628 <span class="comment">    \param rules The structure containing the rules and sorts.</span>
01629 <span class="comment">    \param start The element in the array of rules to start at (and set prevs</span>
01630 <span class="comment">        to).</span>
01631 <span class="comment">*/</span>
<a name="l01632"></a><a class="code" href="codeform_8c.html#a65">01632</a> <span class="keywordtype">void</span> <a class="code" href="codeform_8c.html#a65">set_follow_prev</a>(<span class="keyword">struct</span> <a class="code" href="structrules__t.html">rules_t</a> *rules, size_t start) {
01633     size_t x;
01634 
01635     <span class="keywordflow">for</span>(x = start+1; x &lt; rules-&gt;<a class="code" href="structrules__t.html#o3">data</a>.<a class="code" href="structruledata__t.html#o1">number</a>; x ++) {
01636         <span class="keywordflow">if</span>(strncmp(rules-&gt;<a class="code" href="structrules__t.html#o3">data</a>.<a class="code" href="structruledata__t.html#o0">data</a>[start]-&gt;<a class="code" href="structonerule__t.html#o0">data</a>
01637                 .<a class="code" href="structstrings__t.html#o0">data</a>[rules-&gt;<a class="code" href="structrules__t.html#o0">type</a>[rules-&gt;<a class="code" href="structrules__t.html#o3">data</a>.<a class="code" href="structruledata__t.html#o0">data</a>[start]-&gt;<a class="code" href="structonerule__t.html#o1">type</a>].sort],
01638             rules-&gt;<a class="code" href="structrules__t.html#o3">data</a>.<a class="code" href="structruledata__t.html#o0">data</a>[x]-&gt;<a class="code" href="structonerule__t.html#o0">data</a>
01639                 .<a class="code" href="structstrings__t.html#o0">data</a>[rules-&gt;<a class="code" href="structrules__t.html#o0">type</a>[rules-&gt;<a class="code" href="structrules__t.html#o3">data</a>.<a class="code" href="structruledata__t.html#o0">data</a>[x]-&gt;<a class="code" href="structonerule__t.html#o1">type</a>].sort],
01640             rules-&gt;<a class="code" href="structrules__t.html#o3">data</a>.<a class="code" href="structruledata__t.html#o0">data</a>[start]-&gt;<a class="code" href="structonerule__t.html#o0">data</a>
01641                 .<a class="code" href="structstrings__t.html#o1">len</a>[rules-&gt;<a class="code" href="structrules__t.html#o0">type</a>[rules-&gt;<a class="code" href="structrules__t.html#o3">data</a>.<a class="code" href="structruledata__t.html#o0">data</a>[start]-&gt;<a class="code" href="structonerule__t.html#o1">type</a>].sort])) {
01642 
01643             <span class="keywordflow">break</span>;
01644         }
01645 
01646         rules-&gt;<a class="code" href="structrules__t.html#o3">data</a>.<a class="code" href="structruledata__t.html#o0">data</a>[x]-&gt;<a class="code" href="structonerule__t.html#o2">prev</a> = start;
01647     }
01648 }
01649 <span class="comment"></span>
01650 <span class="comment">/*! Executes a binary search for \a p in the existing rules in \a rt. The</span>
01651 <span class="comment">    longest match is assigned to \a pos.</span>
01652 <span class="comment">    \param rules The array of existing rules to search through.</span>
01653 <span class="comment">    \param p The string to search through the rules for.</span>
01654 <span class="comment">    \param pos The variable to set to the longest match found, if any; if none,</span>
01655 <span class="comment">        set to (size_t)-1.</span>
01656 <span class="comment">    \return 1 if an exact match was found, 0 otherwise.</span>
01657 <span class="comment">*/</span>
<a name="l01658"></a><a class="code" href="codeform_8c.html#a66">01658</a> <span class="keywordtype">int</span> <a class="code" href="codeform_8c.html#a66">find_rule_match</a>(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structrules__t.html">rules_t</a> *rules, <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="structtypefunc__t.html#o1">p</a>, size_t *<a class="code" href="structtypefunc__t.html#o3">pos</a>) {
01659     <span class="keywordflow">if</span>(<a class="code" href="codeform_8c.html#a67">find_rule_new</a>(rules, p, pos)) <span class="keywordflow">return</span> 1;
01660 
01661     <span class="keywordflow">if</span>(*pos &lt; rules-&gt;<a class="code" href="structrules__t.html#o3">data</a>.<a class="code" href="structruledata__t.html#o1">number</a>) <span class="keywordflow">return</span> <a class="code" href="codeform_8c.html#a68">find_rule_prev</a>(rules, p, pos);
01662 
01663     <span class="keywordflow">return</span> 0;
01664 }
01665 <span class="comment"></span>
01666 <span class="comment">/*! Binary searches through the existing rules in \a rt for the position that</span>
01667 <span class="comment">    the rule \a p should be in, putting the result in \a pos.</span>
01668 <span class="comment">    \param rules The structure containing the array of existing rules.</span>
01669 <span class="comment">    \param p The new rule to search for.</span>
01670 <span class="comment">    \param pos The variable to store the position found in. Set to (size_t)-1</span>
01671 <span class="comment">        if no match was found.</span>
01672 <span class="comment">    \return 1 if an exact match (to the shortest length) was found, 0</span>
01673 <span class="comment">        otherwise. 2 if an exact match the whole way was found.</span>
01674 <span class="comment">*/</span>
<a name="l01675"></a><a class="code" href="codeform_8c.html#a67">01675</a> <span class="keywordtype">int</span> <a class="code" href="codeform_8c.html#a67">find_rule_new</a>(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structrules__t.html">rules_t</a> *rules, <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="structtypefunc__t.html#o1">p</a>, size_t *<a class="code" href="structtypefunc__t.html#o3">pos</a>) {
01676     size_t mid = (size_t)-1, first = 0, last = rules-&gt;<a class="code" href="structrules__t.html#o3">data</a>.<a class="code" href="structruledata__t.html#o1">number</a>-1, sort;
01677     <span class="keywordtype">int</span> v = 0;
01678 
01679     *pos = (size_t)-1;
01680 
01681     <span class="keywordflow">if</span>(!rules-&gt;<a class="code" href="structrules__t.html#o3">data</a>.<a class="code" href="structruledata__t.html#o1">number</a>) <span class="keywordflow">return</span> 0;
01682 
01683     <span class="keywordflow">while</span>(first &lt;= last &amp;&amp; last != (size_t)-1) {
01684         mid = (first + last) / 2;
01685         sort = rules-&gt;<a class="code" href="structrules__t.html#o0">type</a>[rules-&gt;<a class="code" href="structrules__t.html#o3">data</a>.<a class="code" href="structruledata__t.html#o0">data</a>[mid]-&gt;<a class="code" href="structonerule__t.html#o1">type</a>].<a class="code" href="structruletype__t.html#o1">sort</a>;
01686 
01687         v = strncmp(p, rules-&gt;<a class="code" href="structrules__t.html#o3">data</a>.<a class="code" href="structruledata__t.html#o0">data</a>[mid]-&gt;<a class="code" href="structonerule__t.html#o0">data</a>.<a class="code" href="structstrings__t.html#o0">data</a>[sort],
01688             rules-&gt;<a class="code" href="structrules__t.html#o3">data</a>.<a class="code" href="structruledata__t.html#o0">data</a>[mid]-&gt;<a class="code" href="structonerule__t.html#o0">data</a>.<a class="code" href="structstrings__t.html#o1">len</a>[sort]);
01689 
01690         <span class="keywordflow">if</span>(first == last &amp;&amp; v) <span class="keywordflow">break</span>;
01691 
01692         <span class="keywordflow">if</span>(v &lt; 0) last = mid-1;
01693         <span class="keywordflow">else</span> <span class="keywordflow">if</span>(v &gt; 0) first = mid+1;
01694         <span class="keywordflow">else</span> {
01695             *pos = mid;
01696 
01697             <span class="keywordflow">if</span>(!p[rules-&gt;<a class="code" href="structrules__t.html#o3">data</a>.<a class="code" href="structruledata__t.html#o0">data</a>[mid]-&gt;<a class="code" href="structonerule__t.html#o0">data</a>.<a class="code" href="structstrings__t.html#o1">len</a>[sort]]) <span class="keywordflow">return</span> 2;
01698 
01699             first = mid+1;
01700         }
01701     }
01702 
01703     <span class="keywordflow">if</span>(*pos != (size_t)-1) <span class="keywordflow">return</span> 1;
01704 
01705     <span class="keywordflow">if</span>(v &lt; 0) *pos = mid;
01706     <span class="keywordflow">else</span> *pos = mid+1;
01707 
01708     <span class="keywordflow">return</span> 0;
01709 }
01710 <span class="comment"></span>
01711 <span class="comment">/*! Follows the prev members of rules until a match with \a p is found.</span>
01712 <span class="comment">    \param rules The array of rules.</span>
01713 <span class="comment">    \param p The string to match with a rule.</span>
01714 <span class="comment">    \param pos The closest match found so far.</span>
01715 <span class="comment">    \return 1 if a match was found, 0 if not.</span>
01716 <span class="comment">*/</span>
<a name="l01717"></a><a class="code" href="codeform_8c.html#a68">01717</a> <span class="keywordtype">int</span> <a class="code" href="codeform_8c.html#a68">find_rule_prev</a>(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structrules__t.html">rules_t</a> *rules, <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="structtypefunc__t.html#o1">p</a>, size_t *<a class="code" href="structtypefunc__t.html#o3">pos</a>) {
01718     size_t <a class="code" href="structtypefunc__t.html#o4">n</a> = *pos-1, sort;
01719 
01720     <span class="keywordflow">if</span>(*pos) {
01721         <span class="keywordflow">while</span>(rules-&gt;<a class="code" href="structrules__t.html#o3">data</a>.<a class="code" href="structruledata__t.html#o0">data</a>[n]-&gt;<a class="code" href="structonerule__t.html#o2">prev</a> != (size_t)-1) {
01722             n = rules-&gt;<a class="code" href="structrules__t.html#o3">data</a>.<a class="code" href="structruledata__t.html#o0">data</a>[n]-&gt;<a class="code" href="structonerule__t.html#o2">prev</a>;
01723             sort = rules-&gt;<a class="code" href="structrules__t.html#o0">type</a>[rules-&gt;<a class="code" href="structrules__t.html#o3">data</a>.<a class="code" href="structruledata__t.html#o0">data</a>[n]-&gt;<a class="code" href="structonerule__t.html#o1">type</a>].<a class="code" href="structruletype__t.html#o1">sort</a>;
01724 
01725             <span class="keywordflow">if</span>(!strncmp(p, rules-&gt;<a class="code" href="structrules__t.html#o3">data</a>.<a class="code" href="structruledata__t.html#o0">data</a>[n]-&gt;<a class="code" href="structonerule__t.html#o0">data</a>.<a class="code" href="structstrings__t.html#o0">data</a>[sort],
01726                 rules-&gt;<a class="code" href="structrules__t.html#o3">data</a>.<a class="code" href="structruledata__t.html#o0">data</a>[n]-&gt;<a class="code" href="structonerule__t.html#o0">data</a>.<a class="code" href="structstrings__t.html#o1">len</a>[sort])) {
01727 
01728                 *pos = n;
01729                 <span class="keywordflow">return</span> 1;
01730             }
01731         }
01732     }
01733 
01734     <span class="keywordflow">return</span> 0;
01735 }
01736 <span class="comment"></span>
01737 <span class="comment">/*! Copies the open file \a from to the filename \a fn. Rewinds the file</span>
01738 <span class="comment">    pointer \a from beforehand. \a fn is opened via open_file().</span>
01739 <span class="comment">    \param from The open file stream used as a source, to copy from.</span>
01740 <span class="comment">    \param fn A string containing the filename for the destination, to copy to.</span>
01741 <span class="comment">*/</span>
<a name="l01742"></a><a class="code" href="codeform_8c.html#a69">01742</a> <span class="keywordtype">void</span> <a class="code" href="codeform_8c.html#a69">copy_file</a>(FILE *from, <span class="keyword">const</span> <span class="keywordtype">char</span> *fn) {
01743     FILE *to = <a class="code" href="codeform_8c.html#a32">open_file</a>(fn, <span class="stringliteral">"w"</span>);
01744     <span class="keywordtype">int</span> c;
01745 
01746     <span class="keywordflow">if</span>(!to) <span class="keywordflow">return</span>;
01747 
01748     rewind(from);  <span class="comment">/* Rewind the file pointer to the beginning. */</span>
01749 
01750     <span class="keywordflow">while</span>((c = getc(from)) != EOF) {
01751         putc(c, to);
01752     }
01753 
01754     <span class="keywordflow">if</span>(to != stdout) fclose(to);
01755 }
01756 <span class="comment"></span>
01757 <span class="comment">/*! Returns true if \a p is a string representation of an integral number. A</span>
01758 <span class="comment">    number is one or more digits followed by a character that is not a period.</span>
01759 <span class="comment">    Thus floating point numbers are excluded.</span>
01760 <span class="comment">    \param p The string that may contain a number.</span>
01761 <span class="comment">    \return True if the string \a p represents an integral number.</span>
01762 <span class="comment">*/</span>
<a name="l01763"></a><a class="code" href="codeform_8c.html#a70">01763</a> <span class="keywordtype">int</span> <a class="code" href="codeform_8c.html#a70">is_number</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="structtypefunc__t.html#o1">p</a>) {
01764     <span class="keywordtype">int</span> <a class="code" href="structtypefunc__t.html#o4">n</a> = 0;
01765 
01766     <span class="keywordflow">while</span>(isdigit(*p)) p ++, n = 1;
01767 
01768     <span class="keywordflow">return</span> n &amp;&amp; *p != <span class="charliteral">'.'</span>;
01769 }
01770 <span class="comment"></span>
01771 <span class="comment">/*! Returns true if \a p is a string representation of a floating-point number.</span>
01772 <span class="comment">    A floating-point number is one or more optional digits plus a period plus</span>
01773 <span class="comment">    one or more optional digits. (At least one digit must be present.)</span>
01774 <span class="comment">    \param p The string to examine for a floating-point number.</span>
01775 <span class="comment">    \return True if the string \a p represents a floating-point number.</span>
01776 <span class="comment">*/</span>
<a name="l01777"></a><a class="code" href="codeform_8c.html#a71">01777</a> <span class="keywordtype">int</span> <a class="code" href="codeform_8c.html#a71">is_fpnumber</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="structtypefunc__t.html#o1">p</a>) {
01778     <span class="keywordtype">int</span> <a class="code" href="structtypefunc__t.html#o4">n</a> = 0;  <span class="comment">/* True if there was a digit before the period. */</span>
01779 
01780     <span class="keywordflow">while</span>(isdigit(*p)) p ++, n = 1;
01781 
01782     <span class="keywordflow">return</span> *p == <span class="charliteral">'.'</span> &amp;&amp; (n || isdigit(p[1]));
01783 }
01784 <span class="comment"></span>
01785 <span class="comment">/*! Prints any digits, periods and underscores starting from the beginning of</span>
01786 <span class="comment">    the string \a p to \a out. It stops printing characters when one that</span>
01787 <span class="comment">    doesn't meet the criteria is found. \a p is incremented to that character.</span>
01788 <span class="comment">    \param p The string to read characters from and to advance.</span>
01789 <span class="comment">    \param out The output stream to write the characters to.</span>
01790 <span class="comment">*/</span>
<a name="l01791"></a><a class="code" href="codeform_8c.html#a72">01791</a> <span class="keywordtype">void</span> <a class="code" href="codeform_8c.html#a72">print_number</a>(<span class="keywordtype">char</span> **<a class="code" href="structtypefunc__t.html#o1">p</a>, FILE *<a class="code" href="structtypefunc__t.html#o0">out</a>) {
01792     <span class="keywordflow">while</span>(isalnum(**p) || **p == <span class="charliteral">'.'</span> || **p == <span class="charliteral">'_'</span>) {
01793         fputc(*(*p)++, out);
01794     }
01795 }
01796 <span class="comment"></span>
01797 <span class="comment">/*! Returns true if the string \a p is escaped. A character is escaped if it</span>
01798 <span class="comment">    has an odd number of backslashes preceding it. \a start indicates the start</span>
01799 <span class="comment">    of the string so that the function can calculate this without going before</span>
01800 <span class="comment">    the beginning of the string.</span>
01801 <span class="comment">    \param start The start of the string.</span>
01802 <span class="comment">    \param p The position in \a start that the function counts backslashes</span>
01803 <span class="comment">        preceding.</span>
01804 <span class="comment">    \return True if there are an odd number of backslashes preceding the</span>
01805 <span class="comment">        position \a p in the string \a start.</span>
01806 <span class="comment">*/</span>
<a name="l01807"></a><a class="code" href="codeform_8c.html#a74">01807</a> <span class="keywordtype">int</span> <a class="code" href="codeform_8c.html#a74">is_backslashed</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *start, <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="structtypefunc__t.html#o1">p</a>) {
01808     size_t x = 0;
01809 
01810     <span class="keywordflow">while</span>(p &gt; start &amp;&amp; *(--p) == <span class="charliteral">'\\'</span>) x ++;
01811 
01812     <span class="keywordflow">return</span> x % 2;
01813 }
01814 <span class="comment"></span>
01815 <span class="comment">/*! Shifts the string \a p to the left, deleting the first character (*p).</span>
01816 <span class="comment">    \param p The string to delete the first character from.</span>
01817 <span class="comment">*/</span>
<a name="l01818"></a><a class="code" href="codeform_8c.html#a75">01818</a> <span class="keywordtype">void</span> <a class="code" href="codeform_8c.html#a75">remove_char</a>(<span class="keywordtype">char</span> *<a class="code" href="structtypefunc__t.html#o1">p</a>) {
01819     <span class="keywordflow">for</span>( ; *p; p++) *p = *(p+1);
01820 }
01821 <span class="comment"></span>
01822 <span class="comment">/*! Returns true if the character \a c is a letter or an underscore (a "word"</span>
01823 <span class="comment">    character).</span>
01824 <span class="comment">    \param c The character to examine.</span>
01825 <span class="comment">    \return True if the character \a c is a word character: a letter or an</span>
01826 <span class="comment">        underscore.</span>
01827 <span class="comment">*/</span>
<a name="l01828"></a><a class="code" href="codeform_8c.html#a73">01828</a> <span class="keywordtype">int</span> <a class="code" href="codeform_8c.html#a73">is_word</a>(<span class="keywordtype">int</span> c) {
01829     <span class="keywordflow">return</span> c == <span class="charliteral">'_'</span> || isalnum(c);
01830 }
01831 <span class="comment"></span>
01832 <span class="comment">/*! Returns true if the character before \a p is a word character (by calling</span>
01833 <span class="comment">    is_word()); if p is the start of the string (equal to \a line), returns 0.</span>
01834 <span class="comment">    \param line The start of the string.</span>
01835 <span class="comment">    \param p The position in \a line to check the character before.</span>
01836 <span class="comment">    \return True if the character before \a p is a word character; false if p</span>
01837 <span class="comment">        is the start of the string.</span>
01838 <span class="comment">*/</span>
<a name="l01839"></a><a class="code" href="codeform_8c.html#a76">01839</a> <span class="keywordtype">int</span> <a class="code" href="codeform_8c.html#a76">is_word_prev</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *line, <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="structtypefunc__t.html#o1">p</a>) {
01840     <span class="keywordflow">return</span> p == line ? 0 : <a class="code" href="codeform_8c.html#a73">is_word</a>(*(p-1));
01841 }
01842 <span class="comment"></span>
01843 <span class="comment">/*! Removes shell-style (# to EOL) comments from the string \a s. Called to</span>
01844 <span class="comment">    strip comments from rules.</span>
01845 <span class="comment">    \param s The string to remove comments from.</span>
01846 <span class="comment">*/</span>
<a name="l01847"></a><a class="code" href="codeform_8c.html#a77">01847</a> <span class="keywordtype">void</span> <a class="code" href="codeform_8c.html#a77">remove_comments</a>(<span class="keywordtype">char</span> *s) {
01848     <span class="keywordtype">char</span> *<a class="code" href="structtypefunc__t.html#o1">p</a>;
01849 
01850     <span class="keywordflow">for</span>(p = s; (p = strchr(p, <span class="charliteral">'#'</span>)); p ++) {
01851         <span class="keywordflow">if</span>(!<a class="code" href="codeform_8c.html#a74">is_backslashed</a>(s, p)) {
01852             <span class="comment">/*while(p &gt; s &amp;&amp; isspace(*(p-1))) p --;*/</span>
01853             *p = 0;
01854 
01855             <span class="keywordflow">break</span>;
01856         }
01857     }
01858 }
01859 <span class="comment"></span>
01860 <span class="comment">/*! Returns the position of the separator for a variable, or NULL if the passed</span>
01861 <span class="comment">    string is not a valid variable string.</span>
01862 <span class="comment">    \param s The string that contains the possible variable. It consists of</span>
01863 <span class="comment">        alphanumeric characters followed by an \c = followed by any other</span>
01864 <span class="comment">        characters.</span>
01865 <span class="comment">*/</span>
<a name="l01866"></a><a class="code" href="codeform_8c.html#a78">01866</a> <span class="keywordtype">char</span> *<a class="code" href="codeform_8c.html#a78">is_var</a>(<span class="keywordtype">char</span> *s) {
01867     <span class="keywordtype">char</span> *<a class="code" href="structtypefunc__t.html#o1">p</a> = s;
01868 
01869     <span class="keywordflow">while</span>(*p++) {
01870         <span class="keywordflow">if</span>(!<a class="code" href="codeform_8c.html#a73">is_word</a>(*p) &amp;&amp; !isdigit(*p)) {
01871             <span class="keywordflow">if</span>(*p == <span class="charliteral">'='</span>) {
01872                 <span class="keywordflow">return</span> <a class="code" href="codeform_8c.html#a74">is_backslashed</a>(s, p) ? 0 : p;
01873             }
01874             <span class="keywordflow">else</span> <span class="keywordflow">return</span> 0;
01875         }
01876     }
01877 
01878     <span class="keywordflow">return</span> 0;
01879 }
01880 <span class="comment"></span>
01881 <span class="comment">/*! Returns true if s represents a filename which starts with "./" or ".\\".</span>
01882 <span class="comment">    \param s The filename to look at.</span>
01883 <span class="comment">    \return True if \a s starts with the current directory, "./" or ".\\".</span>
01884 <span class="comment">*/</span>
<a name="l01885"></a><a class="code" href="codeform_8c.html#a79">01885</a> <span class="keywordtype">int</span> <a class="code" href="codeform_8c.html#a79">is_current_dir</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *s) {
01886     <span class="keywordflow">return</span> *s == <span class="charliteral">'.'</span> &amp;&amp; (s[1] == <span class="charliteral">'/'</span> || s[1] == <span class="charliteral">'\\'</span>);
01887 }
01888 <span class="comment"></span>
01889 <span class="comment">/*! Prints \a len chars from \a *p to out. \a p is advanced to the next</span>
01890 <span class="comment">    character (*p+len).</span>
01891 <span class="comment">    \param p The string to advance and print.</span>
01892 <span class="comment">    \param len The number of characters from \a p to print/advance.</span>
01893 <span class="comment">    \param out The output file stream to write the characters to.</span>
01894 <span class="comment">*/</span>
<a name="l01895"></a><a class="code" href="codeform_8c.html#a80">01895</a> <span class="keywordtype">void</span> <a class="code" href="codeform_8c.html#a80">print_chars</a>(<span class="keywordtype">char</span> **<a class="code" href="structtypefunc__t.html#o1">p</a>, size_t len, FILE *<a class="code" href="structtypefunc__t.html#o0">out</a>) {
01896     <span class="keywordflow">while</span>(len --) fputc(*(*p)++, out);
01897 }
01898 <span class="comment"></span>
01899 <span class="comment">/*! Adds a function to the list of type_func functions.</span>
01900 <span class="comment">    \param func The function list to add \a n to.</span>
01901 <span class="comment">    \param which The function number to add to \a func.</span>
01902 <span class="comment">    \param type The type of the function being added to the list.</span>
01903 <span class="comment">*/</span>
<a name="l01904"></a><a class="code" href="codeform_8c.html#a81">01904</a> <span class="keywordtype">void</span> <a class="code" href="codeform_8c.html#a81">add_to_funclist</a>(<span class="keyword">struct</span> <a class="code" href="structfunclist__t.html">funclist_t</a> *<a class="code" href="structtypefunc__t.html#o7">func</a>, size_t which, <span class="keyword">enum</span> <a class="code" href="codeform_8c.html#a98">type_t</a> <a class="code" href="structtypefunc__t.html#o6">type</a>) {
01905     size_t *f = realloc(func-&gt;<a class="code" href="structfunclist__t.html#o0">which</a>, (func-&gt;number + 1) * <span class="keyword">sizeof</span>(size_t));
01906     <span class="keyword">enum</span> <a class="code" href="codeform_8c.html#a98">type_t</a> *t;
01907 
01908     <span class="keywordflow">if</span>(!f) <a class="code" href="codeform_8c.html#a22">out_of_memory</a>(__FILE__, __LINE__);
01909     func-&gt;<a class="code" href="structfunclist__t.html#o0">which</a> = f;
01910 
01911     t = realloc(func-&gt;type, (func-&gt;number + 1) * <span class="keyword">sizeof</span>(<span class="keyword">enum</span> <a class="code" href="codeform_8c.html#a98">type_t</a>));
01912     <span class="keywordflow">if</span>(!t) <a class="code" href="codeform_8c.html#a22">out_of_memory</a>(__FILE__, __LINE__);
01913     func-&gt;type = t;
01914 
01915     func-&gt;<a class="code" href="structfunclist__t.html#o0">which</a>[func-&gt;number] = which;
01916     func-&gt;type[func-&gt;number] = type;
01917 
01918     func-&gt;number ++;
01919 }
01920 <span class="comment"></span>
01921 <span class="comment">/*! Removes the most recent function (on the bottom) from the function list</span>
01922 <span class="comment">    \a func. (The function list stores the offset of the rule within the rules</span>
01923 <span class="comment">    structure, not a function pointer.)</span>
01924 <span class="comment">    \param func The function list to remove a function from.</span>
01925 <span class="comment">*/</span>
<a name="l01926"></a><a class="code" href="codeform_8c.html#a82">01926</a> <span class="keywordtype">void</span> <a class="code" href="codeform_8c.html#a82">remove_from_funclist</a>(<span class="keyword">struct</span> <a class="code" href="structfunclist__t.html">funclist_t</a> *<a class="code" href="structtypefunc__t.html#o7">func</a>) {
01927     size_t *f;
01928     <span class="keyword">enum</span> <a class="code" href="codeform_8c.html#a98">type_t</a> *t;
01929 
01930     <span class="keywordflow">if</span>(func-&gt;number &gt; 1) {
01931         func-&gt;number --;
01932 
01933         f = realloc(func-&gt;<a class="code" href="structfunclist__t.html#o0">which</a>, func-&gt;number * <span class="keyword">sizeof</span>(size_t));
01934         <span class="keywordflow">if</span>(!f) <a class="code" href="codeform_8c.html#a22">out_of_memory</a>(__FILE__, __LINE__);
01935         func-&gt;<a class="code" href="structfunclist__t.html#o0">which</a> = f;
01936 
01937         t = realloc(func-&gt;type, func-&gt;number * <span class="keyword">sizeof</span>(<span class="keyword">enum</span> <a class="code" href="codeform_8c.html#a98">type_t</a>));
01938         <span class="keywordflow">if</span>(!t) <a class="code" href="codeform_8c.html#a22">out_of_memory</a>(__FILE__, __LINE__);
01939         func-&gt;type = t;
01940     }
01941     <span class="keywordflow">else</span> {
01942         free(func-&gt;<a class="code" href="structfunclist__t.html#o0">which</a>);
01943         free(func-&gt;type);
01944         func-&gt;<a class="code" href="structfunclist__t.html#o0">which</a> = 0;
01945         func-&gt;type = 0;
01946         func-&gt;number = 0;
01947     }
01948 
01949     func-&gt;nest = 1;
01950 }
01951 <span class="comment"></span>
01952 <span class="comment">/*! Adds a whitespace character to the list of whitespace characters.</span>
01953 <span class="comment">    \param list The structure containing the list of whitespace characters.</span>
01954 <span class="comment">    \param c The character to add.</span>
01955 <span class="comment">*/</span>
<a name="l01956"></a><a class="code" href="codeform_8c.html#a83">01956</a> <span class="keywordtype">void</span> <a class="code" href="codeform_8c.html#a83">add_ws_rulelist</a>(<span class="keyword">struct</span> <a class="code" href="structrulelist__t.html">rulelist_t</a> *<a class="code" href="structtypefunc__t.html#o8">list</a>, <span class="keywordtype">char</span> c) {
01957     <span class="keywordtype">char</span> *<a class="code" href="structtypefunc__t.html#o1">p</a>;
01958 
01959     p = realloc(list-&gt;<a class="code" href="structrulelist__t.html#o2">ws</a>, list-&gt;<a class="code" href="structrulelist__t.html#o3">wslen</a> + 2);
01960     <span class="keywordflow">if</span>(!p) <a class="code" href="codeform_8c.html#a22">out_of_memory</a>(__FILE__, __LINE__);
01961     list-&gt;<a class="code" href="structrulelist__t.html#o2">ws</a> = p;
01962 
01963     list-&gt;<a class="code" href="structrulelist__t.html#o2">ws</a>[list-&gt;<a class="code" href="structrulelist__t.html#o3">wslen</a> ++] = c;
01964     list-&gt;<a class="code" href="structrulelist__t.html#o2">ws</a>[list-&gt;<a class="code" href="structrulelist__t.html#o3">wslen</a>] = 0;
01965 }
01966 <span class="comment"></span>
01967 <span class="comment">/*! Prints the whitespace in the whitespace list (if any), clearing the list.</span>
01968 <span class="comment">    \param list The structure containing the list of whitespace characters.</span>
01969 <span class="comment">    \param out The file stream to print the characters to.</span>
01970 <span class="comment">*/</span>
<a name="l01971"></a><a class="code" href="codeform_8c.html#a84">01971</a> <span class="keywordtype">void</span> <a class="code" href="codeform_8c.html#a84">print_ws_rulelist</a>(<span class="keyword">struct</span> <a class="code" href="structrulelist__t.html">rulelist_t</a> *<a class="code" href="structtypefunc__t.html#o8">list</a>, FILE *<a class="code" href="structtypefunc__t.html#o0">out</a>) {
01972     <span class="keywordflow">if</span>(list-&gt;<a class="code" href="structrulelist__t.html#o2">ws</a>) {
01973         fputs(list-&gt;<a class="code" href="structrulelist__t.html#o2">ws</a>, out);
01974 
01975         free(list-&gt;<a class="code" href="structrulelist__t.html#o2">ws</a>);
01976         list-&gt;<a class="code" href="structrulelist__t.html#o2">ws</a> = 0;
01977         list-&gt;<a class="code" href="structrulelist__t.html#o3">wslen</a> = 0;
01978     }
01979 }
01980 <span class="comment"></span>
01981 <span class="comment">/*! Starts a tag, ignoring tags of the same kind in sequence. That is, if two</span>
01982 <span class="comment">    keywords with the same precede-with occur in a row, don't close the tag</span>
01983 <span class="comment">    only to start it again.</span>
01984 <span class="comment">    \param from The text to print before (now) if the previous tag wasn't the</span>
01985 <span class="comment">        same as it.</span>
01986 <span class="comment">    \param to The text to print after if \a from doesn't match list-&gt;from.</span>
01987 <span class="comment">    \param list The structure containing the previous tag.</span>
01988 <span class="comment">    \param out The output file stream to write everything to.</span>
01989 <span class="comment">*/</span>
<a name="l01990"></a><a class="code" href="codeform_8c.html#a85">01990</a> <span class="keywordtype">void</span> <a class="code" href="codeform_8c.html#a85">append_rulelist</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *from, <span class="keyword">const</span> <span class="keywordtype">char</span> *to, <span class="keyword">struct</span> <a class="code" href="structrulelist__t.html">rulelist_t</a> *<a class="code" href="structtypefunc__t.html#o8">list</a>,
01991     FILE *<a class="code" href="structtypefunc__t.html#o0">out</a>) {
01992 
01993     <span class="keywordflow">if</span>(!from) {
01994         <span class="keywordflow">if</span>(list-&gt;<a class="code" href="structrulelist__t.html#o1">to</a>) {
01995             fputs(list-&gt;<a class="code" href="structrulelist__t.html#o1">to</a>, out);
01996             list-&gt;<a class="code" href="structrulelist__t.html#o1">to</a> = 0;
01997             list-&gt;<a class="code" href="structrulelist__t.html#o0">from</a> = 0;
01998 
01999             <a class="code" href="codeform_8c.html#a84">print_ws_rulelist</a>(list, out);
02000         }
02001     }
02002     <span class="keywordflow">else</span> <span class="keywordflow">if</span>(!list-&gt;<a class="code" href="structrulelist__t.html#o0">from</a> || strcmp(from, list-&gt;<a class="code" href="structrulelist__t.html#o0">from</a>)) {
02003         <span class="keywordflow">if</span>(list-&gt;<a class="code" href="structrulelist__t.html#o1">to</a>) fputs(list-&gt;<a class="code" href="structrulelist__t.html#o1">to</a>, out);
02004 
02005         <a class="code" href="codeform_8c.html#a84">print_ws_rulelist</a>(list, out);
02006 
02007         fputs(from, out);
02008         list-&gt;<a class="code" href="structrulelist__t.html#o0">from</a> = from;
02009         list-&gt;<a class="code" href="structrulelist__t.html#o1">to</a> = to;
02010     }
02011     <span class="keywordflow">else</span> <a class="code" href="codeform_8c.html#a84">print_ws_rulelist</a>(list, out);
02012 }
02013 <span class="comment"></span>
02014 <span class="comment">/*! Removes the newline characters, if any, off of the end of \a str. \a flen</span>
02015 <span class="comment">    is adjusted accordingly. (Newline characters are '\\n' and '\\r', to</span>
02016 <span class="comment">    support CRLF newlines under UNIX systems.)</span>
02017 <span class="comment">    \param str The string to remove newline characters from the end of.</span>
02018 <span class="comment">    \param flen The length of the string \a str, decreased with each character</span>
02019 <span class="comment">        removed.</span>
02020 <span class="comment">*/</span>
<a name="l02021"></a><a class="code" href="codeform_8c.html#a86">02021</a> <span class="keywordtype">void</span> <a class="code" href="codeform_8c.html#a86">chomp_newline</a>(<span class="keywordtype">char</span> *str, size_t *flen) {
02022     <span class="keywordflow">while</span>(*flen &amp;&amp; (str[*flen-1] == <span class="charliteral">'\n'</span> || str[*flen-1] == <span class="charliteral">'\r'</span>)) {
02023         str[--(*flen)] = 0;
02024     }
02025 }
02026 
02027 <span class="comment">/*--------------------------------------------*\</span>
02028 <span class="comment"> | type_func functions which implement rules. |</span>
02029 <span class="comment">\*--------------------------------------------*/</span>
02030 
<a name="l02031"></a><a class="code" href="codeform_8c.html#a87">02031</a> <span class="keywordtype">int</span> <a class="code" href="codeform_8c.html#a87">type_keyword</a>(<span class="keyword">struct</span> <a class="code" href="structonerule__t.html">onerule_t</a> *rule, <span class="keyword">struct</span> <a class="code" href="structtypefunc__t.html">typefunc_t</a> *tf) {
02032     <span class="keywordflow">if</span>(!tf-&gt;<a class="code" href="structtypefunc__t.html#o2">iw</a> &amp;&amp; !<a class="code" href="codeform_8c.html#a73">is_word</a>((*tf-&gt;<a class="code" href="structtypefunc__t.html#o1">p</a>)[rule-&gt;<a class="code" href="structonerule__t.html#o0">data</a>.<a class="code" href="structstrings__t.html#o1">len</a>[0]])) {
02033         <span class="keywordflow">return</span> <a class="code" href="codeform_8c.html#a88">type_midword</a>(rule, tf);
02034     }
02035 
02036     <span class="keywordflow">return</span> 0;
02037 }
02038 
<a name="l02039"></a><a class="code" href="codeform_8c.html#a88">02039</a> <span class="keywordtype">int</span> <a class="code" href="codeform_8c.html#a88">type_midword</a>(<span class="keyword">struct</span> <a class="code" href="structonerule__t.html">onerule_t</a> *rule, <span class="keyword">struct</span> <a class="code" href="structtypefunc__t.html">typefunc_t</a> *tf) {
02040     size_t x;
02041 
02042     <span class="keywordflow">if</span>(!strncmp(rule-&gt;<a class="code" href="structonerule__t.html#o0">data</a>.<a class="code" href="structstrings__t.html#o0">data</a>[0], *tf-&gt;<a class="code" href="structtypefunc__t.html#o1">p</a>, rule-&gt;<a class="code" href="structonerule__t.html#o0">data</a>.<a class="code" href="structstrings__t.html#o1">len</a>[0])) {
02043         <span class="keywordflow">if</span>(!tf-&gt;<a class="code" href="structtypefunc__t.html#o7">func</a>.number) {
02044             <a class="code" href="codeform_8c.html#a85">append_rulelist</a>(rule-&gt;<a class="code" href="structonerule__t.html#o0">data</a>.<a class="code" href="structstrings__t.html#o0">data</a>[1],
02045                 rule-&gt;<a class="code" href="structonerule__t.html#o0">data</a>.<a class="code" href="structstrings__t.html#o0">data</a>[rule-&gt;<a class="code" href="structonerule__t.html#o0">data</a>.<a class="code" href="structstrings__t.html#o2">number</a>-1], tf-&gt;<a class="code" href="structtypefunc__t.html#o8">list</a>, tf-&gt;<a class="code" href="structtypefunc__t.html#o0">out</a>);
02046         }
02047 
02048         <span class="keywordflow">if</span>(rule-&gt;<a class="code" href="structonerule__t.html#o0">data</a>.<a class="code" href="structstrings__t.html#o2">number</a> == 3) {
02049             <a class="code" href="codeform_8c.html#a80">print_chars</a>(tf-&gt;<a class="code" href="structtypefunc__t.html#o1">p</a>, rule-&gt;<a class="code" href="structonerule__t.html#o0">data</a>.<a class="code" href="structstrings__t.html#o1">len</a>[0], tf-&gt;<a class="code" href="structtypefunc__t.html#o0">out</a>);
02050         }
02051         <span class="keywordflow">else</span> {
02052             <span class="keywordflow">for</span>(x = 0; x &lt; rule-&gt;<a class="code" href="structonerule__t.html#o0">data</a>.<a class="code" href="structstrings__t.html#o1">len</a>[0]; x ++) {
02053                 (*tf-&gt;<a class="code" href="structtypefunc__t.html#o1">p</a>)++;
02054             }
02055 
02056             fputs(rule-&gt;<a class="code" href="structonerule__t.html#o0">data</a>.<a class="code" href="structstrings__t.html#o0">data</a>[2], tf-&gt;<a class="code" href="structtypefunc__t.html#o0">out</a>);
02057         }
02058 
02059         <span class="keywordflow">return</span> 1;
02060     }
02061 
02062     <span class="keywordflow">return</span> 0;
02063 }
02064 
<a name="l02065"></a><a class="code" href="codeform_8c.html#a89">02065</a> <span class="keywordtype">int</span> <a class="code" href="codeform_8c.html#a89">type_comment_end</a>(<span class="keyword">struct</span> <a class="code" href="structonerule__t.html">onerule_t</a> *rule, <span class="keyword">struct</span> <a class="code" href="structtypefunc__t.html">typefunc_t</a> *tf) {
02066     <span class="keywordflow">if</span>(rule-&gt;<a class="code" href="structonerule__t.html#o0">data</a>.<a class="code" href="structstrings__t.html#o2">number</a> == 3) {
02067         <span class="keywordflow">if</span>(tf-&gt;<a class="code" href="structtypefunc__t.html#o6">type</a> == <a class="code" href="codeform_8c.html#a98a3">TYPE_COMMENT</a> || tf-&gt;<a class="code" href="structtypefunc__t.html#o6">type</a> == <a class="code" href="codeform_8c.html#a98a5">TYPE_NESTCOM</a>) {
02068             <span class="keywordflow">if</span>((**tf-&gt;<a class="code" href="structtypefunc__t.html#o1">p</a> == <span class="charliteral">'\n'</span> || **tf-&gt;<a class="code" href="structtypefunc__t.html#o1">p</a> == <span class="charliteral">'\r'</span>)
02069                 &amp;&amp; !<a class="code" href="codeform_8c.html#a74">is_backslashed</a>(*tf-&gt;<a class="code" href="structtypefunc__t.html#o1">p</a> - tf-&gt;<a class="code" href="structtypefunc__t.html#o4">n</a>, *tf-&gt;<a class="code" href="structtypefunc__t.html#o1">p</a>)) {
02070 
02071                 fputs(rule-&gt;<a class="code" href="structonerule__t.html#o0">data</a>.<a class="code" href="structstrings__t.html#o0">data</a>[2], tf-&gt;<a class="code" href="structtypefunc__t.html#o0">out</a>);
02072 
02073                 <span class="keywordflow">return</span> -1;
02074             }
02075         }
02076         <span class="keywordflow">else</span> <span class="keywordflow">if</span>(!strncmp(rule-&gt;<a class="code" href="structonerule__t.html#o0">data</a>.<a class="code" href="structstrings__t.html#o0">data</a>[0], *tf-&gt;<a class="code" href="structtypefunc__t.html#o1">p</a>, rule-&gt;<a class="code" href="structonerule__t.html#o0">data</a>.<a class="code" href="structstrings__t.html#o1">len</a>[0])) {
02077             <a class="code" href="codeform_8c.html#a80">print_chars</a>(tf-&gt;<a class="code" href="structtypefunc__t.html#o1">p</a>, rule-&gt;<a class="code" href="structonerule__t.html#o0">data</a>.<a class="code" href="structstrings__t.html#o1">len</a>[0], tf-&gt;<a class="code" href="structtypefunc__t.html#o0">out</a>);
02078 
02079             <span class="keywordflow">if</span>(tf-&gt;<a class="code" href="structtypefunc__t.html#o7">func</a>.number == 1) fputs(rule-&gt;<a class="code" href="structonerule__t.html#o0">data</a>.<a class="code" href="structstrings__t.html#o0">data</a>[2], tf-&gt;<a class="code" href="structtypefunc__t.html#o0">out</a>);
02080 
02081             <span class="keywordflow">return</span> -1;
02082         }
02083     }
02084     <span class="keywordflow">else</span> <span class="keywordflow">if</span>(!strncmp(rule-&gt;<a class="code" href="structonerule__t.html#o0">data</a>.<a class="code" href="structstrings__t.html#o0">data</a>[1], *tf-&gt;<a class="code" href="structtypefunc__t.html#o1">p</a>, rule-&gt;<a class="code" href="structonerule__t.html#o0">data</a>.<a class="code" href="structstrings__t.html#o1">len</a>[1])) {
02085         <a class="code" href="codeform_8c.html#a80">print_chars</a>(tf-&gt;<a class="code" href="structtypefunc__t.html#o1">p</a>, rule-&gt;<a class="code" href="structonerule__t.html#o0">data</a>.<a class="code" href="structstrings__t.html#o1">len</a>[1], tf-&gt;<a class="code" href="structtypefunc__t.html#o0">out</a>);
02086 
02087         <span class="keywordflow">if</span>(tf-&gt;<a class="code" href="structtypefunc__t.html#o6">type</a> != <a class="code" href="codeform_8c.html#a98a4">TYPE_STRING</a> || tf-&gt;<a class="code" href="structtypefunc__t.html#o7">func</a>.number == 1) {
02088             fputs(rule-&gt;<a class="code" href="structonerule__t.html#o0">data</a>.<a class="code" href="structstrings__t.html#o0">data</a>[3], tf-&gt;<a class="code" href="structtypefunc__t.html#o0">out</a>);
02089         }
02090 
02091         <span class="keywordflow">return</span> -1;
02092     }
02093 
02094     <span class="keywordflow">if</span>(tf-&gt;<a class="code" href="structtypefunc__t.html#o3">pos</a> &amp; <a class="code" href="codeform_8c.html#a99a13">POS_END</a>) {
02095         <span class="keywordflow">if</span>(tf-&gt;<a class="code" href="structtypefunc__t.html#o6">type</a> != <a class="code" href="codeform_8c.html#a98a4">TYPE_STRING</a> || tf-&gt;<a class="code" href="structtypefunc__t.html#o7">func</a>.number == 1) {
02096             fputs(rule-&gt;<a class="code" href="structonerule__t.html#o0">data</a>.<a class="code" href="structstrings__t.html#o0">data</a>[rule-&gt;<a class="code" href="structonerule__t.html#o0">data</a>.<a class="code" href="structstrings__t.html#o2">number</a>-1], tf-&gt;<a class="code" href="structtypefunc__t.html#o0">out</a>);
02097         }
02098 
02099         <span class="keywordflow">return</span> -1;
02100     }
02101 
02102     <span class="keywordflow">return</span> 0;
02103 }
02104 
<a name="l02105"></a><a class="code" href="codeform_8c.html#a90">02105</a> <span class="keywordtype">int</span> <a class="code" href="codeform_8c.html#a90">type_comment</a>(<span class="keyword">struct</span> <a class="code" href="structonerule__t.html">onerule_t</a> *rule, <span class="keyword">struct</span> <a class="code" href="structtypefunc__t.html">typefunc_t</a> *tf) {
02106     <span class="keywordflow">if</span>(tf-&gt;<a class="code" href="structtypefunc__t.html#o7">func</a>.number &amp;&amp; tf-&gt;<a class="code" href="structtypefunc__t.html#o7">func</a>.<a class="code" href="structfunclist__t.html#o0">which</a>[tf-&gt;<a class="code" href="structtypefunc__t.html#o7">func</a>.number-1] == tf-&gt;<a class="code" href="structtypefunc__t.html#o5">number</a>
02107         &amp;&amp; tf-&gt;<a class="code" href="structtypefunc__t.html#o7">func</a>.type[tf-&gt;<a class="code" href="structtypefunc__t.html#o7">func</a>.number-1] == tf-&gt;<a class="code" href="structtypefunc__t.html#o6">type</a>) {
02108 
02109         <span class="keywordflow">if</span>(<a class="code" href="codeform_8c.html#a89">type_comment_end</a>(rule, tf)) <span class="keywordflow">return</span> -1;
02110     }
02111 
02112     <span class="keywordflow">if</span>(tf-&gt;<a class="code" href="structtypefunc__t.html#o7">func</a>.nest
02113         &amp;&amp; !strncmp(rule-&gt;<a class="code" href="structonerule__t.html#o0">data</a>.<a class="code" href="structstrings__t.html#o0">data</a>[0], *tf-&gt;<a class="code" href="structtypefunc__t.html#o1">p</a>, rule-&gt;<a class="code" href="structonerule__t.html#o0">data</a>.<a class="code" href="structstrings__t.html#o1">len</a>[0])) {
02114 
02115         <a class="code" href="codeform_8c.html#a85">append_rulelist</a>(0, 0, tf-&gt;<a class="code" href="structtypefunc__t.html#o8">list</a>, tf-&gt;<a class="code" href="structtypefunc__t.html#o0">out</a>);
02116 
02117         <span class="keywordflow">if</span>(tf-&gt;<a class="code" href="structtypefunc__t.html#o6">type</a> != <a class="code" href="codeform_8c.html#a98a4">TYPE_STRING</a> || !tf-&gt;<a class="code" href="structtypefunc__t.html#o7">func</a>.number) {
02118             fputs(rule-&gt;<a class="code" href="structonerule__t.html#o0">data</a>.<a class="code" href="structstrings__t.html#o0">data</a>[rule-&gt;<a class="code" href="structonerule__t.html#o0">data</a>.<a class="code" href="structstrings__t.html#o2">number</a>-2], tf-&gt;<a class="code" href="structtypefunc__t.html#o0">out</a>);
02119         }
02120 
02121         <a class="code" href="codeform_8c.html#a80">print_chars</a>(tf-&gt;<a class="code" href="structtypefunc__t.html#o1">p</a>, rule-&gt;<a class="code" href="structonerule__t.html#o0">data</a>.<a class="code" href="structstrings__t.html#o1">len</a>[0], tf-&gt;<a class="code" href="structtypefunc__t.html#o0">out</a>);
02122 
02123         <a class="code" href="codeform_8c.html#a81">add_to_funclist</a>(&amp;tf-&gt;<a class="code" href="structtypefunc__t.html#o7">func</a>, tf-&gt;<a class="code" href="structtypefunc__t.html#o5">number</a>, tf-&gt;<a class="code" href="structtypefunc__t.html#o6">type</a>);
02124         tf-&gt;<a class="code" href="structtypefunc__t.html#o7">func</a>.nest = (tf-&gt;<a class="code" href="structtypefunc__t.html#o6">type</a> == <a class="code" href="codeform_8c.html#a98a5">TYPE_NESTCOM</a>);
02125 
02126         <span class="keywordflow">return</span> 1;
02127     }
02128 
02129     <span class="keywordflow">return</span> 0;
02130 }
02131 
<a name="l02132"></a><a class="code" href="codeform_8c.html#a91">02132</a> <span class="keywordtype">int</span> <a class="code" href="codeform_8c.html#a91">type_string</a>(<span class="keyword">struct</span> <a class="code" href="structonerule__t.html">onerule_t</a> *rule, <span class="keyword">struct</span> <a class="code" href="structtypefunc__t.html">typefunc_t</a> *tf) {
02133     <span class="keywordflow">if</span>(tf-&gt;<a class="code" href="structtypefunc__t.html#o7">func</a>.nest || !<a class="code" href="codeform_8c.html#a74">is_backslashed</a>(*tf-&gt;<a class="code" href="structtypefunc__t.html#o1">p</a> - tf-&gt;<a class="code" href="structtypefunc__t.html#o4">n</a>, *tf-&gt;<a class="code" href="structtypefunc__t.html#o1">p</a>)) {
02134         <span class="keywordflow">return</span> <a class="code" href="codeform_8c.html#a90">type_comment</a>(rule, tf);
02135     }
02136 
02137     <span class="keywordflow">return</span> 0;
02138 }
02139 
<a name="l02140"></a><a class="code" href="codeform_8c.html#a92">02140</a> <span class="keywordtype">int</span> <a class="code" href="codeform_8c.html#a92">type_nestcom</a>(<span class="keyword">struct</span> <a class="code" href="structonerule__t.html">onerule_t</a> *rule, <span class="keyword">struct</span> <a class="code" href="structtypefunc__t.html">typefunc_t</a> *tf) {
02141     <span class="keywordflow">return</span> <a class="code" href="codeform_8c.html#a90">type_comment</a>(rule, tf);
02142 }
02143 
<a name="l02144"></a><a class="code" href="codeform_8c.html#a93">02144</a> <span class="keywordtype">int</span> <a class="code" href="codeform_8c.html#a93">type_number</a>(<span class="keyword">struct</span> <a class="code" href="structonerule__t.html">onerule_t</a> *rule, <span class="keyword">struct</span> <a class="code" href="structtypefunc__t.html">typefunc_t</a> *tf) {
02145     <span class="keywordflow">if</span>(!tf-&gt;<a class="code" href="structtypefunc__t.html#o2">iw</a> &amp;&amp; <a class="code" href="codeform_8c.html#a70">is_number</a>(*tf-&gt;<a class="code" href="structtypefunc__t.html#o1">p</a>)) {
02146         <span class="keywordflow">if</span>(!tf-&gt;<a class="code" href="structtypefunc__t.html#o7">func</a>.number) {
02147             <a class="code" href="codeform_8c.html#a85">append_rulelist</a>(rule-&gt;<a class="code" href="structonerule__t.html#o0">data</a>.<a class="code" href="structstrings__t.html#o0">data</a>[0], rule-&gt;<a class="code" href="structonerule__t.html#o0">data</a>.<a class="code" href="structstrings__t.html#o0">data</a>[1], tf-&gt;<a class="code" href="structtypefunc__t.html#o8">list</a>,
02148                 tf-&gt;<a class="code" href="structtypefunc__t.html#o0">out</a>);
02149         }
02150 
02151         <a class="code" href="codeform_8c.html#a72">print_number</a>(tf-&gt;<a class="code" href="structtypefunc__t.html#o1">p</a>, tf-&gt;<a class="code" href="structtypefunc__t.html#o0">out</a>);
02152 
02153         <span class="keywordflow">return</span> 1;
02154     }
02155 
02156     <span class="keywordflow">return</span> 0;
02157 }
02158 
<a name="l02159"></a><a class="code" href="codeform_8c.html#a94">02159</a> <span class="keywordtype">int</span> <a class="code" href="codeform_8c.html#a94">type_fpnumber</a>(<span class="keyword">struct</span> <a class="code" href="structonerule__t.html">onerule_t</a> *rule, <span class="keyword">struct</span> <a class="code" href="structtypefunc__t.html">typefunc_t</a> *tf) {
02160     <span class="keywordflow">if</span>(!tf-&gt;<a class="code" href="structtypefunc__t.html#o2">iw</a> &amp;&amp; <a class="code" href="codeform_8c.html#a71">is_fpnumber</a>(*tf-&gt;<a class="code" href="structtypefunc__t.html#o1">p</a>)) {
02161         <span class="keywordflow">if</span>(!tf-&gt;<a class="code" href="structtypefunc__t.html#o7">func</a>.number) {
02162             <a class="code" href="codeform_8c.html#a85">append_rulelist</a>(rule-&gt;<a class="code" href="structonerule__t.html#o0">data</a>.<a class="code" href="structstrings__t.html#o0">data</a>[0], rule-&gt;<a class="code" href="structonerule__t.html#o0">data</a>.<a class="code" href="structstrings__t.html#o0">data</a>[1], tf-&gt;<a class="code" href="structtypefunc__t.html#o8">list</a>,
02163                 tf-&gt;<a class="code" href="structtypefunc__t.html#o0">out</a>);
02164         }
02165 
02166         <a class="code" href="codeform_8c.html#a72">print_number</a>(tf-&gt;<a class="code" href="structtypefunc__t.html#o1">p</a>, tf-&gt;<a class="code" href="structtypefunc__t.html#o0">out</a>);
02167 
02168         <span class="keywordflow">return</span> 1;
02169     }
02170 
02171     <span class="keywordflow">return</span> 0;
02172 }
02173 
<a name="l02174"></a><a class="code" href="codeform_8c.html#a95">02174</a> <span class="keywordtype">int</span> <a class="code" href="codeform_8c.html#a95">type_start</a>(<span class="keyword">struct</span> <a class="code" href="structonerule__t.html">onerule_t</a> *rule, <span class="keyword">struct</span> <a class="code" href="structtypefunc__t.html">typefunc_t</a> *tf) {
02175     <span class="keywordflow">if</span>(tf-&gt;<a class="code" href="structtypefunc__t.html#o3">pos</a> &amp; <a class="code" href="codeform_8c.html#a99a12">POS_START</a> &amp;&amp; !tf-&gt;<a class="code" href="structtypefunc__t.html#o4">n</a>) {
02176         tf-&gt;<a class="code" href="structtypefunc__t.html#o3">pos</a> &amp;= ~<a class="code" href="codeform_8c.html#a99a12">POS_START</a>;
02177         fputs(rule-&gt;<a class="code" href="structonerule__t.html#o0">data</a>.<a class="code" href="structstrings__t.html#o0">data</a>[0], tf-&gt;<a class="code" href="structtypefunc__t.html#o0">out</a>);
02178     }
02179 
02180     <span class="keywordflow">return</span> 0;
02181 }
02182 
<a name="l02183"></a><a class="code" href="codeform_8c.html#a96">02183</a> <span class="keywordtype">int</span> <a class="code" href="codeform_8c.html#a96">type_end</a>(<span class="keyword">struct</span> <a class="code" href="structonerule__t.html">onerule_t</a> *rule, <span class="keyword">struct</span> <a class="code" href="structtypefunc__t.html">typefunc_t</a> *tf) {
02184     <span class="keywordflow">if</span>(tf-&gt;<a class="code" href="structtypefunc__t.html#o3">pos</a> &amp; <a class="code" href="codeform_8c.html#a99a13">POS_END</a> &amp;&amp; !**tf-&gt;<a class="code" href="structtypefunc__t.html#o1">p</a>) {
02185         tf-&gt;<a class="code" href="structtypefunc__t.html#o3">pos</a> &amp;= ~<a class="code" href="codeform_8c.html#a99a13">POS_END</a>;
02186         fputs(rule-&gt;<a class="code" href="structonerule__t.html#o0">data</a>.<a class="code" href="structstrings__t.html#o0">data</a>[0], tf-&gt;<a class="code" href="structtypefunc__t.html#o0">out</a>);
02187     }
02188 
02189     <span class="keywordflow">return</span> 0;
02190 }
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Sat Apr 7 11:13:17 2007 for codeform by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.2 </small></address>
</body>
</html>
