<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>codeform</title>
<style type="text/css">
.keyword { color: blue; }
.keyworddark { color: darkblue; }
.midword { color: darkred; }
.midwordlight { color: red; }
.comment { color: green; }
.commentdoc { color: darkgreen; }
.string { color: red; }
.nestcom { color: green; }
.number { color: blue; }
.fpnumber { color: darkblue; }
</style></head><body><pre>
<span class="commentdoc">/*! \mainpage

    codeform, a code formatter and colourer [intended] for C and C++ \n
    Copyright (C) 2007 DWK

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

    The GNU General Public License version 2 is included in the file COPYING.

    \author DWK
        dwks@theprogrammingsite.com \n
        http://dwks.theprogrammingsite.com/ \n

    \version 1.2.0

    At the time of this writing, codeform is available at:
        http://dwks.theprogrammingsite.com/myprogs/codeform.htm
*/</span>

<span class="commentdoc">/*! \file codeform.c

    The one and only source file for codeform.

    This source file compiles without warnings with GCC 2.95.2 and 3.3.3: \n
        $ gcc -W -Wall -ansi -pedantic -O2 -g -o codeform codeform.c
*/</span>

<span class="nestcom">#include &lt;stdio.h&gt;</span>
<span class="nestcom">#include &lt;stddef.h&gt;</span>
<span class="nestcom">#include &lt;stdlib.h&gt;</span>
<span class="nestcom">#include &lt;string.h&gt;</span>
<span class="nestcom">#include &lt;ctype.h&gt;</span>

<span class="commentdoc">/*! Version of codeform. */</span>
<span class="nestcom">#define VERSION "codeform version 1.2.0 by DWK"</span>

<span class="commentdoc">/*! An array of strings. Stores the length of each string. */</span>
<span class="keyword">struct</span> strings_t <span class="midword">{</span>
    <span class="keyword">char</span> <span class="midwordlight">**</span>data;
    <span class="keyworddark">size_t</span> <span class="midwordlight">*</span>len;
    <span class="keyworddark">size_t</span> number;
<span class="midword">}</span>;

<span class="commentdoc">/*! The type of a rule. */</span>
<span class="keyword">enum</span> type_t <span class="midword">{</span>
    TYPE_KEYWORD,
    TYPE_MIDWORD,
    TYPE_COMMENT,
    TYPE_STRING,
    TYPE_NESTCOM,
    TYPE_NUMBER,
    TYPE_FPNUMBER,
    TYPE_START,
    TYPE_END,
    TYPES,  <span class="commentdoc">/*!&lt; Number of values for \c type_t (this enum). */</span>
    TYPE_ERROR = -<span class="number">1</span>
<span class="midword">}</span>;

<span class="commentdoc">/*! Flag values to indicate the position in the current file (can be OR'd
    together).
*/</span>
<span class="keyword">enum</span> pos_t <span class="midword">{</span>
    POS_START = <span class="number">1</span>,
    POS_END = <span class="number">2</span>
<span class="midword">}</span>;

<span class="commentdoc">/*! File names passed to the program on the command line. */</span>
<span class="keyword">struct</span> argument_t <span class="midword">{</span>
    <span class="keyword">struct</span> strings_t inputfn, outputfn, rulefn, ilrule;
<span class="midword">}</span>;

<span class="commentdoc">/*! A rule, containing sections and a type. */</span>
<span class="keyword">struct</span> onerule_t <span class="midword">{</span>
    <span class="keyword">struct</span> strings_t data;  <span class="commentdoc">/*!&lt; The data for the rule. */</span>

    <span class="keyworddark">size_t</span> type;  <span class="commentdoc">/*!&lt; Type of the rule (type_func number). */</span>

    <span class="keyworddark">size_t</span> prev;  <span class="commentdoc">/*!&lt; Rule starting with the same as this one. */</span>
<span class="midword">}</span>;

<span class="commentdoc">/*! A pointer to the previous rule parsed (for '*' sections). */</span>
<span class="keyword">struct</span> prevrule_t <span class="midword">{</span>
    <span class="keyword">enum</span> type_t type;        <span class="comment">/* The current header type. */</span>
    <span class="keyword">struct</span> onerule_t <span class="midwordlight">*</span>one;   <span class="comment">/* The current rule being parsed. */</span>
    <span class="keyword">struct</span> onerule_t <span class="midwordlight">*</span>prev;  <span class="comment">/* The previous rule. */</span>
    <span class="comment">/* True if prev is the only pointer to a dynamically allocated structure,
        and so needs freeing. */</span>
    <span class="keyword">int</span> freep;
<span class="midword">}</span>;

<span class="commentdoc">/*! A variable. */</span>
<span class="keyword">struct</span> onevar_t <span class="midword">{</span>
    <span class="comment">/* The name of the variable and the text to replace it with. */</span>
    <span class="keyword">char</span> <span class="midwordlight">*</span>from, <span class="midwordlight">*</span>to;
    <span class="keyworddark">size_t</span> flen, tlen;  <span class="comment">/* The length of \c from and \c to. */</span>
<span class="midword">}</span>;

<span class="commentdoc">/*! Array of all the rules. */</span>
<span class="keyword">struct</span> ruledata_t <span class="midword">{</span>
    <span class="keyword">struct</span> onerule_t <span class="midwordlight">**</span>data;
    <span class="keyworddark">size_t</span> number;
<span class="midword">}</span>;

<span class="commentdoc">/*! List of type_func functions, representing which comments the parser is
    inside. Since comments can be nested, it stores a list of function numbers.
*/</span>
<span class="keyword">struct</span> funclist_t <span class="midword">{</span>
    <span class="keyworddark">size_t</span> <span class="midwordlight">*</span>which;
    <span class="keyword">enum</span> type_t <span class="midwordlight">*</span>type;
    <span class="keyworddark">size_t</span> number;

    <span class="comment">/* True if the current comment supports nesting of other comments inside it. */</span>
    <span class="keyword">int</span> nest;
<span class="midword">}</span>;

<span class="commentdoc">/*! The previous tag, its beginning and end. */</span>
<span class="keyword">struct</span> rulelist_t <span class="midword">{</span>
    <span class="keyword">const char</span> <span class="midwordlight">*</span>from, <span class="midwordlight">*</span>to;
    <span class="keyword">char</span> <span class="midwordlight">*</span>ws;
    <span class="keyworddark">size_t</span> wslen;
<span class="midword">}</span>;

<span class="commentdoc">/*! Structure passed to the type_func functions, containing all of the non-rule
    related data they might need.
*/</span>
<span class="keyword">struct</span> typefunc_t <span class="midword">{</span>
    <span class="keyworddark">FILE</span> <span class="midwordlight">*</span>out;  <span class="comment">/* Output file stream to write data to. */</span>
    <span class="keyword">char</span> <span class="midwordlight">**</span>p;  <span class="comment">/* Pointer to the current position in the string. */</span>
    <span class="keyword">int</span> iw;  <span class="comment">/* True if the previous character was a word character. */</span>
    <span class="keyword">enum</span> pos_t pos;  <span class="comment">/* Flags for the beginning and end of the file. */</span>
    <span class="keyworddark">size_t</span> n;  <span class="comment">/* Character count from the beginning of the string. */</span>
    <span class="keyworddark">size_t</span> number;  <span class="comment">/* Element in ruledata_t that the rule is. */</span>
    <span class="keyword">enum</span> type_t type;  <span class="comment">/* The type of rule. */</span>

    <span class="keyword">struct</span> funclist_t func;  <span class="comment">/* List of nested comments. */</span>
    <span class="keyword">struct</span> rulelist_t <span class="midwordlight">*</span>list;  <span class="comment">/* The previous tag. */</span>
<span class="midword">}</span>;

<span class="commentdoc">/*! A rule type. */</span>
<span class="keyword">struct</span> ruletype_t <span class="midword">{</span>
    <span class="keyword">const char</span> <span class="midwordlight">*</span>name;  <span class="comment">/* The name of this type of rule. */</span>
    <span class="keyworddark">size_t</span> sort;  <span class="comment">/* The part to sort by. */</span>
    <span class="keyword">int</span> parts, xparts;  <span class="comment">/* Minimum parts, and optional extra parts. */</span>

    <span class="comment">/* A pointer to the function that handles this type of rule. */</span>
    <span class="keyword">int</span> <span class="midword">(</span><span class="midwordlight">*</span>func<span class="midword">)(</span><span class="keyword">struct</span> onerule_t <span class="midwordlight">*</span>rule, <span class="keyword">struct</span> typefunc_t <span class="midwordlight">*</span>tf<span class="midword">)</span>;
<span class="midword">}</span>;

<span class="commentdoc">/*! Array of variables. */</span>
<span class="keyword">struct</span> rulevars_t <span class="midword">{</span>
    <span class="keyword">struct</span> onevar_t <span class="midwordlight">**</span>data;
    <span class="keyworddark">size_t</span> number;
<span class="midword">}</span>;

<span class="commentdoc">/*! Base rules structure, containing types, rules, and variables. */</span>
<span class="keyword">struct</span> rules_t <span class="midword">{</span>
    <span class="keyword">struct</span> ruletype_t type<span class="midword">[</span>TYPES<span class="midword">]</span>;
    <span class="keyword">struct</span> rulevars_t vars;
    <span class="keyword">struct</span> rulelist_t list;
    <span class="keyword">struct</span> ruledata_t data;
    <span class="keyword">struct</span> onerule_t <span class="midwordlight">*</span>cdat<span class="midword">[</span>TYPES<span class="midword">]</span>;
    <span class="keyword">struct</span> prevrule_t pr;
<span class="midword">}</span>;

<span class="comment">/*----------------------*\
 | Function prototypes. |
\*----------------------*/</span>

<span class="keyword">void</span> parse_arguments<span class="midword">(</span><span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="midwordlight">*</span>argv<span class="midword">[]</span>, <span class="keyword">struct</span> argument_t <span class="midwordlight">*</span>arg<span class="midword">)</span>;
<span class="keyword">void</span> add_string<span class="midword">(</span><span class="keyword">struct</span> strings_t <span class="midwordlight">*</span>data, <span class="keyword">const char</span> <span class="midwordlight">*</span>str<span class="midword">)</span>;
<span class="keyword">void</span> add_string_len<span class="midword">(</span><span class="keyword">struct</span> strings_t <span class="midwordlight">*</span>data, <span class="keyword">const char</span> <span class="midwordlight">*</span>str, <span class="keyworddark">size_t</span> len<span class="midword">)</span>;
<span class="keyword">void</span> add_string_copy<span class="midword">(</span><span class="keyword">struct</span> strings_t <span class="midwordlight">*</span>data, <span class="keyword">const struct</span> strings_t <span class="midwordlight">*</span>prev<span class="midword">)</span>;
<span class="keyword">void</span> shrink_string<span class="midword">(</span><span class="keyword">char</span> <span class="midwordlight">**</span>str, <span class="keyworddark">size_t</span> len<span class="midword">)</span>;
<span class="keyword">int</span> check_usage<span class="midword">(</span><span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="midwordlight">*</span>argv<span class="midword">[])</span>;
<span class="keyword">void</span> print_usage<span class="midword">(</span><span class="keyword">const char</span> <span class="midwordlight">*</span>progname<span class="midword">)</span>;
<span class="keyword">void</span> print_version<span class="midword">(</span><span class="keyword">void</span><span class="midword">)</span>;
<span class="keyword">void</span> out_of_memory<span class="midword">(</span><span class="keyword">const char</span> <span class="midwordlight">*</span>file, <span class="keyword">int</span> line<span class="midword">)</span>;
<span class="keyword">void</span> free_ruledata<span class="midword">(</span><span class="keyword">const struct</span> ruledata_t <span class="midwordlight">*</span>ruledata<span class="midword">)</span>;
<span class="keyword">void</span> free_rulecdat<span class="midword">(</span><span class="keyword">const struct</span> rules_t <span class="midwordlight">*</span>rules<span class="midword">)</span>;
<span class="keyword">void</span> free_onerule<span class="midword">(</span><span class="keyword">const struct</span> ruledata_t <span class="midwordlight">*</span>ruledata, <span class="keyworddark">size_t</span> which<span class="midword">)</span>;
<span class="keyword">void</span> free_strings<span class="midword">(</span><span class="keyword">const struct</span> strings_t <span class="midwordlight">*</span>strings<span class="midword">)</span>;
<span class="keyword">void</span> free_dup_onerule<span class="midword">(</span><span class="keyword">struct</span> onerule_t <span class="midwordlight">*</span>rule, <span class="keyword">const struct</span> onerule_t <span class="midwordlight">*</span>prev<span class="midword">)</span>;
<span class="keyword">void</span> free_rulevars<span class="midword">(</span><span class="keyword">const struct</span> rulevars_t <span class="midwordlight">*</span>rulevars<span class="midword">)</span>;
<span class="keyword">void</span> free_onevar<span class="midword">(</span><span class="keyword">const struct</span> onevar_t <span class="midwordlight">*</span>var<span class="midword">)</span>;
<span class="keyword">void</span> free_argument<span class="midword">(</span><span class="keyword">const struct</span> argument_t <span class="midwordlight">*</span>argument<span class="midword">)</span>;
<span class="keyword">void</span> free_prevrule<span class="midword">(</span><span class="keyword">struct</span> prevrule_t <span class="midwordlight">*</span>pr<span class="midword">)</span>;

<span class="keyworddark">FILE</span> <span class="midwordlight">*</span>open_file<span class="midword">(</span><span class="keyword">const char</span> <span class="midwordlight">*</span>fn, <span class="keyword">const char</span> <span class="midwordlight">*</span>mode<span class="midword">)</span>;
<span class="keyworddark">size_t</span> get_string<span class="midword">(</span><span class="keyword">char</span> <span class="midwordlight">**</span>line, <span class="keyworddark">size_t</span> len, <span class="keyworddark">size_t</span> <span class="midwordlight">*</span>alen, <span class="keyworddark">FILE</span> <span class="midwordlight">*</span>fp<span class="midword">)</span>;
<span class="keyword">void</span> load_rules<span class="midword">(</span><span class="keyword">struct</span> rules_t <span class="midwordlight">*</span>rules, <span class="keyword">const struct</span> strings_t <span class="midwordlight">*</span>rulefn<span class="midword">)</span>;
<span class="keyword">void</span> add_ilrules<span class="midword">(</span><span class="keyword">struct</span> rules_t <span class="midwordlight">*</span>rules, <span class="keyword">const struct</span> strings_t <span class="midwordlight">*</span>ilrule<span class="midword">)</span>;
<span class="keyword">void</span> add_rules_file_dir<span class="midword">(</span><span class="keyword">struct</span> rules_t <span class="midwordlight">*</span>rules, <span class="keyword">const char</span> <span class="midwordlight">*</span>fn,
    <span class="keyword">const char</span> <span class="midwordlight">*</span>dir<span class="midword">)</span>;
<span class="keyword">void</span> add_rules_file<span class="midword">(</span><span class="keyword">struct</span> rules_t <span class="midwordlight">*</span>rules, <span class="keyword">const char</span> <span class="midwordlight">*</span>fn<span class="midword">)</span>;
<span class="keyword">void</span> add_rule_var<span class="midword">(</span><span class="keyword">struct</span> rules_t <span class="midwordlight">*</span>rules, <span class="keyword">char</span> <span class="midwordlight">*</span>str, <span class="keyword">const char</span> <span class="midwordlight">*</span>file,
    <span class="keyword">int</span> line<span class="midword">)</span>;
<span class="keyword">void</span> add_var<span class="midword">(</span><span class="keyword">struct</span> rulevars_t <span class="midwordlight">*</span>vars, <span class="keyword">char</span> <span class="midwordlight">*</span>str, <span class="keyword">char</span> <span class="midwordlight">*</span>eq<span class="midword">)</span>;
<span class="keyword">int</span> find_var_pos<span class="midword">(</span><span class="keyword">struct</span> rulevars_t <span class="midwordlight">*</span>vars, <span class="keyword">const char</span> <span class="midwordlight">*</span>p, <span class="keyworddark">size_t</span> <span class="midwordlight">*</span>pos<span class="midword">)</span>;
<span class="keyword">int</span> add_rule_type<span class="midword">(</span><span class="keyword">struct</span> rules_t <span class="midwordlight">*</span>rules, <span class="keyword">enum</span> type_t <span class="midwordlight">*</span>t, <span class="keyword">char</span> <span class="midwordlight">**</span>str,
    <span class="keyword">const char</span> <span class="midwordlight">*</span>file, <span class="keyword">int</span> line<span class="midword">)</span>;
<span class="keyword">int</span> add_rule_pos<span class="midword">(</span><span class="keyword">struct</span> rules_t <span class="midwordlight">*</span>rules, <span class="keyworddark">size_t</span> rsort, <span class="keyword">struct</span> onerule_t <span class="midwordlight">*</span>one<span class="midword">)</span>;
<span class="keyword">struct</span> onerule_t <span class="midwordlight">*</span>rule_new<span class="midword">(</span><span class="keyword">void</span><span class="midword">)</span>;
<span class="keyword">void</span> add_rule_new<span class="midword">(</span><span class="keyword">struct</span> ruledata_t <span class="midwordlight">*</span>rd<span class="midword">)</span>;
<span class="keyword">void</span> add_rule<span class="midword">(</span><span class="keyword">struct</span> rules_t <span class="midwordlight">*</span>rules, <span class="keyword">char</span> <span class="midwordlight">*</span>str, <span class="keyword">const char</span> <span class="midwordlight">*</span>file, <span class="keyword">int</span> line<span class="midword">)</span>;
<span class="keyword">int</span> add_allocated_rule<span class="midword">(</span><span class="keyword">struct</span> rules_t <span class="midwordlight">*</span>rules, <span class="keyword">struct</span> onerule_t <span class="midwordlight">**</span>cdat,
    <span class="keyworddark">size_t</span> sort<span class="midword">)</span>;
<span class="keyword">void</span> add_parts<span class="midword">(</span><span class="keyword">struct</span> strings_t <span class="midwordlight">*</span>data, <span class="keyword">const struct</span> strings_t <span class="midwordlight">*</span>prev,
    <span class="keyword">const char</span> <span class="midwordlight">*</span>str<span class="midword">)</span>;
<span class="keyword">int</span> check_parts<span class="midword">(</span><span class="keyword">int</span> rparts, <span class="keyword">int</span> xparts, <span class="keyword">const char</span> <span class="midwordlight">*</span>str<span class="midword">)</span>;
<span class="keyword">void</span> process_escapes<span class="midword">(</span><span class="keyword">struct</span> strings_t <span class="midwordlight">*</span>data<span class="midword">)</span>;
<span class="keyword">void</span> remove_escapes<span class="midword">(</span><span class="keyword">char</span> <span class="midwordlight">**</span>str, <span class="keyworddark">size_t</span> <span class="midwordlight">*</span>len<span class="midword">)</span>;
<span class="keyword">void</span> process_vars<span class="midword">(</span><span class="keyword">const struct</span> rulevars_t <span class="midwordlight">*</span>vars, <span class="keyword">struct</span> strings_t <span class="midwordlight">*</span>data<span class="midword">)</span>;
<span class="keyword">void</span> replace_var_str<span class="midword">(</span><span class="keyword">const struct</span> rulevars_t <span class="midwordlight">*</span>vars, <span class="keyword">char</span> <span class="midwordlight">**</span>str<span class="midword">)</span>;
<span class="keyword">void</span> resize_var_string<span class="midword">(</span><span class="keyword">char</span> <span class="midwordlight">**</span>str, <span class="keyword">char</span> <span class="midwordlight">**</span>pos, <span class="keyworddark">size_t</span> len<span class="midword">)</span>;
<span class="keyword">void</span> find_var_replace<span class="midword">(</span><span class="keyword">const struct</span> rulevars_t <span class="midwordlight">*</span>vars, <span class="keyword">char</span> <span class="midwordlight">**</span>str, <span class="keyword">char</span> <span class="midwordlight">**</span>p,
    <span class="keyword">char</span> <span class="midwordlight">*</span>end<span class="midword">)</span>;
<span class="keyword">int</span> replace_onevar<span class="midword">(</span><span class="keyword">const struct</span> onevar_t <span class="midwordlight">*</span>var, <span class="keyword">char</span> <span class="midwordlight">**</span>str, <span class="keyword">char</span> <span class="midwordlight">**</span>pos,
    <span class="keyword">char</span> <span class="midwordlight">*</span>end<span class="midword">)</span>;
<span class="keyword">void</span> replace_novar<span class="midword">(</span><span class="keyworddark">size_t</span> cp, <span class="keyword">char</span> <span class="midwordlight">**</span>str, <span class="keyword">char</span> <span class="midwordlight">**</span>pos<span class="midword">)</span>;
<span class="keyworddark">size_t</span> get_type<span class="midword">(</span><span class="keyword">struct</span> rules_t <span class="midwordlight">*</span>rules, <span class="keyword">const char</span> <span class="midwordlight">*</span>str, <span class="keyword">enum</span> type_t <span class="midwordlight">*</span>type<span class="midword">)</span>;

<span class="keyword">void</span> parse_files<span class="midword">(</span><span class="keyword">struct</span> rules_t <span class="midwordlight">*</span>rules, <span class="keyword">struct</span> strings_t <span class="midwordlight">*</span>inputfn,
    <span class="keyword">struct</span> strings_t <span class="midwordlight">*</span>outputfn<span class="midword">)</span>;
<span class="keyword">void</span> read_file<span class="midword">(</span><span class="keyword">struct</span> rules_t <span class="midwordlight">*</span>rules, <span class="keyword">const char</span> <span class="midwordlight">*</span>fn, <span class="keyworddark">FILE</span> <span class="midwordlight">*</span>out<span class="midword">)</span>;
<span class="keyword">void</span> parse_line<span class="midword">(</span><span class="keyword">struct</span> rules_t <span class="midwordlight">*</span>rules, <span class="keyword">char</span> <span class="midwordlight">*</span>line, <span class="keyworddark">FILE</span> <span class="midwordlight">*</span>out,
    <span class="keyword">struct</span> typefunc_t <span class="midwordlight">*</span>tf<span class="midword">)</span>;
<span class="keyword">int</span> call_one_type<span class="midword">(</span><span class="keyword">struct</span> rules_t <span class="midwordlight">*</span>rules, <span class="keyword">struct</span> typefunc_t <span class="midwordlight">*</span>tf<span class="midword">)</span>;
<span class="keyword">int</span> call_type_cdat<span class="midword">(</span><span class="keyword">struct</span> rules_t <span class="midwordlight">*</span>rules, <span class="keyword">struct</span> typefunc_t <span class="midwordlight">*</span>tf<span class="midword">)</span>;
<span class="keyword">int</span> call_type_funcs<span class="midword">(</span><span class="keyword">struct</span> rules_t <span class="midwordlight">*</span>rules, <span class="keyword">struct</span> typefunc_t <span class="midwordlight">*</span>tf<span class="midword">)</span>;
<span class="keyword">void</span> set_rules_prev<span class="midword">(</span><span class="keyword">struct</span> rules_t <span class="midwordlight">*</span>rules<span class="midword">)</span>;
<span class="keyword">void</span> set_follow_prev<span class="midword">(</span><span class="keyword">struct</span> rules_t <span class="midwordlight">*</span>rules, <span class="keyworddark">size_t</span> start<span class="midword">)</span>;
<span class="keyword">int</span> find_rule_match<span class="midword">(</span><span class="keyword">const struct</span> rules_t <span class="midwordlight">*</span>rules, <span class="keyword">const char</span> <span class="midwordlight">*</span>p, <span class="keyworddark">size_t</span> <span class="midwordlight">*</span>pos<span class="midword">)</span>;
<span class="keyword">int</span> find_rule_new<span class="midword">(</span><span class="keyword">const struct</span> rules_t <span class="midwordlight">*</span>rules, <span class="keyword">const char</span> <span class="midwordlight">*</span>p, <span class="keyworddark">size_t</span> <span class="midwordlight">*</span>pos<span class="midword">)</span>;
<span class="keyword">int</span> find_rule_prev<span class="midword">(</span><span class="keyword">const struct</span> rules_t <span class="midwordlight">*</span>rules, <span class="keyword">const char</span> <span class="midwordlight">*</span>p, <span class="keyworddark">size_t</span> <span class="midwordlight">*</span>pos<span class="midword">)</span>;
<span class="keyword">void</span> copy_file<span class="midword">(</span><span class="keyworddark">FILE</span> <span class="midwordlight">*</span>from, <span class="keyword">const char</span> <span class="midwordlight">*</span>fn<span class="midword">)</span>;

<span class="keyword">int</span> is_number<span class="midword">(</span><span class="keyword">const char</span> <span class="midwordlight">*</span>p<span class="midword">)</span>;
<span class="keyword">int</span> is_fpnumber<span class="midword">(</span><span class="keyword">const char</span> <span class="midwordlight">*</span>p<span class="midword">)</span>;
<span class="keyword">void</span> print_number<span class="midword">(</span><span class="keyword">char</span> <span class="midwordlight">**</span>p, <span class="keyworddark">FILE</span> <span class="midwordlight">*</span>out<span class="midword">)</span>;
<span class="keyword">int</span> is_word<span class="midword">(</span><span class="keyword">int</span> c<span class="midword">)</span>;
<span class="keyword">int</span> is_backslashed<span class="midword">(</span><span class="keyword">const char</span> <span class="midwordlight">*</span>start, <span class="keyword">const char</span> <span class="midwordlight">*</span>p<span class="midword">)</span>;
<span class="keyword">void</span> remove_char<span class="midword">(</span><span class="keyword">char</span> <span class="midwordlight">*</span>p<span class="midword">)</span>;
<span class="keyword">int</span> is_word<span class="midword">(</span><span class="keyword">int</span> c<span class="midword">)</span>;
<span class="keyword">int</span> is_word_prev<span class="midword">(</span><span class="keyword">const char</span> <span class="midwordlight">*</span>line, <span class="keyword">const char</span> <span class="midwordlight">*</span>p<span class="midword">)</span>;
<span class="keyword">void</span> remove_comments<span class="midword">(</span><span class="keyword">char</span> <span class="midwordlight">*</span>s<span class="midword">)</span>;
<span class="keyword">char</span> <span class="midwordlight">*</span>is_var<span class="midword">(</span><span class="keyword">char</span> <span class="midwordlight">*</span>s<span class="midword">)</span>;
<span class="keyword">int</span> is_current_dir<span class="midword">(</span><span class="keyword">const char</span> <span class="midwordlight">*</span>s<span class="midword">)</span>;
<span class="keyword">void</span> print_chars<span class="midword">(</span><span class="keyword">char</span> <span class="midwordlight">**</span>p, <span class="keyworddark">size_t</span> len, <span class="keyworddark">FILE</span> <span class="midwordlight">*</span>out<span class="midword">)</span>;
<span class="keyword">void</span> add_to_funclist<span class="midword">(</span><span class="keyword">struct</span> funclist_t <span class="midwordlight">*</span>func, <span class="keyworddark">size_t</span> which, <span class="keyword">enum</span> type_t type<span class="midword">)</span>;
<span class="keyword">void</span> remove_from_funclist<span class="midword">(</span><span class="keyword">struct</span> funclist_t <span class="midwordlight">*</span>func<span class="midword">)</span>;
<span class="keyword">void</span> add_ws_rulelist<span class="midword">(</span><span class="keyword">struct</span> rulelist_t <span class="midwordlight">*</span>list, <span class="keyword">char</span> c<span class="midword">)</span>;
<span class="keyword">void</span> print_ws_rulelist<span class="midword">(</span><span class="keyword">struct</span> rulelist_t <span class="midwordlight">*</span>list, <span class="keyworddark">FILE</span> <span class="midwordlight">*</span>out<span class="midword">)</span>;
<span class="keyword">void</span> append_rulelist<span class="midword">(</span><span class="keyword">const char</span> <span class="midwordlight">*</span>from, <span class="keyword">const char</span> <span class="midwordlight">*</span>to, <span class="keyword">struct</span> rulelist_t <span class="midwordlight">*</span>list,
    <span class="keyworddark">FILE</span> <span class="midwordlight">*</span>out<span class="midword">)</span>;
<span class="keyword">void</span> chomp_newline<span class="midword">(</span><span class="keyword">char</span> <span class="midwordlight">*</span>str, <span class="keyworddark">size_t</span> <span class="midwordlight">*</span>flen<span class="midword">)</span>;

<span class="keyword">int</span> type_keyword<span class="midword">(</span><span class="keyword">struct</span> onerule_t <span class="midwordlight">*</span>rule, <span class="keyword">struct</span> typefunc_t <span class="midwordlight">*</span>tf<span class="midword">)</span>;
<span class="keyword">int</span> type_midword<span class="midword">(</span><span class="keyword">struct</span> onerule_t <span class="midwordlight">*</span>rule, <span class="keyword">struct</span> typefunc_t <span class="midwordlight">*</span>tf<span class="midword">)</span>;
<span class="keyword">int</span> type_comment_end<span class="midword">(</span><span class="keyword">struct</span> onerule_t <span class="midwordlight">*</span>rule, <span class="keyword">struct</span> typefunc_t <span class="midwordlight">*</span>tf<span class="midword">)</span>;
<span class="keyword">int</span> type_comment<span class="midword">(</span><span class="keyword">struct</span> onerule_t <span class="midwordlight">*</span>rule, <span class="keyword">struct</span> typefunc_t <span class="midwordlight">*</span>tf<span class="midword">)</span>;
<span class="keyword">int</span> type_string<span class="midword">(</span><span class="keyword">struct</span> onerule_t <span class="midwordlight">*</span>rule, <span class="keyword">struct</span> typefunc_t <span class="midwordlight">*</span>tf<span class="midword">)</span>;
<span class="keyword">int</span> type_nestcom<span class="midword">(</span><span class="keyword">struct</span> onerule_t <span class="midwordlight">*</span>rule, <span class="keyword">struct</span> typefunc_t <span class="midwordlight">*</span>tf<span class="midword">)</span>;
<span class="keyword">int</span> type_number<span class="midword">(</span><span class="keyword">struct</span> onerule_t <span class="midwordlight">*</span>rule, <span class="keyword">struct</span> typefunc_t <span class="midwordlight">*</span>tf<span class="midword">)</span>;
<span class="keyword">int</span> type_fpnumber<span class="midword">(</span><span class="keyword">struct</span> onerule_t <span class="midwordlight">*</span>rule, <span class="keyword">struct</span> typefunc_t <span class="midwordlight">*</span>tf<span class="midword">)</span>;
<span class="keyword">int</span> type_start<span class="midword">(</span><span class="keyword">struct</span> onerule_t <span class="midwordlight">*</span>rule, <span class="keyword">struct</span> typefunc_t <span class="midwordlight">*</span>tf<span class="midword">)</span>;
<span class="keyword">int</span> type_end<span class="midword">(</span><span class="keyword">struct</span> onerule_t <span class="midwordlight">*</span>rule, <span class="keyword">struct</span> typefunc_t <span class="midwordlight">*</span>tf<span class="midword">)</span>;

<span class="comment">/*------------*\
 | Functions. |
\*------------*/</span>

<span class="commentdoc">/*! Program entry point. Acts as a driver function, calling other functions.
    \param argc Number of arguments passed to the program.
    \param argv Array of command-line arguments, including program name.
    \return Always returns 0, indicating success.
*/</span>
<span class="keyword">int</span> main<span class="midword">(</span><span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="midwordlight">*</span>argv<span class="midword">[]) {</span>
    <span class="keyword">struct</span> argument_t arg = <span class="midword">{</span>
        <span class="midword">{</span><span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span><span class="midword">}</span>,
        <span class="midword">{</span><span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span><span class="midword">}</span>,
        <span class="midword">{</span><span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span><span class="midword">}</span>,
        <span class="midword">{</span><span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span><span class="midword">}</span>
    <span class="midword">}</span>;
    <span class="keyword">struct</span> rules_t rules = <span class="midword">{</span>
        <span class="midword">{</span>
            <span class="midword">{</span><span class="string">"keyword"</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">1</span>, type_keyword<span class="midword">}</span>,
            <span class="midword">{</span><span class="string">"midword"</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">1</span>, type_midword<span class="midword">}</span>,
            <span class="midword">{</span><span class="string">"comment"</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">1</span>, type_comment<span class="midword">}</span>,
            <span class="midword">{</span><span class="string">"string"</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">1</span>, type_string<span class="midword">}</span>,
            <span class="midword">{</span><span class="string">"nestcom"</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">1</span>, type_nestcom<span class="midword">}</span>,
            <span class="midword">{</span><span class="string">"number"</span>, <span class="midword">(</span><span class="keyworddark">size_t</span><span class="midword">)</span>-<span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, type_number<span class="midword">}</span>,
            <span class="midword">{</span><span class="string">"fpnumber"</span>, <span class="midword">(</span><span class="keyworddark">size_t</span><span class="midword">)</span>-<span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, type_fpnumber<span class="midword">}</span>,
            <span class="midword">{</span><span class="string">"start"</span>, <span class="midword">(</span><span class="keyworddark">size_t</span><span class="midword">)</span>-<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, type_start<span class="midword">}</span>,
            <span class="midword">{</span><span class="string">"end"</span>, <span class="midword">(</span><span class="keyworddark">size_t</span><span class="midword">)</span>-<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, type_end<span class="midword">}</span>,
        <span class="midword">}</span>,
        <span class="midword">{</span><span class="number">0</span>, <span class="number">0</span><span class="midword">}</span>,
        <span class="midword">{</span><span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span><span class="midword">}</span>,
        <span class="midword">{</span><span class="number">0</span>, <span class="number">0</span><span class="midword">}</span>,
        <span class="midword">{</span><span class="number">0</span><span class="midword">}</span>,
        <span class="midword">{</span>TYPE_ERROR, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span><span class="midword">}</span>
    <span class="midword">}</span>;  <span class="comment">/* The only instance of the structure \c rules_t. */</span>

    <span class="keyword">if</span><span class="midword">(</span>check_usage<span class="midword">(</span>argc, argv<span class="midword">))</span> <span class="keyword">return</span> <span class="number">0</span>;

    parse_arguments<span class="midword">(</span>argc, argv, <span class="midwordlight">&amp;</span>arg<span class="midword">)</span>;

    add_ilrules<span class="midword">(</span><span class="midwordlight">&amp;</span>rules, <span class="midwordlight">&amp;</span>arg.ilrule<span class="midword">)</span>;
    load_rules<span class="midword">(</span><span class="midwordlight">&amp;</span>rules, <span class="midwordlight">&amp;</span>arg.rulefn<span class="midword">)</span>;
    set_rules_prev<span class="midword">(</span><span class="midwordlight">&amp;</span>rules<span class="midword">)</span>;

    parse_files<span class="midword">(</span><span class="midwordlight">&amp;</span>rules, <span class="midwordlight">&amp;</span>arg.inputfn, <span class="midwordlight">&amp;</span>arg.outputfn<span class="midword">)</span>;

    <span class="comment">/* Free all allocated memory. */</span>

    free_ruledata<span class="midword">(</span><span class="midwordlight">&amp;</span>rules.data<span class="midword">)</span>;
    free_rulecdat<span class="midword">(</span><span class="midwordlight">&amp;</span>rules<span class="midword">)</span>;
    free_rulevars<span class="midword">(</span><span class="midwordlight">&amp;</span>rules.vars<span class="midword">)</span>;
    free_prevrule<span class="midword">(</span><span class="midwordlight">&amp;</span>rules.pr<span class="midword">)</span>;
    free_argument<span class="midword">(</span><span class="midwordlight">&amp;</span>arg<span class="midword">)</span>;

    <span class="keyword">return</span> <span class="number">0</span>;
<span class="midword">}</span>

<span class="commentdoc">/*! Parses the command-line parameters passed to codeform on the command line.
    Stores the results in \a arg.
    \param argc Number of arguments passed to the program.
    \param argv Array of command-line arguments, including executable name.
    \param arg The structure to store the arguments in.
*/</span>
<span class="keyword">void</span> parse_arguments<span class="midword">(</span><span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="midwordlight">*</span>argv<span class="midword">[]</span>, <span class="keyword">struct</span> argument_t <span class="midwordlight">*</span>arg<span class="midword">) {</span>
    <span class="keyword">struct</span> strings_t <span class="midwordlight">*</span>p;
    <span class="keyword">int</span> x;

    <span class="comment">/* Parse command-line parameters. */</span>
    <span class="keyword">for</span><span class="midword">(</span>x = <span class="number">1</span>; x &lt; argc; x ++<span class="midword">) {</span>
        <span class="keyword">if</span><span class="midword">(</span>!strcmp<span class="midword">(</span>argv<span class="midword">[</span>x<span class="midword">]</span>, <span class="string">"--"</span><span class="midword">)) {</span>  <span class="comment">/* End of arguments. */</span>
            x ++;
            <span class="keyword">break</span>;
        <span class="midword">}</span>
        <span class="keyword">else if</span><span class="midword">(</span>!strcmp<span class="midword">(</span>argv<span class="midword">[</span>x<span class="midword">]</span>, <span class="string">"-e"</span><span class="midword">))</span> p = <span class="midwordlight">&amp;</span>arg-&gt;ilrule;  <span class="comment">/* Inline rule. */</span>
        <span class="keyword">else if</span><span class="midword">(</span>!strcmp<span class="midword">(</span>argv<span class="midword">[</span>x<span class="midword">]</span>, <span class="string">"-f"</span><span class="midword">))</span> p = <span class="midwordlight">&amp;</span>arg-&gt;rulefn;  <span class="comment">/* Rules file. */</span>
        <span class="keyword">else if</span><span class="midword">(</span>!strcmp<span class="midword">(</span>argv<span class="midword">[</span>x<span class="midword">]</span>, <span class="string">"-o"</span><span class="midword">))</span> p = <span class="midwordlight">&amp;</span>arg-&gt;outputfn;  <span class="comment">/* Output file. */</span>
        <span class="keyword">else break</span>;  <span class="comment">/* End of arguments. */</span>

        add_string<span class="midword">(</span>p, argv<span class="midword">[</span>++x<span class="midword">])</span>;
    <span class="midword">}</span>
    
    <span class="comment">/* Make the first non-command-line-argument argument an input file if there
        are no rules, much like sed. */</span>
    <span class="keyword">if</span><span class="midword">(</span>x &lt; argc <span class="midwordlight">&amp;&amp;</span> !arg-&gt;rulefn.number <span class="midwordlight">&amp;&amp;</span> !arg-&gt;ilrule.number<span class="midword">) {</span>
        add_string<span class="midword">(</span><span class="midwordlight">&amp;</span>arg-&gt;rulefn, argv<span class="midword">[</span>x++<span class="midword">])</span>;
    <span class="midword">}</span>

    <span class="comment">/* Parse remaining command-line parameters; rules or input files. */</span>
    <span class="keyword">for</span><span class="midword">(</span> ; x &lt; argc; x ++<span class="midword">) {</span>
        add_string<span class="midword">(</span><span class="midwordlight">&amp;</span>arg-&gt;inputfn, argv<span class="midword">[</span>x<span class="midword">])</span>;
    <span class="midword">}</span>
<span class="midword">}</span>

<span class="commentdoc">/*! Adds a string to a strings_t structure. Calls add_string_len().
    \param data The structure to add the string \a str to.
    \param str The string to add to \a data.
*/</span>
<span class="keyword">void</span> add_string<span class="midword">(</span><span class="keyword">struct</span> strings_t <span class="midwordlight">*</span>data, <span class="keyword">const char</span> <span class="midwordlight">*</span>str<span class="midword">) {</span>
    add_string_len<span class="midword">(</span>data, str, <span class="midword">(</span><span class="keyworddark">size_t</span><span class="midword">)</span>-<span class="number">1</span><span class="midword">)</span>;
<span class="midword">}</span>

<span class="commentdoc">/*! Adds a string of specified length to a strings_t structure.
    \param data The structure to add the string to.
    \param str The string to add to the structure, \a data. Only \a len
        characters are copied.
    \param len Number of characters to copy from the string \a str.
*/</span>
<span class="keyword">void</span> add_string_len<span class="midword">(</span><span class="keyword">struct</span> strings_t <span class="midwordlight">*</span>data, <span class="keyword">const char</span> <span class="midwordlight">*</span>str, <span class="keyworddark">size_t</span> len<span class="midword">) {</span>
    <span class="keyword">char</span> <span class="midwordlight">**</span>p;
    <span class="keyworddark">size_t</span> slen, <span class="midwordlight">*</span>tlen;

    slen = <span class="midword">(</span>len == <span class="midword">(</span><span class="keyworddark">size_t</span><span class="midword">)</span>-<span class="number">1</span> ? strlen<span class="midword">(</span>str<span class="midword">)</span> : len<span class="midword">)</span>;

    p = realloc<span class="midword">(</span>data-&gt;data, <span class="midword">(</span>data-&gt;number + <span class="number">1</span><span class="midword">)</span> <span class="midwordlight">*</span> <span class="keyword">sizeof</span><span class="midword">(</span><span class="keyword">char</span> <span class="midwordlight">*</span><span class="midword">))</span>;

    <span class="keyword">if</span><span class="midword">(</span>!p<span class="midword">)</span> out_of_memory<span class="midword">(</span>__FILE__, __LINE__<span class="midword">)</span>;

    data-&gt;data = p;
    data-&gt;data<span class="midword">[</span>data-&gt;number<span class="midword">]</span> = malloc<span class="midword">(</span>slen + <span class="number">1</span><span class="midword">)</span>;
    <span class="keyword">if</span><span class="midword">(</span>!data-&gt;data<span class="midword">[</span>data-&gt;number<span class="midword">])</span> out_of_memory<span class="midword">(</span>__FILE__, __LINE__<span class="midword">)</span>;

    <span class="keyword">if</span><span class="midword">(</span>len == <span class="midword">(</span><span class="keyworddark">size_t</span><span class="midword">)</span>-<span class="number">1</span><span class="midword">) {</span>
        strcpy<span class="midword">(</span>data-&gt;data<span class="midword">[</span>data-&gt;number<span class="midword">]</span>, str<span class="midword">)</span>;
    <span class="midword">}</span>
    <span class="keyword">else</span> <span class="midword">{</span>
        strncpy<span class="midword">(</span>data-&gt;data<span class="midword">[</span>data-&gt;number<span class="midword">]</span>, str, len<span class="midword">)</span>;
        data-&gt;data<span class="midword">[</span>data-&gt;number<span class="midword">][</span>len<span class="midword">]</span> = <span class="number">0</span>;
    <span class="midword">}</span>

    tlen = realloc<span class="midword">(</span>data-&gt;len, <span class="midword">(</span>data-&gt;number + <span class="number">1</span><span class="midword">)</span> <span class="midwordlight">*</span> <span class="keyword">sizeof</span><span class="midword">(</span><span class="keyworddark">size_t</span><span class="midword">))</span>;

    <span class="keyword">if</span><span class="midword">(</span>!tlen<span class="midword">)</span> out_of_memory<span class="midword">(</span>__FILE__, __LINE__<span class="midword">)</span>;

    data-&gt;len = tlen;
    data-&gt;len<span class="midword">[</span>data-&gt;number<span class="midword">]</span> = slen;

    data-&gt;number ++;
<span class="midword">}</span>

<span class="commentdoc">/*! Adds a string to \a data, the equivalent string in \a prev. The string
    itself isn't copied, the pointer is just set to the same position in
    (dynamically-allocated) memory.
    \param data The strings_t structure to add a string to.
    \param prev The structure to get the pointer to the string from.
*/</span>
<span class="keyword">void</span> add_string_copy<span class="midword">(</span><span class="keyword">struct</span> strings_t <span class="midwordlight">*</span>data, <span class="keyword">const struct</span> strings_t <span class="midwordlight">*</span>prev<span class="midword">) {</span>
    <span class="keyword">char</span> <span class="midwordlight">**</span>p;
    <span class="keyworddark">size_t</span> <span class="midwordlight">*</span>tlen;

    p = realloc<span class="midword">(</span>data-&gt;data, <span class="midword">(</span>data-&gt;number + <span class="number">1</span><span class="midword">)</span> <span class="midwordlight">*</span> <span class="keyword">sizeof</span><span class="midword">(</span><span class="keyword">char</span> <span class="midwordlight">*</span><span class="midword">))</span>;

    <span class="keyword">if</span><span class="midword">(</span>!p<span class="midword">)</span> out_of_memory<span class="midword">(</span>__FILE__, __LINE__<span class="midword">)</span>;

    data-&gt;data = p;

    data-&gt;data<span class="midword">[</span>data-&gt;number<span class="midword">]</span> = prev-&gt;data<span class="midword">[</span>data-&gt;number<span class="midword">]</span>;

    tlen = realloc<span class="midword">(</span>data-&gt;len, <span class="midword">(</span>data-&gt;number + <span class="number">1</span><span class="midword">)</span> <span class="midwordlight">*</span> <span class="keyword">sizeof</span><span class="midword">(</span><span class="keyworddark">size_t</span><span class="midword">))</span>;

    <span class="keyword">if</span><span class="midword">(</span>!tlen<span class="midword">)</span> out_of_memory<span class="midword">(</span>__FILE__, __LINE__<span class="midword">)</span>;

    data-&gt;len = tlen;
    data-&gt;len<span class="midword">[</span>data-&gt;number<span class="midword">]</span> = prev-&gt;len<span class="midword">[</span>data-&gt;number<span class="midword">]</span>;

    data-&gt;number ++;
<span class="midword">}</span>

<span class="commentdoc">/*! Reallocates the memory for the string \c str to be just enough. Used when
    some characters have been removed from the string (eg by remove_escapes()).
    \param str The string to shrink to the right size.
    \param len The new length of the string.
*/</span>
<span class="keyword">void</span> shrink_string<span class="midword">(</span><span class="keyword">char</span> <span class="midwordlight">**</span>str, <span class="keyworddark">size_t</span> len<span class="midword">) {</span>
    <span class="keyword">char</span> <span class="midwordlight">*</span>p = realloc<span class="midword">(</span><span class="midwordlight">*</span>str, len + <span class="number">1</span><span class="midword">)</span>;

    <span class="keyword">if</span><span class="midword">(</span>!p<span class="midword">)</span> out_of_memory<span class="midword">(</span>__FILE__, __LINE__<span class="midword">)</span>;

    <span class="midwordlight">*</span>str = p;
<span class="midword">}</span>

<span class="commentdoc">/*! Returns true if any of the command-line parameters are usage, help, or
    version requests. Called before parsing the rest of the arguments.
    \param argc Number of command-line parameters.
    \param argv Array of command-line parameters.
*/</span>
<span class="keyword">int</span> check_usage<span class="midword">(</span><span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="midwordlight">*</span>argv<span class="midword">[]) {</span>
    <span class="keyword">int</span> x;
    
    <span class="keyword">for</span><span class="midword">(</span>x = <span class="number">1</span>; x &lt; argc; x ++<span class="midword">) {</span>
        <span class="keyword">if</span><span class="midword">(</span>!strcmp<span class="midword">(</span>argv<span class="midword">[</span>x<span class="midword">]</span>, <span class="string">"--help"</span><span class="midword">)</span> || !strcmp<span class="midword">(</span>argv<span class="midword">[</span>x<span class="midword">]</span>, <span class="string">"-h"</span><span class="midword">)</span>
            || !strcmp<span class="midword">(</span>argv<span class="midword">[</span>x<span class="midword">]</span>, <span class="string">"--usage"</span><span class="midword">)) {</span>

            print_usage<span class="midword">(</span>argv<span class="midword">[</span><span class="number">0</span><span class="midword">])</span>;
            <span class="keyword">return</span> <span class="number">1</span>;
        <span class="midword">}</span>
        <span class="keyword">else if</span><span class="midword">(</span>!strcmp<span class="midword">(</span>argv<span class="midword">[</span>x<span class="midword">]</span>, <span class="string">"--version"</span><span class="midword">)</span> || !strcmp<span class="midword">(</span>argv<span class="midword">[</span>x<span class="midword">]</span>, <span class="string">"-v"</span><span class="midword">)) {</span>
            print_version<span class="midword">()</span>;
            <span class="keyword">return</span> <span class="number">1</span>;
        <span class="midword">}</span>
    <span class="midword">}</span>

    <span class="keyword">return</span> <span class="number">0</span>;
<span class="midword">}</span>

<span class="commentdoc">/*! Prints codeform's usage to the screen.
    \param progname The executable path of codeform (argv[0] in main()).
*/</span>
<span class="keyword">void</span> print_usage<span class="midword">(</span><span class="keyword">const char</span> <span class="midwordlight">*</span>progname<span class="midword">) {</span>
    fprintf<span class="midword">(</span>stderr, <span class="string">"\n"</span> VERSION
        <span class="string">"\nExecutable path: %s\n"</span>
        <span class="string">"\nusage: codeform [-f rule-file] [-e inline-rule] [-o output]"</span>
        <span class="string">"\n                [--help] [-h] [--usage] [--version] [-v]"</span>
        <span class="string">"\n                [--] [rule-file-if-no-other-rules] [files...]\n"</span>
        <span class="string">"\nThe arguments are very similar to sed's (and -o is from GCC).\n"</span>
        <span class="string">"\nOutput can go to multiple files -- just specify more than one -o"</span>
        <span class="string">" argument. With\nno -o arguments (or if none of the output files"</span>
        <span class="string">" could be opened), stdout is\nused instead.\n"</span>, progname<span class="midword">)</span>;
    fprintf<span class="midword">(</span>stderr,  <span class="comment">/* Two fprintf()s to avoid strings over 509 chars long. */</span>
        <span class="string">"\nIf no rules are specified, the first argument that isn't preceded"</span>
        <span class="string">" by an option\nis taken as a rules file instead of an input file."</span>
        <span class="string">" With no input files, stdin\nis used.\n"</span>
        <span class="string">"\nA simple usage of codeform might look like the following:"</span>
        <span class="string">"\n    $ ./codeform -o codeform.htm rules/c_1_html codeform.c"</span>
        <span class="string">"\nThis formats codeform.c according to the rules in rules/c_1_html,"</span>
        <span class="string">" storing the\noutput in codeform.htm.\n"</span><span class="midword">)</span>;
<span class="midword">}</span>

<span class="commentdoc">/*! Prints the version of codeform, including time and date of compilation
    (__TIME__ and __DATE__).
*/</span>
<span class="keyword">void</span> print_version<span class="midword">(</span><span class="keyword">void</span><span class="midword">) {</span>
    fprintf<span class="midword">(</span>stderr, <span class="string">"\n"</span> VERSION <span class="string">" ("</span> __TIME__ <span class="string">" "</span> __DATE__ <span class="string">")"</span>
        <span class="string">"\nCopyright (C) 2007 DWK\n"</span>
        <span class="string">"\nThis is free software; see the source for copying conditions. "</span>
            <span class="string">" There is NO"</span>
        <span class="string">"\nwarranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR"</span>
            <span class="string">" PURPOSE,"</span>
        <span class="string">"\nto the extent permitted by law.\n"</span>
        <span class="string">"\nSee the file history that comes with the distribution for a"</span>
        <span class="string">" complete history\nlist of versions of codeform.\n"</span><span class="midword">)</span>;
<span class="midword">}</span>

<span class="commentdoc">/*! Prints an error and exits due to an out-of-memory condition.
    \param file The file in which the condition occured (__FILE__).
    \param line The line at which the condition occured (__LINE__).
*/</span>
<span class="keyword">void</span> out_of_memory<span class="midword">(</span><span class="keyword">const char</span> <span class="midwordlight">*</span>file, <span class="keyword">int</span> line<span class="midword">) {</span>
    fprintf<span class="midword">(</span>stderr, <span class="string">"codeform: (%s:%i): Out of memory\n"</span>, file, line<span class="midword">)</span>;
    exit<span class="midword">(</span><span class="number">1</span><span class="midword">)</span>;
<span class="midword">}</span>

<span class="commentdoc">/*! Frees the memory allocated in a ruledata_t structure. Frees data only once,
    even if two rules reference the same memory.
    \param ruledata The ruledata_t structure to free the contents of.
*/</span>
<span class="keyword">void</span> free_ruledata<span class="midword">(</span><span class="keyword">const struct</span> ruledata_t <span class="midwordlight">*</span>ruledata<span class="midword">) {</span>
    <span class="keyworddark">size_t</span> x;

    <span class="keyword">for</span><span class="midword">(</span>x = <span class="number">0</span>; x &lt; ruledata-&gt;number; x ++<span class="midword">) {</span>
        free_onerule<span class="midword">(</span>ruledata, x<span class="midword">)</span>;

        free<span class="midword">(</span>ruledata-&gt;data<span class="midword">[</span>x<span class="midword">])</span>;
    <span class="midword">}</span>

    free<span class="midword">(</span>ruledata-&gt;data<span class="midword">)</span>;
<span class="midword">}</span>

<span class="commentdoc">/*! Frees the memory allocated for the cdat[] array of rules in \a rules.
    \param rules The structure containing the array of rules to free.
*/</span>
<span class="keyword">void</span> free_rulecdat<span class="midword">(</span><span class="keyword">const struct</span> rules_t <span class="midwordlight">*</span>rules<span class="midword">) {</span>
    <span class="keyword">enum</span> type_t x;
    <span class="keyworddark">size_t</span> y;

    <span class="keyword">for</span><span class="midword">(</span>x = <span class="number">0</span>; x &lt; TYPES; x ++<span class="midword">) {</span>
        <span class="keyword">if</span><span class="midword">(</span>rules-&gt;cdat<span class="midword">[</span>x<span class="midword">]) {</span>
            <span class="keyword">for</span><span class="midword">(</span>y = <span class="number">0</span>; y &lt; rules-&gt;cdat<span class="midword">[</span>x<span class="midword">]</span>-&gt;data.number; y ++<span class="midword">) {</span>
                free<span class="midword">(</span>rules-&gt;cdat<span class="midword">[</span>x<span class="midword">]</span>-&gt;data.data<span class="midword">[</span>y<span class="midword">])</span>;
            <span class="midword">}</span>

            free<span class="midword">(</span>rules-&gt;cdat<span class="midword">[</span>x<span class="midword">]</span>-&gt;data.data<span class="midword">)</span>;
            free<span class="midword">(</span>rules-&gt;cdat<span class="midword">[</span>x<span class="midword">]</span>-&gt;data.len<span class="midword">)</span>;
            free<span class="midword">(</span>rules-&gt;cdat<span class="midword">[</span>x<span class="midword">])</span>;
        <span class="midword">}</span>
    <span class="midword">}</span>
<span class="midword">}</span>

<span class="commentdoc">/*! Frees the allocated memory for a strings_t structure contained in a
    one_rule structure. Sets any pointers in \a ruledata to the same memory to
    NULL.
    \param ruledata The structure containing structures with allocated memory.
    \param which The strings_t structure to free the contents of.
*/</span>
<span class="keyword">void</span> free_onerule<span class="midword">(</span><span class="keyword">const struct</span> ruledata_t <span class="midwordlight">*</span>ruledata, <span class="keyworddark">size_t</span> which<span class="midword">) {</span>
    <span class="keyworddark">size_t</span> x, y;

    <span class="keyword">for</span><span class="midword">(</span>x = <span class="number">0</span>; x &lt; ruledata-&gt;data<span class="midword">[</span>which<span class="midword">]</span>-&gt;data.number; x ++<span class="midword">) {</span>
        <span class="keyword">if</span><span class="midword">(</span>ruledata-&gt;data<span class="midword">[</span>which<span class="midword">]</span>-&gt;data.data<span class="midword">[</span>x<span class="midword">]) {</span>
            <span class="keyword">for</span><span class="midword">(</span>y = which + <span class="number">1</span>; y &lt; ruledata-&gt;number; y ++<span class="midword">) {</span>
                <span class="keyword">if</span><span class="midword">(</span>y != which <span class="midwordlight">&amp;&amp;</span> x &lt; ruledata-&gt;data<span class="midword">[</span>y<span class="midword">]</span>-&gt;data.number  <span class="comment">/* !!!?*/</span>
                    <span class="midwordlight">&amp;&amp;</span> ruledata-&gt;data<span class="midword">[</span>which<span class="midword">]</span>-&gt;data.data<span class="midword">[</span>x<span class="midword">]</span>
                    == ruledata-&gt;data<span class="midword">[</span>y<span class="midword">]</span>-&gt;data.data<span class="midword">[</span>x<span class="midword">]) {</span>

                    ruledata-&gt;data<span class="midword">[</span>y<span class="midword">]</span>-&gt;data.data<span class="midword">[</span>x<span class="midword">]</span> = <span class="number">0</span>;
                <span class="midword">}</span>
            <span class="midword">}</span>

            free<span class="midword">(</span>ruledata-&gt;data<span class="midword">[</span>which<span class="midword">]</span>-&gt;data.data<span class="midword">[</span>x<span class="midword">])</span>;
        <span class="midword">}</span>
    <span class="midword">}</span>

    free<span class="midword">(</span>ruledata-&gt;data<span class="midword">[</span>which<span class="midword">]</span>-&gt;data.data<span class="midword">)</span>;
    free<span class="midword">(</span>ruledata-&gt;data<span class="midword">[</span>which<span class="midword">]</span>-&gt;data.len<span class="midword">)</span>;
<span class="midword">}</span>

<span class="commentdoc">/*! Frees the memory allocated for a strings_t structure. All members are freed
    except for the structure itself and non-pointer members.
    \param strings The strings_t structure to free allocated memory from.
*/</span>
<span class="keyword">void</span> free_strings<span class="midword">(</span><span class="keyword">const struct</span> strings_t <span class="midwordlight">*</span>strings<span class="midword">) {</span>
    <span class="keyworddark">size_t</span> x;

    <span class="keyword">for</span><span class="midword">(</span>x = <span class="number">0</span>; x &lt; strings-&gt;number; x ++<span class="midword">) {</span>
        free<span class="midword">(</span>strings-&gt;data<span class="midword">[</span>x<span class="midword">])</span>;
    <span class="midword">}</span>

    free<span class="midword">(</span>strings-&gt;data<span class="midword">)</span>;
    free<span class="midword">(</span>strings-&gt;len<span class="midword">)</span>;
<span class="midword">}</span>

<span class="commentdoc">/*! Frees the rule \a rule and its parts that are not present in \a prev.
    \param rule The structure to free, including all non-duplicate parts.
    \param prev The structure containing parts that could possibly be
        duplicates of \a rule's parts.
*/</span>
<span class="keyword">void</span> free_dup_onerule<span class="midword">(</span><span class="keyword">struct</span> onerule_t <span class="midwordlight">*</span>rule, <span class="keyword">const struct</span> onerule_t <span class="midwordlight">*</span>prev<span class="midword">) {</span>
    <span class="keyworddark">size_t</span> x;

    <span class="keyword">for</span><span class="midword">(</span>x = <span class="number">0</span>; x &lt; rule-&gt;data.number; x ++<span class="midword">) {</span>
        <span class="keyword">if</span><span class="midword">(</span>!prev || x &gt;= prev-&gt;data.number
            || rule-&gt;data.data<span class="midword">[</span>x<span class="midword">]</span> != prev-&gt;data.data<span class="midword">[</span>x<span class="midword">]) {</span>

            free<span class="midword">(</span>rule-&gt;data.data<span class="midword">[</span>x<span class="midword">])</span>;
        <span class="midword">}</span>
    <span class="midword">}</span>

    free<span class="midword">(</span>rule-&gt;data.data<span class="midword">)</span>;
    free<span class="midword">(</span>rule-&gt;data.len<span class="midword">)</span>;
    free<span class="midword">(</span>rule<span class="midword">)</span>;
<span class="midword">}</span>

<span class="commentdoc">/*! Frees the memory allocated in a rulevars_t structure.
    \param rulevars The rulevars_t structure to free the contents of.
*/</span>
<span class="keyword">void</span> free_rulevars<span class="midword">(</span><span class="keyword">const struct</span> rulevars_t <span class="midwordlight">*</span>rulevars<span class="midword">) {</span>
    <span class="keyworddark">size_t</span> x;

    <span class="keyword">for</span><span class="midword">(</span>x = <span class="number">0</span>; x &lt; rulevars-&gt;number; x ++<span class="midword">) {</span>
        free_onevar<span class="midword">(</span>rulevars-&gt;data<span class="midword">[</span>x<span class="midword">])</span>;

        free<span class="midword">(</span>rulevars-&gt;data<span class="midword">[</span>x<span class="midword">])</span>;
    <span class="midword">}</span>

    free<span class="midword">(</span>rulevars-&gt;data<span class="midword">)</span>;
<span class="midword">}</span>

<span class="commentdoc">/*! Frees the memory allocated for a onevar_t structure.
    \param var The structure to free the contents of.
*/</span>
<span class="keyword">void</span> free_onevar<span class="midword">(</span><span class="keyword">const struct</span> onevar_t <span class="midwordlight">*</span>var<span class="midword">) {</span>
    free<span class="midword">(</span>var-&gt;from<span class="midword">)</span>;
    free<span class="midword">(</span>var-&gt;to<span class="midword">)</span>;
<span class="midword">}</span>

<span class="commentdoc">/*! Frees the memory allocated while parsing command-line arguments:
    the input, output, and rules file names and any inline rules.
    \param argument The structure containing the comment-line data to free.
*/</span>
<span class="keyword">void</span> free_argument<span class="midword">(</span><span class="keyword">const struct</span> argument_t <span class="midwordlight">*</span>argument<span class="midword">) {</span>
    free_strings<span class="midword">(</span><span class="midwordlight">&amp;</span>argument-&gt;inputfn<span class="midword">)</span>;
    free_strings<span class="midword">(</span><span class="midwordlight">&amp;</span>argument-&gt;outputfn<span class="midword">)</span>;
    free_strings<span class="midword">(</span><span class="midwordlight">&amp;</span>argument-&gt;rulefn<span class="midword">)</span>;
    free_strings<span class="midword">(</span><span class="midwordlight">&amp;</span>argument-&gt;ilrule<span class="midword">)</span>;
<span class="midword">}</span>

<span class="commentdoc">/*! Frees the rule pointed to in the \c prevrule_t structure by the member
    \c prev if it is the only pointer to the allocated memory.
    \param pr The \c prevrule_t structure containing a pointer to the previous
        rule parsed.
*/</span>
<span class="keyword">void</span> free_prevrule<span class="midword">(</span><span class="keyword">struct</span> prevrule_t <span class="midwordlight">*</span>pr<span class="midword">) {</span>
    <span class="keyword">if</span><span class="midword">(</span>pr-&gt;freep<span class="midword">) {</span>
        free_dup_onerule<span class="midword">(</span>pr-&gt;prev, pr-&gt;one<span class="midword">)</span>;
    <span class="midword">}</span>
<span class="midword">}</span>

<span class="commentdoc">/*! Opens the file \a fn in mode \a mode, returning the file pointer on success
    or NULL on error. Prints an error message on error before returning.
    \param fn The name of the file to open.
    \param mode The mode to open the file in.
    \return The newly opened file, or NULL on error.
*/</span>
<span class="keyworddark">FILE</span> <span class="midwordlight">*</span>open_file<span class="midword">(</span><span class="keyword">const char</span> <span class="midwordlight">*</span>fn, <span class="keyword">const char</span> <span class="midwordlight">*</span>mode<span class="midword">) {</span>
    <span class="keyworddark">FILE</span> <span class="midwordlight">*</span>fp;

    <span class="keyword">if</span><span class="midword">(</span>!strcmp<span class="midword">(</span>fn, <span class="string">"-"</span><span class="midword">)) {</span>
        <span class="keyword">return</span> strchr<span class="midword">(</span>mode, <span class="string">'r'</span><span class="midword">)</span> ? stdin : stdout;
    <span class="midword">}</span>

    <span class="keyword">if</span><span class="midword">(</span>!<span class="midword">(</span>fp = fopen<span class="midword">(</span>fn, mode<span class="midword">))) {</span>
        fprintf<span class="midword">(</span>stderr, <span class="string">"codeform: Can't open file \"%s\" for mode \"%s\"\n"</span>,
            fn, mode<span class="midword">)</span>;
    <span class="midword">}</span>

    <span class="keyword">return</span> fp;
<span class="midword">}</span>

<span class="commentdoc">/*! A dynamic-memory allocating clone of fgets(). Reads characters from fp,
    storing them in \a line starting with (*line)[len].
    \param line The resizeable string to store characters in.
    \param len The position in \a line to start storing characters at.
    \param alen The amount of memory currently allocated (multiple of BUFSIZ).
    \param fp The file to read the characters from.
    \return The new length of the string (\a len modified). It will be the same
    as \a len if no characters were read before EOF was encountered.
*/</span>
<span class="keyworddark">size_t</span> get_string<span class="midword">(</span><span class="keyword">char</span> <span class="midwordlight">**</span>line, <span class="keyworddark">size_t</span> len, <span class="keyworddark">size_t</span> <span class="midwordlight">*</span>alen, <span class="keyworddark">FILE</span> <span class="midwordlight">*</span>fp<span class="midword">) {</span>
    <span class="keyword">char</span> <span class="midwordlight">*</span>p;
    <span class="keyword">int</span> c = <span class="number">0</span>;

    <span class="keyword">do</span> <span class="midword">{</span>
        <span class="keyword">if</span><span class="midword">(</span>c == <span class="string">'\n'</span><span class="midword">)</span> c = <span class="number">0</span>;
        <span class="keyword">else</span> c = getc<span class="midword">(</span>fp<span class="midword">)</span>;

        <span class="keyword">if</span><span class="midword">(</span>c == EOF<span class="midword">) {</span>
            c = <span class="number">0</span>;
        <span class="midword">}</span>

        <span class="keyword">if</span><span class="midword">(</span>len &gt;= <span class="midwordlight">*</span>alen<span class="midword">) {</span>
            <span class="keyword">if</span><span class="midword">(</span><span class="midwordlight">*</span>alen<span class="midword">)</span> <span class="midwordlight">*</span>alen <span class="midwordlight">*</span>= <span class="number">2</span>;
            <span class="keyword">else</span> <span class="midwordlight">*</span>alen = BUFSIZ;

            p = realloc<span class="midword">(</span><span class="midwordlight">*</span>line, <span class="midwordlight">*</span>alen<span class="midword">)</span>;

            <span class="keyword">if</span><span class="midword">(</span>!p<span class="midword">)</span> out_of_memory<span class="midword">(</span>__FILE__, __LINE__<span class="midword">)</span>;

            <span class="midwordlight">*</span>line = p;
        <span class="midword">}</span>

        <span class="midword">(</span><span class="midwordlight">*</span>line<span class="midword">)[</span>len++<span class="midword">]</span> = c;
    <span class="midword">}</span> <span class="keyword">while</span><span class="midword">(</span>c<span class="midword">)</span>;

    <span class="keyword">return</span> len - <span class="number">1</span>;
<span class="midword">}</span>

<span class="commentdoc">/*! Loads all the rules files in \a rulefn by calling add_rules_file() for each
    one. Stores the rules read into \a rules.
    \param rules The structure to store all the rules read in into.
    \param rulefn The names of rules files to parse.
*/</span>
<span class="keyword">void</span> load_rules<span class="midword">(</span><span class="keyword">struct</span> rules_t <span class="midwordlight">*</span>rules, <span class="keyword">const struct</span> strings_t <span class="midwordlight">*</span>rulefn<span class="midword">) {</span>
    <span class="keyworddark">size_t</span> x;

    <span class="keyword">for</span><span class="midword">(</span>x = <span class="number">0</span>; x &lt; rulefn-&gt;number; x ++<span class="midword">) {</span>
        add_rules_file<span class="midword">(</span>rules, rulefn-&gt;data<span class="midword">[</span>x<span class="midword">])</span>;
    <span class="midword">}</span>
<span class="midword">}</span>

<span class="commentdoc">/*! Adds the inline rules in \c ilrule to \c rules by calling add_rule_var()
    for each rule.
    \param rules The structure to add the rules to.
    \param ilrule The inline rules to add.
*/</span>
<span class="keyword">void</span> add_ilrules<span class="midword">(</span><span class="keyword">struct</span> rules_t <span class="midwordlight">*</span>rules, <span class="keyword">const struct</span> strings_t <span class="midwordlight">*</span>ilrule<span class="midword">) {</span>
    <span class="keyworddark">size_t</span> x;

    <span class="keyword">for</span><span class="midword">(</span>x = <span class="number">0</span>; x &lt; ilrule-&gt;number; x ++<span class="midword">) {</span>
        add_rule_var<span class="midword">(</span>rules, ilrule-&gt;data<span class="midword">[</span>x<span class="midword">]</span>, NULL, x + <span class="number">1</span><span class="midword">)</span>;
    <span class="midword">}</span>
<span class="midword">}</span>

<span class="commentdoc">/*! Sources a rules file, prepending the location of the containing rules file
    if it does not start with "./" or ".\\".
    \param rules The rules read from rules files so far.
    \param fn The name of the rules file to read.
    \param dir The name of the containing rules file to extract the path from.
*/</span>
<span class="keyword">void</span> add_rules_file_dir<span class="midword">(</span><span class="keyword">struct</span> rules_t <span class="midwordlight">*</span>rules, <span class="keyword">const char</span> <span class="midwordlight">*</span>fn,
    <span class="keyword">const char</span> <span class="midwordlight">*</span>dir<span class="midword">) {</span>

    <span class="keyword">char</span> <span class="midwordlight">*</span>last = strrchr<span class="midword">(</span>dir, <span class="string">'/'</span><span class="midword">)</span>, <span class="midwordlight">*</span>p = strrchr<span class="midword">(</span>dir, <span class="string">'\\'</span><span class="midword">)</span>;

    <span class="keyword">if</span><span class="midword">(</span>p &gt; last<span class="midword">)</span> last = p;

    <span class="keyword">if</span><span class="midword">(</span>fn <span class="midwordlight">&amp;&amp;</span> !is_current_dir<span class="midword">(</span>fn<span class="midword">)</span> <span class="midwordlight">&amp;&amp;</span> last ++<span class="midword">) {</span>
        p = malloc<span class="midword">(</span>strlen<span class="midword">(</span>fn<span class="midword">)</span> + last - dir + <span class="number">1</span><span class="midword">)</span>;
        <span class="keyword">if</span><span class="midword">(</span>!p<span class="midword">)</span> out_of_memory<span class="midword">(</span>__FILE__, __LINE__<span class="midword">)</span>;

        strncpy<span class="midword">(</span>p, dir, last - dir<span class="midword">)</span>;
        strcpy<span class="midword">(</span>p + <span class="midword">(</span>last - dir<span class="midword">)</span>, fn<span class="midword">)</span>;

        add_rules_file<span class="midword">(</span>rules, p<span class="midword">)</span>;

        free<span class="midword">(</span>p<span class="midword">)</span>;
    <span class="midword">}</span>
    <span class="keyword">else</span> add_rules_file<span class="midword">(</span>rules, fn<span class="midword">)</span>;
<span class="midword">}</span>

<span class="commentdoc">/*! Reads the file \a fn, passing each rule to add_rule_var() for parsing.
    \param rules The rules that have already been parsed, to add new rules to.
    \param fn The name of the file containing the new rules.
*/</span>
<span class="keyword">void</span> add_rules_file<span class="midword">(</span><span class="keyword">struct</span> rules_t <span class="midwordlight">*</span>rules, <span class="keyword">const char</span> <span class="midwordlight">*</span>fn<span class="midword">) {</span>
    <span class="keyworddark">FILE</span> <span class="midwordlight">*</span>fp = open_file<span class="midword">(</span>fn, <span class="string">"r"</span><span class="midword">)</span>;
    <span class="keyword">char</span> <span class="midwordlight">*</span>str = <span class="number">0</span>;
    <span class="keyword">int</span> line = <span class="number">0</span>, isb;
    <span class="keyworddark">size_t</span> tlen, len, flen = <span class="number">0</span>, alen = <span class="number">0</span>;

    <span class="keyword">if</span><span class="midword">(</span>!fp<span class="midword">)</span> <span class="keyword">return</span>;

    <span class="keyword">do</span> <span class="midword">{</span>
        len = <span class="number">0</span>;

        isb = <span class="number">1</span>;
        <span class="keyword">while</span><span class="midword">(</span>isb <span class="midwordlight">&amp;&amp;</span> <span class="midword">(</span>tlen = get_string<span class="midword">(</span><span class="midwordlight">&amp;</span>str, len, <span class="midwordlight">&amp;</span>alen, fp<span class="midword">))</span> != len<span class="midword">) {</span>
            flen = tlen;

            chomp_newline<span class="midword">(</span>str, <span class="midwordlight">&amp;</span>flen<span class="midword">)</span>;

            isb = is_backslashed<span class="midword">(</span>str+len, str+flen<span class="midword">)</span>;

            len = flen;
            line ++;

            <span class="keyword">if</span><span class="midword">(</span>len <span class="midwordlight">&amp;&amp;</span> str<span class="midword">[</span>len-<span class="number">1</span><span class="midword">]</span> == <span class="string">'\\'</span><span class="midword">)</span> str<span class="midword">[</span>--len<span class="midword">]</span> = <span class="number">0</span>;
        <span class="midword">}</span>

        add_rule_var<span class="midword">(</span>rules, str, fn, line<span class="midword">)</span>;
    <span class="midword">}</span> <span class="keyword">while</span><span class="midword">(</span>tlen != len<span class="midword">)</span>;

    <span class="keyword">if</span><span class="midword">(</span>fp != stdin<span class="midword">)</span> fclose<span class="midword">(</span>fp<span class="midword">)</span>;

    free<span class="midword">(</span>str<span class="midword">)</span>;
<span class="midword">}</span>

<span class="commentdoc">/*! Adds a rule/variable specified by \c str into \c rules.
    \param rules The structure to add the variable/rule to.
    \param str The string representing the rule/variable.
    \param file The file that the string \c str came from.
    \param line The line of the file \c file from which \c str came.
*/</span>
<span class="keyword">void</span> add_rule_var<span class="midword">(</span><span class="keyword">struct</span> rules_t <span class="midwordlight">*</span>rules, <span class="keyword">char</span> <span class="midwordlight">*</span>str, <span class="keyword">const char</span> <span class="midwordlight">*</span>file,
    <span class="keyword">int</span> line<span class="midword">) {</span>

    <span class="keyword">char</span> <span class="midwordlight">*</span>p;

    remove_comments<span class="midword">(</span>str<span class="midword">)</span>;

    <span class="keyword">if</span><span class="midword">(</span><span class="midwordlight">*</span>str == <span class="string">'.'</span><span class="midword">) {</span>
        <span class="keyword">if</span><span class="midword">(</span>file <span class="midwordlight">&amp;&amp;</span> !strcmp<span class="midword">(</span>file, str+<span class="number">1</span><span class="midword">)) {</span>
            fprintf<span class="midword">(</span>stderr, <span class="string">"codeform: Error in rule (%s:%i):"</span>
                <span class="string">" Recursive sourcing: \"%s\"\n"</span>,
                file ? file : <span class="string">"-e"</span>, line, str<span class="midword">)</span>;
        <span class="midword">}</span>
        <span class="keyword">else</span> <span class="midword">{</span>
            <span class="keyword">if</span><span class="midword">(</span>file <span class="midwordlight">&amp;&amp;</span> !strchr<span class="midword">(</span>str+<span class="number">1</span>, <span class="string">'/'</span><span class="midword">)</span> <span class="midwordlight">&amp;&amp;</span> !strchr<span class="midword">(</span>str+<span class="number">1</span>, <span class="string">'\\'</span><span class="midword">)) {</span>
                add_rules_file_dir<span class="midword">(</span>rules, str+<span class="number">1</span>, file<span class="midword">)</span>;
            <span class="midword">}</span>
            <span class="keyword">else</span> add_rules_file<span class="midword">(</span>rules, str+<span class="number">1</span><span class="midword">)</span>;
        <span class="midword">}</span>
    <span class="midword">}</span>
    <span class="keyword">else if</span><span class="midword">((</span>p = is_var<span class="midword">(</span>str<span class="midword">)))</span> add_var<span class="midword">(</span><span class="midwordlight">&amp;</span>rules-&gt;vars, str, p<span class="midword">)</span>;
    <span class="keyword">else if</span><span class="midword">(</span><span class="midwordlight">*</span>str<span class="midword">)</span> add_rule<span class="midword">(</span>rules, str, file, line<span class="midword">)</span>;
<span class="midword">}</span>

<span class="commentdoc">/*! Adds a variable to the list of variables. The variable starts with \a str,
    and the position of the '=' is at \a eq.
    \param vars The structure of variables to store the new variable in.
    \param str The string representing the variable.
    \param eq The position in string of the '=' sign separating the name of the
        variable from the variable's value.
*/</span>
<span class="keyword">void</span> add_var<span class="midword">(</span><span class="keyword">struct</span> rulevars_t <span class="midwordlight">*</span>vars, <span class="keyword">char</span> <span class="midwordlight">*</span>str, <span class="keyword">char</span> <span class="midwordlight">*</span>eq<span class="midword">) {</span>
    <span class="keyword">struct</span> onevar_t <span class="midwordlight">**</span>p;
    <span class="keyworddark">size_t</span> eqlen = strlen<span class="midword">(</span>eq<span class="midword">)</span>, pos;

    <span class="midwordlight">*</span>eq = <span class="number">0</span>;

    <span class="keyword">if</span><span class="midword">(</span>find_var_pos<span class="midword">(</span>vars, str, <span class="midwordlight">&amp;</span>pos<span class="midword">))</span> <span class="keyword">return</span>;
    <span class="keyword">if</span><span class="midword">(</span>pos == <span class="midword">(</span><span class="keyworddark">size_t</span><span class="midword">)</span>-<span class="number">1</span><span class="midword">)</span> pos = <span class="number">0</span>;

    p = realloc<span class="midword">(</span>vars-&gt;data, <span class="midword">(</span>vars-&gt;number + <span class="number">1</span><span class="midword">)</span> <span class="midwordlight">*</span> <span class="keyword">sizeof</span><span class="midword">(</span><span class="keyword">struct</span> onevar_t <span class="midwordlight">*</span><span class="midword">))</span>;

    <span class="keyword">if</span><span class="midword">(</span>!p<span class="midword">)</span> out_of_memory<span class="midword">(</span>__FILE__, __LINE__<span class="midword">)</span>;

    vars-&gt;data = p;

    memmove<span class="midword">(</span>vars-&gt;data + pos + <span class="number">1</span>, vars-&gt;data + pos,
        <span class="midword">(</span>vars-&gt;number - pos<span class="midword">)</span> <span class="midwordlight">*</span> <span class="keyword">sizeof</span><span class="midword">(</span><span class="keyword">struct</span> onevar_t <span class="midwordlight">*</span><span class="midword">))</span>;

    vars-&gt;data<span class="midword">[</span>pos<span class="midword">]</span> = malloc<span class="midword">(</span><span class="keyword">sizeof</span><span class="midword">(</span><span class="keyword">struct</span> onevar_t<span class="midword">))</span>;
    <span class="keyword">if</span><span class="midword">(</span>!vars-&gt;data<span class="midword">[</span>pos<span class="midword">])</span> out_of_memory<span class="midword">(</span>__FILE__, __LINE__<span class="midword">)</span>;

    vars-&gt;data<span class="midword">[</span>pos<span class="midword">]</span>-&gt;from = malloc<span class="midword">(</span>eq - str + <span class="number">1</span><span class="midword">)</span>;
    <span class="keyword">if</span><span class="midword">(</span>!vars-&gt;data<span class="midword">[</span>pos<span class="midword">]</span>-&gt;from<span class="midword">)</span> out_of_memory<span class="midword">(</span>__FILE__, __LINE__<span class="midword">)</span>;
    <span class="comment">/*strncpy(vars-&gt;data[pos]-&gt;from, str, eq - str);*/</span>
    strcpy<span class="midword">(</span>vars-&gt;data<span class="midword">[</span>pos<span class="midword">]</span>-&gt;from, str<span class="midword">)</span>;  <span class="comment">/* will not overflow */</span>
    <span class="comment">/*vars-&gt;data[pos]-&gt;from[eq - str] = 0;*/</span>
    vars-&gt;data<span class="midword">[</span>pos<span class="midword">]</span>-&gt;flen = eq - str;

    vars-&gt;data<span class="midword">[</span>pos<span class="midword">]</span>-&gt;to = malloc<span class="midword">(</span>eqlen<span class="midword">)</span>;
    <span class="keyword">if</span><span class="midword">(</span>!vars-&gt;data<span class="midword">[</span>pos<span class="midword">]</span>-&gt;to<span class="midword">)</span> out_of_memory<span class="midword">(</span>__FILE__, __LINE__<span class="midword">)</span>;
    strcpy<span class="midword">(</span>vars-&gt;data<span class="midword">[</span>pos<span class="midword">]</span>-&gt;to, eq+<span class="number">1</span><span class="midword">)</span>;
    vars-&gt;data<span class="midword">[</span>pos<span class="midword">]</span>-&gt;tlen = eqlen - <span class="number">1</span>;

    vars-&gt;number ++;
<span class="midword">}</span>

<span class="commentdoc">/*! Binary searches through the existing variables in \a rt for the position
    that the variable \a p should be in, putting the result in \a pos.
    \param vars The existing variables to search through.
    \param p The text representing the new variable to search for.
    \param pos The variable to store the position found in. Set to (size_t)-1
        if no match was found.
    \return 1 if an exact match (to the shortest length) was found, 0
        otherwise.
*/</span>
<span class="keyword">int</span> find_var_pos<span class="midword">(</span><span class="keyword">struct</span> rulevars_t <span class="midwordlight">*</span>vars, <span class="keyword">const char</span> <span class="midwordlight">*</span>p, <span class="keyworddark">size_t</span> <span class="midwordlight">*</span>pos<span class="midword">) {</span>
    <span class="keyworddark">size_t</span> mid = <span class="midword">(</span><span class="keyworddark">size_t</span><span class="midword">)</span>-<span class="number">1</span>, first = <span class="number">0</span>, last = vars-&gt;number-<span class="number">1</span>;
    <span class="keyword">int</span> v = <span class="number">0</span>;

    <span class="midwordlight">*</span>pos = <span class="midword">(</span><span class="keyworddark">size_t</span><span class="midword">)</span>-<span class="number">1</span>;

    <span class="keyword">if</span><span class="midword">(</span>!vars-&gt;number<span class="midword">)</span> <span class="keyword">return</span> <span class="number">0</span>;

    <span class="keyword">while</span><span class="midword">(</span>first &lt;= last <span class="midwordlight">&amp;&amp;</span> last != <span class="midword">(</span><span class="keyworddark">size_t</span><span class="midword">)</span>-<span class="number">1</span><span class="midword">) {</span>
        mid = <span class="midword">(</span>first + last<span class="midword">)</span> / <span class="number">2</span>;

        v = strcmp<span class="midword">(</span>p, vars-&gt;data<span class="midword">[</span>mid<span class="midword">]</span>-&gt;from<span class="midword">)</span>;

        <span class="keyword">if</span><span class="midword">(</span>first == last <span class="midwordlight">&amp;&amp;</span> v<span class="midword">)</span> <span class="keyword">break</span>;

        <span class="keyword">if</span><span class="midword">(</span>v &lt; <span class="number">0</span><span class="midword">)</span> last = mid-<span class="number">1</span>;
        <span class="keyword">else if</span><span class="midword">(</span>v &gt; <span class="number">0</span><span class="midword">)</span> first = mid+<span class="number">1</span>;
        <span class="keyword">else</span> <span class="midword">{</span>
            <span class="midwordlight">*</span>pos = mid;
            first = mid+<span class="number">1</span>;
        <span class="midword">}</span>
    <span class="midword">}</span>

    <span class="keyword">if</span><span class="midword">(</span><span class="midwordlight">*</span>pos != <span class="midword">(</span><span class="keyworddark">size_t</span><span class="midword">)</span>-<span class="number">1</span><span class="midword">)</span> <span class="keyword">return</span> <span class="number">1</span>;

    <span class="keyword">if</span><span class="midword">(</span>v &lt; <span class="number">0</span><span class="midword">)</span> <span class="midwordlight">*</span>pos = mid;
    <span class="keyword">else</span> <span class="midwordlight">*</span>pos = mid+<span class="number">1</span>;

    <span class="keyword">return</span> <span class="number">0</span>;
<span class="midword">}</span>

<span class="commentdoc">/*! Called by add_rule() to determine the type of the rule \a str.
    \param rules The array of rules that have been parsed so far.
    \param t The pointer to store the type of the current rule.
    \param str The rule itself.
    \param file The file which the rule \a str came from.
    \param line The line of the file from which the rule came.
    \return 0 if no errors occured and str is an ordinary rule; nonzero if the
        rule is a header, an invalid header, or not under a header. If \a str
        is an inline header, positions \a str past the header and returns 0 so
        that \a str may be treated as an ordinary rule.
*/</span>
<span class="keyword">int</span> add_rule_type<span class="midword">(</span><span class="keyword">struct</span> rules_t <span class="midwordlight">*</span>rules, <span class="keyword">enum</span> type_t <span class="midwordlight">*</span>t, <span class="keyword">char</span> <span class="midwordlight">**</span>str,
    <span class="keyword">const char</span> <span class="midwordlight">*</span>file, <span class="keyword">int</span> line<span class="midword">) {</span>

    <span class="keyworddark">size_t</span> v = get_type<span class="midword">(</span>rules, <span class="midwordlight">*</span>str, t<span class="midword">)</span>;

    <span class="keyword">if</span><span class="midword">(</span>!v<span class="midword">) {</span>
        <span class="keyword">if</span><span class="midword">(</span>rules-&gt;pr.type == TYPE_ERROR<span class="midword">) {</span>
            fprintf<span class="midword">(</span>stderr, <span class="string">"codeform: Error in rule (%s:%i):"</span>
                <span class="string">" Rule not under a header: \"%s\"\n"</span>,
                file ? file : <span class="string">"-e"</span>, line, <span class="midwordlight">*</span>str<span class="midword">)</span>;
            <span class="keyword">return</span> <span class="number">1</span>;
        <span class="midword">}</span>
        <span class="keyword">else</span> <span class="midword">{</span>
            <span class="midwordlight">*</span>t = rules-&gt;pr.type;
        <span class="midword">}</span>
    <span class="midword">}</span>
    <span class="keyword">else if</span><span class="midword">(</span>v == <span class="midword">(</span><span class="keyworddark">size_t</span><span class="midword">)</span>-<span class="number">1</span><span class="midword">) {</span>
        rules-&gt;pr.type = TYPE_ERROR;
        fprintf<span class="midword">(</span>stderr, <span class="string">"codeform: Error in rule (%s:%i):"</span>
            <span class="string">" Invalid header: \"%s\"\n"</span>,
            file ? file : <span class="string">"-e"</span>, line, <span class="midwordlight">*</span>str<span class="midword">)</span>;
        <span class="keyword">return</span> <span class="number">1</span>;
    <span class="midword">}</span>
    <span class="keyword">else</span> <span class="midword">{</span>
        rules-&gt;pr.type = <span class="midwordlight">*</span>t;

        <span class="keyword">if</span><span class="midword">(</span>v != <span class="number">1</span><span class="midword">) {</span>
            <span class="midwordlight">*</span>str += v;
        <span class="midword">}</span>
        <span class="keyword">else return</span> <span class="number">1</span>;
    <span class="midword">}</span>

    <span class="keyword">return</span> <span class="number">0</span>;
<span class="midword">}</span>

<span class="commentdoc">/*! Adds the rule \a one to the correct place, keeping the list of rules
    sorted.
    \param rules The array of rules collected so far.
    \param rsort The index to sort this rule by.
    \param one The rule to add to \a rd.
    \return Same as find_rule_new(): 1 if an exact match was found, 0
        otherwise. 2 if \a one is already an existing rule.
*/</span>
<span class="keyword">int</span> add_rule_pos<span class="midword">(</span><span class="keyword">struct</span> rules_t <span class="midwordlight">*</span>rules, <span class="keyworddark">size_t</span> rsort, <span class="keyword">struct</span> onerule_t <span class="midwordlight">*</span>one<span class="midword">) {</span>
    <span class="keyworddark">size_t</span> sort;
    <span class="keyword">int</span> r;

    r = find_rule_new<span class="midword">(</span>rules, one-&gt;data.data<span class="midword">[</span>rsort<span class="midword">]</span>, <span class="midwordlight">&amp;</span>sort<span class="midword">)</span>;

    <span class="keyword">if</span><span class="midword">(</span>r == <span class="number">2</span><span class="midword">)</span> <span class="keyword">return</span> <span class="number">2</span>;  <span class="comment">/* \a one is already an existing rule. */</span>

    add_rule_new<span class="midword">(</span><span class="midwordlight">&amp;</span>rules-&gt;data<span class="midword">)</span>;

    <span class="keyword">if</span><span class="midword">(</span>r<span class="midword">) {</span>
        <span class="keyword">if</span><span class="midword">(</span>sort+<span class="number">1</span> == rules-&gt;data.number<span class="midword">) {</span>
            rules-&gt;data.data<span class="midword">[</span>rules-&gt;data.number<span class="midword">]</span> = one;
        <span class="midword">}</span>
        <span class="keyword">else</span> <span class="midword">{</span>
            memmove<span class="midword">(</span>rules-&gt;data.data+sort+<span class="number">2</span>, rules-&gt;data.data+sort+<span class="number">1</span>,
                <span class="midword">(</span>rules-&gt;data.number - sort - <span class="number">1</span><span class="midword">)</span> <span class="midwordlight">*</span> <span class="keyword">sizeof</span><span class="midword">(</span><span class="keyword">struct</span> onerule_t <span class="midwordlight">*</span><span class="midword">))</span>;
            rules-&gt;data.data<span class="midword">[</span>sort+<span class="number">1</span><span class="midword">]</span> = one;
        <span class="midword">}</span>
    <span class="midword">}</span>
    <span class="keyword">else</span> <span class="midword">{</span>
        <span class="keyword">if</span><span class="midword">(</span>sort == <span class="midword">(</span><span class="keyworddark">size_t</span><span class="midword">)</span>-<span class="number">1</span><span class="midword">) {</span>
            rules-&gt;data.data<span class="midword">[</span>rules-&gt;data.number<span class="midword">]</span> = one;
        <span class="midword">}</span>
        <span class="keyword">else</span> <span class="midword">{</span>
            memmove<span class="midword">(</span>rules-&gt;data.data+sort+<span class="number">1</span>, rules-&gt;data.data+sort,
                <span class="midword">(</span>rules-&gt;data.number - sort<span class="midword">)</span> <span class="midwordlight">*</span> <span class="keyword">sizeof</span><span class="midword">(</span><span class="keyword">struct</span> onerule_t <span class="midwordlight">*</span><span class="midword">))</span>;
            rules-&gt;data.data<span class="midword">[</span>sort<span class="midword">]</span> = one;
        <span class="midword">}</span>
    <span class="midword">}</span>

    <span class="keyword">return</span> r;
<span class="midword">}</span>

<span class="commentdoc">/*! Allocates a new rule and sets all of its fields to an appropriate value.
    \return The newly allocated and initialized rule.
*/</span>
<span class="keyword">struct</span> onerule_t <span class="midwordlight">*</span>rule_new<span class="midword">(</span><span class="keyword">void</span><span class="midword">) {</span>
    <span class="keyword">struct</span> onerule_t <span class="midwordlight">*</span>one = malloc<span class="midword">(</span><span class="keyword">sizeof</span><span class="midword">(</span><span class="keyword">struct</span> onerule_t<span class="midword">))</span>;
    <span class="keyword">if</span><span class="midword">(</span>!one<span class="midword">)</span> out_of_memory<span class="midword">(</span>__FILE__, __LINE__<span class="midword">)</span>;

    one-&gt;prev = <span class="midword">(</span><span class="keyworddark">size_t</span><span class="midword">)</span>-<span class="number">1</span>;
    one-&gt;data.data = <span class="number">0</span>;
    one-&gt;data.len = <span class="number">0</span>;
    one-&gt;data.number = <span class="number">0</span>;

    <span class="keyword">return</span> one;
<span class="midword">}</span>

<span class="commentdoc">/*! Increments the size of the array of structures in \a rd to accommodate a
    new rule.
    \param rd The current array of rules.
    \return The newly allocated rule.
*/</span>
<span class="keyword">void</span> add_rule_new<span class="midword">(</span><span class="keyword">struct</span> ruledata_t <span class="midwordlight">*</span>rd<span class="midword">) {</span>
    <span class="keyword">struct</span> onerule_t <span class="midwordlight">**</span>p;

    p = realloc<span class="midword">(</span>rd-&gt;data, <span class="midword">(</span>rd-&gt;number + <span class="number">1</span><span class="midword">)</span> <span class="midwordlight">*</span> <span class="keyword">sizeof</span><span class="midword">(</span><span class="keyword">struct</span> onerule_t <span class="midwordlight">*</span><span class="midword">))</span>;

    <span class="keyword">if</span><span class="midword">(</span>!p<span class="midword">)</span> out_of_memory<span class="midword">(</span>__FILE__, __LINE__<span class="midword">)</span>;

    rd-&gt;data = p;
<span class="midword">}</span>

<span class="commentdoc">/*! Adds the rule \a str to the structure \a rules containing the array of
    rules. In doing so, it separates the parts of the rule, extracts variables
    and processes escapes; and does a search on the existing rules to find the
    position of the current one. If the rule is a header it is handled, too.
    \param rules The structure containing the rules parsed so far, to add the
        latest rule \a str to.
    \param str The string representing the rule to add to \a rules.
    \param file The file that the rule \a str came from.
    \param line The line of the file that the rule \a str came from.
*/</span>
<span class="keyword">void</span> add_rule<span class="midword">(</span><span class="keyword">struct</span> rules_t <span class="midwordlight">*</span>rules, <span class="keyword">char</span> <span class="midwordlight">*</span>str, <span class="keyword">const char</span> <span class="midwordlight">*</span>file, <span class="keyword">int</span> line<span class="midword">) {</span>
    <span class="keyword">enum</span> type_t t;
    <span class="keyword">int</span> r;

    <span class="keyword">if</span><span class="midword">(</span>add_rule_type<span class="midword">(</span>rules, <span class="midwordlight">&amp;</span>t, <span class="midwordlight">&amp;</span>str, file, line<span class="midword">))</span> <span class="keyword">return</span>;

    <span class="keyword">if</span><span class="midword">(</span>!check_parts<span class="midword">(</span>rules-&gt;type<span class="midword">[</span>t<span class="midword">]</span>.parts, rules-&gt;type<span class="midword">[</span>t<span class="midword">]</span>.xparts, str<span class="midword">)) {</span>
        fprintf<span class="midword">(</span>stderr, <span class="string">"codeform: Error in rule (%s:%i):"</span>
            <span class="string">" Incorrect number of parts (must be %i-%i): \"%s\"\n"</span>,
            file ? file : <span class="string">"-e"</span>, line, rules-&gt;type<span class="midword">[</span>t<span class="midword">]</span>.parts,
            rules-&gt;type<span class="midword">[</span>t<span class="midword">]</span>.parts + rules-&gt;type<span class="midword">[</span>t<span class="midword">]</span>.xparts, str<span class="midword">)</span>;
        <span class="keyword">return</span>;
    <span class="midword">}</span>

    rules-&gt;pr.one = rule_new<span class="midword">()</span>;

    rules-&gt;pr.one-&gt;type = t;

    add_parts<span class="midword">(</span><span class="midwordlight">&amp;</span>rules-&gt;pr.one-&gt;data,
        rules-&gt;data.number ? <span class="midwordlight">&amp;</span>rules-&gt;pr.prev-&gt;data : <span class="number">0</span>, str<span class="midword">)</span>;
    process_vars<span class="midword">(</span><span class="midwordlight">&amp;</span>rules-&gt;vars, <span class="midwordlight">&amp;</span>rules-&gt;pr.one-&gt;data<span class="midword">)</span>;
    process_escapes<span class="midword">(</span><span class="midwordlight">&amp;</span>rules-&gt;pr.one-&gt;data<span class="midword">)</span>;

    rules-&gt;pr.type = t;

    r = add_allocated_rule<span class="midword">(</span>rules, <span class="midwordlight">&amp;</span>rules-&gt;cdat<span class="midword">[</span>t<span class="midword">]</span>, rules-&gt;type<span class="midword">[</span>t<span class="midword">]</span>.sort<span class="midword">)</span>;

    free_prevrule<span class="midword">(</span><span class="midwordlight">&amp;</span>rules-&gt;pr<span class="midword">)</span>;

    rules-&gt;pr.prev = rules-&gt;pr.one;
    rules-&gt;pr.one = <span class="number">0</span>;

    rules-&gt;pr.freep = r;
<span class="midword">}</span>

<span class="commentdoc">/*! Add a pre-allocated rule to the list of rules, setting \a prev to \a one.
    \param rules The array of existing rules.
    \param cdat The pointer to the cdat structure for \a one's type.
    \param sort The element to sort \a one by.
    \return 1 if everything is taken care of and add_rule() may return. !!!
*/</span>
<span class="keyword">int</span> add_allocated_rule<span class="midword">(</span><span class="keyword">struct</span> rules_t <span class="midwordlight">*</span>rules, <span class="keyword">struct</span> onerule_t <span class="midwordlight">**</span>cdat,
    <span class="keyworddark">size_t</span> sort<span class="midword">) {</span>

    <span class="keyword">if</span><span class="midword">(</span>sort == <span class="midword">(</span><span class="keyworddark">size_t</span><span class="midword">)</span>-<span class="number">1</span><span class="midword">) {</span>
        <span class="keyword">if</span><span class="midword">(</span>!<span class="midwordlight">*</span>cdat<span class="midword">)</span> <span class="midwordlight">*</span>cdat = rules-&gt;pr.one;
        <span class="keyword">else return</span> <span class="number">1</span>;
    <span class="midword">}</span>
    <span class="keyword">else</span> <span class="midword">{</span>
        <span class="keyword">if</span><span class="midword">(</span>add_rule_pos<span class="midword">(</span>rules, sort, rules-&gt;pr.one<span class="midword">)</span> == <span class="number">2</span><span class="midword">) {</span>
            <span class="keyword">return</span> <span class="number">1</span>;
        <span class="midword">}</span>

        rules-&gt;data.number ++;
    <span class="midword">}</span>

    <span class="keyword">return</span> <span class="number">0</span>;
<span class="midword">}</span>

<span class="commentdoc">/*! Separates the parts of the rule \a str and adds them to \a data, which is a
    structure containing an array of strings. If a part is "*", it is assigned
    the value of the same section of the previous rule (determined from
    \a prev).
    \param data The structure to add the parts of the rule \a str to.
    \param prev The structure containing the parts of the previous rule (or
        NULL if this is the first rule).
    \param str The string representing the current rule, with all its parts.
*/</span>
<span class="keyword">void</span> add_parts<span class="midword">(</span><span class="keyword">struct</span> strings_t <span class="midwordlight">*</span>data, <span class="keyword">const struct</span> strings_t <span class="midwordlight">*</span>prev,
    <span class="keyword">const char</span> <span class="midwordlight">*</span>str<span class="midword">) {</span>

    <span class="keyword">const char</span> <span class="midwordlight">*</span>p = str;

    <span class="keyword">do</span> <span class="midword">{</span>
        p = strchr<span class="midword">(</span>p, <span class="string">':'</span><span class="midword">)</span>;

        <span class="keyword">if</span><span class="midword">(</span>!p<span class="midword">) {</span>  <span class="comment">/* No more ':'s */</span>
            <span class="keyword">if</span><span class="midword">(</span>prev <span class="midwordlight">&amp;&amp; *</span>str == <span class="string">'*'</span> <span class="midwordlight">&amp;&amp;</span> !str<span class="midword">[</span><span class="number">1</span><span class="midword">]</span> <span class="midwordlight">&amp;&amp;</span> data-&gt;number &lt; prev-&gt;number<span class="midword">) {</span>
                add_string_copy<span class="midword">(</span>data, prev<span class="midword">)</span>;
            <span class="midword">}</span>
            <span class="keyword">else</span> add_string<span class="midword">(</span>data, str<span class="midword">)</span>;
        <span class="midword">}</span>
        <span class="keyword">else</span> <span class="midword">{</span>
            <span class="keyword">if</span><span class="midword">(</span>!is_backslashed<span class="midword">(</span>str, p<span class="midword">)) {</span>
                <span class="keyword">if</span><span class="midword">(</span>prev <span class="midwordlight">&amp;&amp; *</span>str == <span class="string">'*'</span> <span class="midwordlight">&amp;&amp;</span> str<span class="midword">[</span><span class="number">1</span><span class="midword">]</span> == <span class="string">':'</span><span class="midword">) {</span>
                    add_string_copy<span class="midword">(</span>data, prev<span class="midword">)</span>;
                <span class="midword">}</span>
                <span class="keyword">else</span> add_string_len<span class="midword">(</span>data, str, p-str<span class="midword">)</span>;

                str = p+<span class="number">1</span>;
            <span class="midword">}</span>

            p ++;
        <span class="midword">}</span>
    <span class="midword">}</span> <span class="keyword">while</span><span class="midword">(</span>p<span class="midword">)</span>;
<span class="midword">}</span>

<span class="commentdoc">/*! Checks to see if the number of parts in the rule \a str has at least
    \a rparts (required parts) with an optional up to \a xparts extra parts.
    \param rparts Minimum number of required parts for the rule \a str to have.
    \param xparts Optional number of extra parts in addition to \a rparts.
    \param str The string to check the parts of.
    \return True if the number of parts is in the range rparts to
        rparts+xparts.
*/</span>
<span class="keyword">int</span> check_parts<span class="midword">(</span><span class="keyword">int</span> rparts, <span class="keyword">int</span> xparts, <span class="keyword">const char</span> <span class="midwordlight">*</span>str<span class="midword">) {</span>
    <span class="keyword">const char</span> <span class="midwordlight">*</span>s = str, <span class="midwordlight">*</span>p;
    <span class="keyword">int</span> parts = <span class="number">0</span>;

    <span class="keyword">do</span> <span class="midword">{</span>
        p = strchr<span class="midword">(</span>s, <span class="string">':'</span><span class="midword">)</span>;
        <span class="keyword">if</span><span class="midword">(</span>!p <span class="midwordlight">&amp;&amp; *</span>s<span class="midword">) {</span>
            parts ++;
        <span class="midword">}</span>
        <span class="keyword">else</span> <span class="midword">{</span>
            <span class="keyword">if</span><span class="midword">(</span>!is_backslashed<span class="midword">(</span>str, p<span class="midword">)) {</span>
                parts ++;
                str = s = p+<span class="number">1</span>;
            <span class="midword">}</span>
            <span class="keyword">else</span> s ++;
        <span class="midword">}</span>
    <span class="midword">}</span> <span class="keyword">while</span><span class="midword">(</span>p<span class="midword">)</span>;

    <span class="keyword">return</span> parts &gt;= rparts <span class="midwordlight">&amp;&amp;</span> parts &lt;= rparts+xparts;
<span class="midword">}</span>

<span class="commentdoc">/*! Calls remove_escapes() for every string in the strings structure \a data.
    \param data The structure containing strings to remove escapes from.
*/</span>
<span class="keyword">void</span> process_escapes<span class="midword">(</span><span class="keyword">struct</span> strings_t <span class="midwordlight">*</span>data<span class="midword">) {</span>
    <span class="keyworddark">size_t</span> x;

    <span class="keyword">for</span><span class="midword">(</span>x = <span class="number">0</span>; x &lt; data-&gt;number; x ++<span class="midword">) {</span>
        remove_escapes<span class="midword">(</span><span class="midwordlight">&amp;</span>data-&gt;data<span class="midword">[</span>x<span class="midword">]</span>, <span class="midwordlight">&amp;</span>data-&gt;len<span class="midword">[</span>x<span class="midword">])</span>;
    <span class="midword">}</span>
<span class="midword">}</span>

<span class="commentdoc">/*! Removes characters in \a str, replacing them with what they represent. "\n"
    turns into a newline. (To do this, a character must be removed, for "\n" is
    two characters and a newline one; remove_char() is called to this end.)
    \param str The string to remove escaped characters from.
    \param len The length of the string, decremented for each escape sequence
        replaced.
*/</span>
<span class="keyword">void</span> remove_escapes<span class="midword">(</span><span class="keyword">char</span> <span class="midwordlight">**</span>str, <span class="keyworddark">size_t</span> <span class="midwordlight">*</span>len<span class="midword">) {</span>
    <span class="keyword">char</span> <span class="midwordlight">*</span>p;
    <span class="keyworddark">size_t</span> olen = <span class="midwordlight">*</span>len;

    <span class="keyword">for</span><span class="midword">(</span>p = <span class="midwordlight">*</span>str; <span class="midword">(</span>p = strchr<span class="midword">(</span>p, <span class="string">'\\'</span><span class="midword">))</span>; p ++<span class="midword">) {</span>
        remove_char<span class="midword">(</span>p<span class="midword">)</span>;

        <span class="keyword">switch</span><span class="midword">(</span><span class="midwordlight">*</span>p<span class="midword">) {</span>
        <span class="keyword">case</span> <span class="string">'n'</span>:
            <span class="midwordlight">*</span>p = <span class="string">'\n'</span>;
            <span class="keyword">break</span>;
        <span class="keyword">case</span> <span class="string">'t'</span>:
            <span class="midwordlight">*</span>p = <span class="string">'\t'</span>;
            <span class="keyword">break</span>;
        <span class="keyword">default</span>: <span class="keyword">break</span>;
        <span class="midword">}</span>

        <span class="midword">(</span><span class="midwordlight">*</span>len<span class="midword">)</span> --;
    <span class="midword">}</span>

    <span class="keyword">if</span><span class="midword">(</span><span class="midwordlight">*</span>len != olen<span class="midword">)</span> shrink_string<span class="midword">(</span>str, <span class="midwordlight">*</span>len<span class="midword">)</span>;
<span class="midword">}</span>

<span class="commentdoc">/*! Calls replace_var_str() for every string in \a data.
    \param vars A structure containing an array of variables.
    \param data The data to apply the variables to.
*/</span>
<span class="keyword">void</span> process_vars<span class="midword">(</span><span class="keyword">const struct</span> rulevars_t <span class="midwordlight">*</span>vars, <span class="keyword">struct</span> strings_t <span class="midwordlight">*</span>data<span class="midword">) {</span>
    <span class="keyworddark">size_t</span> x;

    <span class="keyword">for</span><span class="midword">(</span>x = <span class="number">0</span>; x &lt; data-&gt;number; x ++<span class="midword">) {</span>
        replace_var_str<span class="midword">(</span>vars, <span class="midwordlight">&amp;</span>data-&gt;data<span class="midword">[</span>x<span class="midword">])</span>;
        data-&gt;len<span class="midword">[</span>x<span class="midword">]</span> = strlen<span class="midword">(</span>data-&gt;data<span class="midword">[</span>x<span class="midword">])</span>;  <span class="comment">/* !!! can be determined */</span>
    <span class="midword">}</span>
<span class="midword">}</span>

<span class="commentdoc">/*! For every '$' sign in \a str, calls replace_onevar() with every variable,
    looking for a match.
    \param vars The structure containing the array of variables.
    \param str The string to replace occurences of $variable_name with the
        value of the variable variable_name.
*/</span>
<span class="keyword">void</span> replace_var_str<span class="midword">(</span><span class="keyword">const struct</span> rulevars_t <span class="midwordlight">*</span>vars, <span class="keyword">char</span> <span class="midwordlight">**</span>str<span class="midword">) {</span>
    <span class="keyword">char</span> <span class="midwordlight">*</span>p, <span class="midwordlight">*</span>end;

    <span class="keyword">for</span><span class="midword">(</span>p = <span class="midwordlight">*</span>str; <span class="midword">(</span>p = strchr<span class="midword">(</span>p, <span class="string">'$'</span><span class="midword">))</span>; p ++<span class="midword">) {</span>
        <span class="keyword">if</span><span class="midword">(</span>!is_backslashed<span class="midword">(</span><span class="midwordlight">*</span>str, p<span class="midword">)</span> <span class="midwordlight">&amp;&amp;</span> p<span class="midword">[</span><span class="number">1</span><span class="midword">]</span> == <span class="string">'('</span>
            <span class="midwordlight">&amp;&amp;</span> <span class="midword">(</span>end = strchr<span class="midword">(</span>p+<span class="number">2</span>, <span class="string">')'</span><span class="midword">))) {</span>

            find_var_replace<span class="midword">(</span>vars, str, <span class="midwordlight">&amp;</span>p, end<span class="midword">)</span>;
        <span class="midword">}</span>
    <span class="midword">}</span>
<span class="midword">}</span>

<span class="commentdoc">/*! Resizes the string str to len characters in size. If the memory block was
    moved, points pos to the same position relative to the new memory block as
    it was relative to str.
    \param str The string to resize to \a len characters long.
    \param pos The position to move if str changes.
    \param len The new size of the string.
*/</span>
<span class="keyword">void</span> resize_var_string<span class="midword">(</span><span class="keyword">char</span> <span class="midwordlight">**</span>str, <span class="keyword">char</span> <span class="midwordlight">**</span>pos, <span class="keyworddark">size_t</span> len<span class="midword">) {</span>
    <span class="keyword">char</span> <span class="midwordlight">*</span>p = realloc<span class="midword">(</span><span class="midwordlight">*</span>str, len<span class="midword">)</span>;

    <span class="keyword">if</span><span class="midword">(</span>!p<span class="midword">) {</span>
        out_of_memory<span class="midword">(</span>__FILE__, __LINE__<span class="midword">)</span>;
    <span class="midword">}</span>

    <span class="midwordlight">*</span>pos = <span class="midwordlight">*</span>pos-<span class="midwordlight">*</span>str + p;
    <span class="midwordlight">*</span>str = p;
<span class="midword">}</span>

<span class="commentdoc">/*! Binary searches through the existing variables in \a rt for the variable
    matching the string \a str, calling the function to replace the variable
    with the text for that variable.
    \param vars The existing variables to search through.
    \param str The string containing the variable to search for.
    \param p The start of the variable to look for (position of the '$').
    \param end The end of the variable to look for (position of the ')').
*/</span>
<span class="keyword">void</span> find_var_replace<span class="midword">(</span><span class="keyword">const struct</span> rulevars_t <span class="midwordlight">*</span>vars, <span class="keyword">char</span> <span class="midwordlight">**</span>str, <span class="keyword">char</span> <span class="midwordlight">**</span>p,
    <span class="keyword">char</span> <span class="midwordlight">*</span>end<span class="midword">) {</span>

    <span class="keyworddark">size_t</span> mid = <span class="midword">(</span><span class="keyworddark">size_t</span><span class="midword">)</span>-<span class="number">1</span>, first = <span class="number">0</span>, last = vars-&gt;number-<span class="number">1</span>;
    <span class="keyworddark">size_t</span> pos = <span class="midword">(</span><span class="keyworddark">size_t</span><span class="midword">)</span>-<span class="number">1</span>;
    <span class="keyword">int</span> v = <span class="number">0</span>;

    pos = <span class="midword">(</span><span class="keyworddark">size_t</span><span class="midword">)</span>-<span class="number">1</span>;

    <span class="keyword">if</span><span class="midword">(</span>!vars-&gt;number<span class="midword">)</span> <span class="keyword">return</span>;

    <span class="keyword">while</span><span class="midword">(</span>first &lt;= last <span class="midwordlight">&amp;&amp;</span> last != <span class="midword">(</span><span class="keyworddark">size_t</span><span class="midword">)</span>-<span class="number">1</span><span class="midword">) {</span>
        mid = <span class="midword">(</span>first + last<span class="midword">)</span> / <span class="number">2</span>;

        v = replace_onevar<span class="midword">(</span>vars-&gt;data<span class="midword">[</span>mid<span class="midword">]</span>, str, p, end<span class="midword">)</span>;

        <span class="keyword">if</span><span class="midword">(</span>v &lt; <span class="number">0</span><span class="midword">)</span> last = mid-<span class="number">1</span>;
        <span class="keyword">else if</span><span class="midword">(</span>v &gt; <span class="number">0</span><span class="midword">)</span> first = mid+<span class="number">1</span>;
        <span class="keyword">else</span> <span class="midword">{</span>
            pos = mid;
            first = mid+<span class="number">1</span>;

            <span class="midwordlight">*</span>p = <span class="midwordlight">*</span>str-<span class="number">1</span>;
            <span class="keyword">break</span>;
        <span class="midword">}</span>
    <span class="midword">}</span>

    <span class="keyword">if</span><span class="midword">(</span>pos == <span class="midword">(</span><span class="keyworddark">size_t</span><span class="midword">)</span>-<span class="number">1</span><span class="midword">) {</span>
        replace_novar<span class="midword">(</span>end-<span class="midwordlight">*</span>p-<span class="number">2</span>, str, p<span class="midword">)</span>;
        <span class="midword">(</span><span class="midwordlight">*</span>p<span class="midword">)</span> --;
    <span class="midword">}</span>
    <span class="keyword">else</span> <span class="midword">{</span>
        <span class="keyword">if</span><span class="midword">(</span>v &lt; <span class="number">0</span><span class="midword">)</span> pos = mid;
        <span class="keyword">else</span> pos = mid+<span class="number">1</span>;
    <span class="midword">}</span>
<span class="midword">}</span>

<span class="commentdoc">/*! Replaces the position \a pos in the string \a str (if it matches a '$' and
    the variable's name) with the text the variable is replaced with.
    \param var A structure containing the variable's name and text to replace
        with.
    \param str The string containing the variable.
    \param pos The start of the string to do the replacing in (dynamically
        reallocated to the new size).
    \param end The position in \a str of the '$' in a variable name.
    \return Nonzero if a text substitution was made.
*/</span>
<span class="keyword">int</span> replace_onevar<span class="midword">(</span><span class="keyword">const struct</span> onevar_t <span class="midwordlight">*</span>var, <span class="keyword">char</span> <span class="midwordlight">**</span>str, <span class="keyword">char</span> <span class="midwordlight">**</span>pos,
    <span class="keyword">char</span> <span class="midwordlight">*</span>end<span class="midword">) {</span>

    <span class="keyworddark">size_t</span> olen, plen;
    <span class="keyword">int</span> v;

    <span class="keyword">if</span><span class="midword">(</span>!<span class="midword">(</span>v = strncmp<span class="midword">(</span><span class="midwordlight">*</span>pos+<span class="number">2</span>, var-&gt;from, end - <span class="midwordlight">*</span>pos - <span class="number">2</span><span class="midword">))) {</span>
        <span class="keyword">if</span><span class="midword">(</span>var-&gt;from<span class="midword">[</span>end - <span class="midwordlight">*</span>pos - <span class="number">2</span><span class="midword">])</span> <span class="keyword">return</span> -<span class="number">1</span>;

        olen = strlen<span class="midword">(</span><span class="midwordlight">*</span>str<span class="midword">)</span>;
        plen = olen + <span class="midwordlight">*</span>str - <span class="midwordlight">*</span>pos;

        <span class="keyword">if</span><span class="midword">(</span>var-&gt;flen+<span class="number">2</span> &lt; var-&gt;tlen<span class="midword">) {</span>
            resize_var_string<span class="midword">(</span>str, pos, olen - var-&gt;flen + var-&gt;tlen - <span class="number">2</span><span class="midword">)</span>;

            memmove<span class="midword">(</span><span class="midwordlight">*</span>pos + var-&gt;tlen, <span class="midwordlight">*</span>pos + var-&gt;flen+<span class="number">3</span>, plen - var-&gt;flen-<span class="number">2</span><span class="midword">)</span>;
        <span class="midword">}</span>
        <span class="keyword">else</span> <span class="midword">{</span>
            memmove<span class="midword">(</span><span class="midwordlight">*</span>pos + var-&gt;tlen, <span class="midwordlight">*</span>pos + var-&gt;flen+<span class="number">3</span>, plen - var-&gt;flen-<span class="number">2</span><span class="midword">)</span>;

            resize_var_string<span class="midword">(</span>str, pos, olen - var-&gt;flen + var-&gt;tlen - <span class="number">2</span><span class="midword">)</span>;
        <span class="midword">}</span>

        memmove<span class="midword">(</span><span class="midwordlight">*</span>pos, var-&gt;to, var-&gt;tlen<span class="midword">)</span>;
    <span class="midword">}</span>

    <span class="keyword">return</span> v;
<span class="midword">}</span>

<span class="commentdoc">/*! Replaces the variable at \a pos in the string \a str with a null value, "".
    \param cp The length of the variable.
    \param str The start of the string to do the replacing in (dynamically
        reallocated to the new size).
    \param pos The position in \a str of the variable.
*/</span>
<span class="keyword">void</span> replace_novar<span class="midword">(</span><span class="keyworddark">size_t</span> cp, <span class="keyword">char</span> <span class="midwordlight">**</span>str, <span class="keyword">char</span> <span class="midwordlight">**</span>pos<span class="midword">) {</span>
    <span class="keyworddark">size_t</span> olen, plen;

    olen = strlen<span class="midword">(</span><span class="midwordlight">*</span>str<span class="midword">)</span>;
    plen = olen + <span class="midwordlight">*</span>str - <span class="midwordlight">*</span>pos;

    memmove<span class="midword">(</span><span class="midwordlight">*</span>pos, <span class="midwordlight">*</span>pos + cp+<span class="number">3</span>, plen - cp-<span class="number">2</span><span class="midword">)</span>;

    resize_var_string<span class="midword">(</span>str, pos, olen - cp-<span class="number">2</span><span class="midword">)</span>;
<span class="midword">}</span>

<span class="commentdoc">/*! Returns the number of the header that the rule \a str represents.
    \param rules The rules structure that holds the types.
    \param str The string representing the rule that may be a header.
    \param type A pointer to set to the type of the header.
    \return Zero if \a str is not a header; (size_t)-1 if it is a nonexistent
        header; 1 if it is a header; and the position of the end of the header
        (&gt;= 2) if it is an inline header.
*/</span>
<span class="keyworddark">size_t</span> get_type<span class="midword">(</span><span class="keyword">struct</span> rules_t <span class="midwordlight">*</span>rules, <span class="keyword">const char</span> <span class="midwordlight">*</span>str, <span class="keyword">enum</span> type_t <span class="midwordlight">*</span>type<span class="midword">) {</span>
    <span class="keyword">enum</span> type_t x;
    <span class="keyword">const char</span> <span class="midwordlight">*</span>p;
    <span class="keyworddark">size_t</span> len = <span class="midword">(</span><span class="keyworddark">size_t</span><span class="midword">)</span>-<span class="number">1</span>;

    <span class="keyword">if</span><span class="midword">(</span><span class="midwordlight">*</span>str != <span class="string">'='</span><span class="midword">)</span> <span class="keyword">return</span> <span class="number">0</span>;
    <span class="keyword">if</span><span class="midword">((</span>p = strchr<span class="midword">(</span>str, <span class="string">':'</span><span class="midword">)))</span> len = p-str-<span class="number">1</span>;

    <span class="keyword">for</span><span class="midword">(</span>x = <span class="number">0</span>; x &lt; TYPES; x ++<span class="midword">) {</span>
        <span class="keyword">if</span><span class="midword">(</span>!strncmp<span class="midword">(</span>rules-&gt;type<span class="midword">[</span>x<span class="midword">]</span>.name, str+<span class="number">1</span>, len<span class="midword">)) {</span>
            <span class="midwordlight">*</span>type = x;
            <span class="keyword">return</span> <span class="midword">(</span>p ? len+<span class="number">2</span> : <span class="number">1</span><span class="midword">)</span>;
        <span class="midword">}</span>
    <span class="midword">}</span>

    <span class="keyword">return</span> <span class="midword">(</span><span class="keyworddark">size_t</span><span class="midword">)</span>-<span class="number">1</span>;
<span class="midword">}</span>

<span class="commentdoc">/*! Opens all the input files and pass them on to read_file(). Copies the other
    output files from the first output file with copy_file().
    \param rules The structure containing all the rules.
    \param inputfn The strings_t structure with all the input file names.
    \param outputfn The files to write to. All the data is written to the first
        one, and that file is then copied to all the others.
*/</span>
<span class="keyword">void</span> parse_files<span class="midword">(</span><span class="keyword">struct</span> rules_t <span class="midwordlight">*</span>rules, <span class="keyword">struct</span> strings_t <span class="midwordlight">*</span>inputfn,
    <span class="keyword">struct</span> strings_t <span class="midwordlight">*</span>outputfn<span class="midword">) {</span>

    <span class="keyworddark">FILE</span> <span class="midwordlight">*</span>out = <span class="number">0</span>;
    <span class="keyworddark">size_t</span> x, y;

    <span class="keyword">for</span><span class="midword">(</span>x = <span class="number">0</span>; x &lt; outputfn-&gt;number
        <span class="midwordlight">&amp;&amp;</span> !<span class="midword">(</span>out = open_file<span class="midword">(</span>outputfn-&gt;data<span class="midword">[</span>x<span class="midword">]</span>, <span class="string">"w+"</span><span class="midword">))</span>; x ++<span class="midword">)</span>;

    <span class="keyword">if</span><span class="midword">(</span>!out<span class="midword">) {</span>
        <span class="keyword">if</span><span class="midword">(</span>x<span class="midword">)</span> fprintf<span class="midword">(</span>stderr, <span class="string">"codeform: No output files could be opened,"</span>
            <span class="string">" using stdout\n"</span><span class="midword">)</span>;
        out = stdout;
    <span class="midword">}</span>

    <span class="keyword">for</span><span class="midword">(</span>y = <span class="number">0</span>; y &lt; inputfn-&gt;number; y ++<span class="midword">) {</span>
        read_file<span class="midword">(</span>rules, inputfn-&gt;data<span class="midword">[</span>y<span class="midword">]</span>, out<span class="midword">)</span>;
    <span class="midword">}</span>

    <span class="keyword">if</span><span class="midword">(</span>!inputfn-&gt;number<span class="midword">)</span> read_file<span class="midword">(</span>rules, <span class="string">"-"</span>, out<span class="midword">)</span>;

    <span class="keyword">for</span><span class="midword">(</span>y = <span class="number">1</span>; y &lt; outputfn-&gt;number; y ++<span class="midword">) {</span>
        copy_file<span class="midword">(</span>out, outputfn-&gt;data<span class="midword">[</span>y<span class="midword">])</span>;
    <span class="midword">}</span>

    <span class="keyword">if</span><span class="midword">(</span>out != stdout<span class="midword">)</span> fclose<span class="midword">(</span>out<span class="midword">)</span>;
<span class="midword">}</span>

<span class="commentdoc">/*! Reads from the file \a fn, passing each line read to parse_line().
    Determines when the end or the start of the file \a fn has been reached,
    passing this information on to parse_line().
    \param rules Used only to pass on to parse_line().
    \param fn The filename to read from.
    \param out Used only to pass on to parse_line().
*/</span>
<span class="keyword">void</span> read_file<span class="midword">(</span><span class="keyword">struct</span> rules_t <span class="midwordlight">*</span>rules, <span class="keyword">const char</span> <span class="midwordlight">*</span>fn, <span class="keyworddark">FILE</span> <span class="midwordlight">*</span>out<span class="midword">) {</span>
    <span class="keyworddark">FILE</span> <span class="midwordlight">*</span>in = open_file<span class="midword">(</span>fn, <span class="string">"r"</span><span class="midword">)</span>;
    <span class="keyword">char</span> <span class="midwordlight">*</span>line = malloc<span class="midword">(</span>BUFSIZ<span class="midword">)</span>;
    <span class="keyword">struct</span> typefunc_t tf;
    <span class="keyworddark">size_t</span> len, alen = BUFSIZ;
    <span class="keyword">int</span> quit = <span class="number">0</span>;

    <span class="keyword">if</span><span class="midword">(</span>!in<span class="midword">)</span> <span class="keyword">return</span>;

    <span class="keyword">if</span><span class="midword">(</span>!line<span class="midword">)</span> out_of_memory<span class="midword">(</span>__FILE__, __LINE__<span class="midword">)</span>;
    <span class="midwordlight">*</span>line = <span class="number">0</span>;

    tf.func.which = <span class="number">0</span>;
    tf.func.type = <span class="number">0</span>;
    tf.func.number = <span class="number">0</span>;
    tf.func.nest = <span class="number">1</span>;
    tf.pos = POS_START;
    tf.list = <span class="midwordlight">&amp;</span>rules-&gt;list;

    tf.out = out;
    parse_line<span class="midword">(</span>rules, line, out, <span class="midwordlight">&amp;</span>tf<span class="midword">)</span>;

    <span class="keyword">do</span> <span class="midword">{</span>
        len = <span class="number">0</span>;

        <span class="keyword">if</span><span class="midword">(</span>!get_string<span class="midword">(</span><span class="midwordlight">&amp;</span>line, <span class="number">0</span>, <span class="midwordlight">&amp;</span>alen, in<span class="midword">)) {</span>
            tf.pos |= POS_END;
            quit = <span class="number">1</span>;
        <span class="midword">}</span>

        tf.out = out;
        parse_line<span class="midword">(</span>rules, line, out, <span class="midwordlight">&amp;</span>tf<span class="midword">)</span>;

        tf.pos = <span class="number">0</span>;
    <span class="midword">}</span> <span class="keyword">while</span><span class="midword">(</span>!quit<span class="midword">)</span>;

    <span class="keyword">if</span><span class="midword">(</span>in != stdin<span class="midword">)</span> fclose<span class="midword">(</span>in<span class="midword">)</span>;

    free<span class="midword">(</span>line<span class="midword">)</span>;
<span class="midword">}</span>

<span class="commentdoc">/*! Parses a line from an input file, calling type_funcs for every character.
    If one call is successful, calls each type_func again.
    \param rules The structure containing all the rules for parsing.
    \param line The line from the input file to parse.
    \param out The output file stream to write the results to.
    \param tf The structure that is passed to all the type_func functions,
        along with the rule_t structure appropriate for it.
*/</span>
<span class="keyword">void</span> parse_line<span class="midword">(</span><span class="keyword">struct</span> rules_t <span class="midwordlight">*</span>rules, <span class="keyword">char</span> <span class="midwordlight">*</span>line, <span class="keyworddark">FILE</span> <span class="midwordlight">*</span>out,
    <span class="keyword">struct</span> typefunc_t <span class="midwordlight">*</span>tf<span class="midword">) {</span>

    <span class="keyword">char</span> <span class="midwordlight">*</span>p = line;
    <span class="keyword">int</span> iw = <span class="number">0</span>, redo;

    tf-&gt;p = <span class="midwordlight">&amp;</span>p;

    <span class="keyword">do</span> <span class="midword">{</span>
        <span class="keyword">do</span> <span class="midword">{</span>
            redo = <span class="number">0</span>;

            tf-&gt;iw = iw;
            tf-&gt;n = p - line;

            <span class="keyword">if</span><span class="midword">(</span>tf-&gt;func.number<span class="midword">) {</span>
                <span class="keyword">if</span><span class="midword">(</span>call_one_type<span class="midword">(</span>rules, tf<span class="midword">)</span> || call_type_cdat<span class="midword">(</span>rules, tf<span class="midword">)) {</span>
                    redo = <span class="number">1</span>;
                <span class="midword">}</span>
            <span class="midword">}</span>

            <span class="keyword">if</span><span class="midword">(</span>!redo <span class="midwordlight">&amp;&amp;</span> call_type_funcs<span class="midword">(</span>rules, tf<span class="midword">))</span> redo = <span class="number">1</span>;

            <span class="keyword">if</span><span class="midword">(</span>!redo<span class="midword">) {</span>
                <span class="keyword">if</span><span class="midword">(</span><span class="midwordlight">*</span>p<span class="midword">) {</span>
                    <span class="keyword">if</span><span class="midword">(</span>!isspace<span class="midword">(</span><span class="midwordlight">*</span>p<span class="midword">)) {</span>
                        append_rulelist<span class="midword">(</span><span class="number">0</span>, <span class="number">0</span>, <span class="midwordlight">&amp;</span>rules-&gt;list, out<span class="midword">)</span>;
                        putc<span class="midword">(</span><span class="midwordlight">*</span>p, out<span class="midword">)</span>;
                    <span class="midword">}</span>
                    <span class="keyword">else if</span><span class="midword">(</span>rules-&gt;list.to<span class="midword">) {</span>
                        add_ws_rulelist<span class="midword">(</span><span class="midwordlight">&amp;</span>rules-&gt;list, <span class="midwordlight">*</span>p<span class="midword">)</span>;
                    <span class="midword">}</span>
                    <span class="keyword">else</span> putc<span class="midword">(</span><span class="midwordlight">*</span>p, out<span class="midword">)</span>;
                <span class="midword">}</span>

                iw = is_word<span class="midword">(</span><span class="midwordlight">*</span>p<span class="midword">)</span>;
            <span class="midword">}</span>
            <span class="keyword">else</span> iw = is_word_prev<span class="midword">(</span>line, p<span class="midword">)</span>;
        <span class="midword">}</span> <span class="keyword">while</span><span class="midword">(</span>redo<span class="midword">)</span>;
    <span class="midword">}</span> <span class="keyword">while</span><span class="midword">(</span><span class="midwordlight">*</span>p++<span class="midword">)</span>;

    append_rulelist<span class="midword">(</span><span class="number">0</span>, <span class="number">0</span>, <span class="midwordlight">&amp;</span>rules-&gt;list, out<span class="midword">)</span>;
<span class="midword">}</span>

<span class="commentdoc">/*! Calls the type_func function that may end the latest comment.
    \param rules The structure containing the rules and types.
    \param tf The structure that is passed to the type_func function.
    \return Nonzero if the type_func function ended the comment.
*/</span>
<span class="keyword">int</span> call_one_type<span class="midword">(</span><span class="keyword">struct</span> rules_t <span class="midwordlight">*</span>rules, <span class="keyword">struct</span> typefunc_t <span class="midwordlight">*</span>tf<span class="midword">) {</span>
    <span class="keyword">int</span> r;

    tf-&gt;number = tf-&gt;func.which<span class="midword">[</span>tf-&gt;func.number-<span class="number">1</span><span class="midword">]</span>;
    tf-&gt;type = tf-&gt;func.type<span class="midword">[</span>tf-&gt;func.number-<span class="number">1</span><span class="midword">]</span>;

    r = <span class="midword">(</span><span class="midwordlight">*</span>rules-&gt;type<span class="midword">[</span>tf-&gt;type<span class="midword">]</span>.func<span class="midword">)</span>
        <span class="midword">(</span>rules-&gt;data.data<span class="midword">[</span>tf-&gt;number<span class="midword">]</span>, tf<span class="midword">)</span>;

    <span class="keyword">if</span><span class="midword">(</span>r &lt; <span class="number">0</span><span class="midword">)</span> remove_from_funclist<span class="midword">(</span><span class="midwordlight">&amp;</span>tf-&gt;func<span class="midword">)</span>;

    <span class="keyword">return</span> r;
<span class="midword">}</span>

<span class="commentdoc">/*! Calls the type_func functions that have a sort of \c (size_t)-1, which have
    only one rule, stored in the cdat[] array in \a rules.
    \param rules The structure containing the cdat array and sorts for the
        type_func functions.
    \param tf The structure that is passed to the type_func functions.
    \return True if one of the functions called returned true.
*/</span>
<span class="keyword">int</span> call_type_cdat<span class="midword">(</span><span class="keyword">struct</span> rules_t <span class="midwordlight">*</span>rules, <span class="keyword">struct</span> typefunc_t <span class="midwordlight">*</span>tf<span class="midword">) {</span>
    <span class="keyword">enum</span> type_t x;

    <span class="keyword">for</span><span class="midword">(</span>x = <span class="number">0</span>; x &lt; TYPES; x ++<span class="midword">) {</span>
        <span class="keyword">if</span><span class="midword">(</span>rules-&gt;type<span class="midword">[</span>x<span class="midword">]</span>.sort == <span class="midword">(</span><span class="keyworddark">size_t</span><span class="midword">)</span>-<span class="number">1</span> <span class="midwordlight">&amp;&amp;</span> rules-&gt;cdat<span class="midword">[</span>x<span class="midword">]) {</span>
            tf-&gt;number = <span class="midword">(</span><span class="keyworddark">size_t</span><span class="midword">)</span>-<span class="number">1</span>;
            tf-&gt;type = x;

            <span class="keyword">if</span><span class="midword">((</span><span class="midwordlight">*</span>rules-&gt;type<span class="midword">[</span>x<span class="midword">]</span>.func<span class="midword">)(</span>rules-&gt;cdat<span class="midword">[</span>x<span class="midword">]</span>, tf<span class="midword">)) {</span>
                <span class="keyword">return</span> <span class="number">1</span>;
            <span class="midword">}</span>
        <span class="midword">}</span>
    <span class="midword">}</span>

    <span class="keyword">return</span> <span class="number">0</span>;
<span class="midword">}</span>

<span class="commentdoc">/*! Calls the appropriate type_func function for a rule if a match to the
    current position in the line was found.
    \param rules The structure containing the rules to search through.
    \param tf The structure passed to the type_func functions.
    \return True if a function was called.
*/</span>
<span class="keyword">int</span> call_type_funcs<span class="midword">(</span><span class="keyword">struct</span> rules_t <span class="midwordlight">*</span>rules, <span class="keyword">struct</span> typefunc_t <span class="midwordlight">*</span>tf<span class="midword">) {</span>
    <span class="keyworddark">size_t</span> match;

    <span class="keyword">if</span><span class="midword">(</span>call_type_cdat<span class="midword">(</span>rules, tf<span class="midword">))</span> <span class="keyword">return</span> <span class="number">1</span>;

    <span class="keyword">if</span><span class="midword">(</span>find_rule_match<span class="midword">(</span>rules, <span class="midwordlight">*</span>tf-&gt;p, <span class="midwordlight">&amp;</span>match<span class="midword">)) {</span>
        tf-&gt;number = match;
        tf-&gt;type = rules-&gt;data.data<span class="midword">[</span>match<span class="midword">]</span>-&gt;type;

        <span class="keyword">if</span><span class="midword">((</span><span class="midwordlight">*</span>rules-&gt;type<span class="midword">[</span>tf-&gt;type<span class="midword">]</span>.func<span class="midword">)(</span>rules-&gt;data.data<span class="midword">[</span>match<span class="midword">]</span>, tf<span class="midword">)) {</span>
            <span class="keyword">return</span> <span class="number">1</span>;
        <span class="midword">}</span>
    <span class="midword">}</span>

    <span class="keyword">return</span> <span class="number">0</span>;
<span class="midword">}</span>

<span class="commentdoc">/*! Sets the prev members of every rule in \a rules, calling set_follow_prev()
    for each rule.
    \param rules The structure containing the rules to set the prev member of.
*/</span>
<span class="keyword">void</span> set_rules_prev<span class="midword">(</span><span class="keyword">struct</span> rules_t <span class="midwordlight">*</span>rules<span class="midword">) {</span>
    <span class="keyworddark">size_t</span> x, y;

    <span class="keyword">for</span><span class="midword">(</span>x = <span class="number">0</span>; x &lt; TYPES; x ++<span class="midword">) {</span>
        <span class="keyword">for</span><span class="midword">(</span>y = <span class="number">0</span>; y &lt; rules-&gt;data.number; y ++<span class="midword">) {</span>
            <span class="keyword">if</span><span class="midword">(</span>rules-&gt;type<span class="midword">[</span>x<span class="midword">]</span>.sort != <span class="midword">(</span><span class="keyworddark">size_t</span><span class="midword">)</span>-<span class="number">1</span><span class="midword">) {</span>
                set_follow_prev<span class="midword">(</span>rules, y<span class="midword">)</span>;
            <span class="midword">}</span>
        <span class="midword">}</span>
    <span class="midword">}</span>
<span class="midword">}</span>

<span class="commentdoc">/*! Sets the prev members of the structures following the rule \a start to
    \a start if their first characters (the length of the rule \a start) match
    the characters in the rule \a start.
    \param rules The structure containing the rules and sorts.
    \param start The element in the array of rules to start at (and set prevs
        to).
*/</span>
<span class="keyword">void</span> set_follow_prev<span class="midword">(</span><span class="keyword">struct</span> rules_t <span class="midwordlight">*</span>rules, <span class="keyworddark">size_t</span> start<span class="midword">) {</span>
    <span class="keyworddark">size_t</span> x;

    <span class="keyword">for</span><span class="midword">(</span>x = start+<span class="number">1</span>; x &lt; rules-&gt;data.number; x ++<span class="midword">) {</span>
        <span class="keyword">if</span><span class="midword">(</span>strncmp<span class="midword">(</span>rules-&gt;data.data<span class="midword">[</span>start<span class="midword">]</span>-&gt;data
                .data<span class="midword">[</span>rules-&gt;type<span class="midword">[</span>rules-&gt;data.data<span class="midword">[</span>start<span class="midword">]</span>-&gt;type<span class="midword">]</span>.sort<span class="midword">]</span>,
            rules-&gt;data.data<span class="midword">[</span>x<span class="midword">]</span>-&gt;data
                .data<span class="midword">[</span>rules-&gt;type<span class="midword">[</span>rules-&gt;data.data<span class="midword">[</span>x<span class="midword">]</span>-&gt;type<span class="midword">]</span>.sort<span class="midword">]</span>,
            rules-&gt;data.data<span class="midword">[</span>start<span class="midword">]</span>-&gt;data
                .len<span class="midword">[</span>rules-&gt;type<span class="midword">[</span>rules-&gt;data.data<span class="midword">[</span>start<span class="midword">]</span>-&gt;type<span class="midword">]</span>.sort<span class="midword">])) {</span>

            <span class="keyword">break</span>;
        <span class="midword">}</span>

        rules-&gt;data.data<span class="midword">[</span>x<span class="midword">]</span>-&gt;prev = start;
    <span class="midword">}</span>
<span class="midword">}</span>

<span class="commentdoc">/*! Executes a binary search for \a p in the existing rules in \a rt. The
    longest match is assigned to \a pos.
    \param rules The array of existing rules to search through.
    \param p The string to search through the rules for.
    \param pos The variable to set to the longest match found, if any; if none,
        set to (size_t)-1.
    \return 1 if an exact match was found, 0 otherwise.
*/</span>
<span class="keyword">int</span> find_rule_match<span class="midword">(</span><span class="keyword">const struct</span> rules_t <span class="midwordlight">*</span>rules, <span class="keyword">const char</span> <span class="midwordlight">*</span>p, <span class="keyworddark">size_t</span> <span class="midwordlight">*</span>pos<span class="midword">) {</span>
    <span class="keyword">if</span><span class="midword">(</span>find_rule_new<span class="midword">(</span>rules, p, pos<span class="midword">))</span> <span class="keyword">return</span> <span class="number">1</span>;

    <span class="keyword">if</span><span class="midword">(</span><span class="midwordlight">*</span>pos &lt; rules-&gt;data.number<span class="midword">)</span> <span class="keyword">return</span> find_rule_prev<span class="midword">(</span>rules, p, pos<span class="midword">)</span>;

    <span class="keyword">return</span> <span class="number">0</span>;
<span class="midword">}</span>

<span class="commentdoc">/*! Binary searches through the existing rules in \a rt for the position that
    the rule \a p should be in, putting the result in \a pos.
    \param rules The structure containing the array of existing rules.
    \param p The new rule to search for.
    \param pos The variable to store the position found in. Set to (size_t)-1
        if no match was found.
    \return 1 if an exact match (to the shortest length) was found, 0
        otherwise. 2 if an exact match the whole way was found.
*/</span>
<span class="keyword">int</span> find_rule_new<span class="midword">(</span><span class="keyword">const struct</span> rules_t <span class="midwordlight">*</span>rules, <span class="keyword">const char</span> <span class="midwordlight">*</span>p, <span class="keyworddark">size_t</span> <span class="midwordlight">*</span>pos<span class="midword">) {</span>
    <span class="keyworddark">size_t</span> mid = <span class="midword">(</span><span class="keyworddark">size_t</span><span class="midword">)</span>-<span class="number">1</span>, first = <span class="number">0</span>, last = rules-&gt;data.number-<span class="number">1</span>, sort;
    <span class="keyword">int</span> v = <span class="number">0</span>;

    <span class="midwordlight">*</span>pos = <span class="midword">(</span><span class="keyworddark">size_t</span><span class="midword">)</span>-<span class="number">1</span>;

    <span class="keyword">if</span><span class="midword">(</span>!rules-&gt;data.number<span class="midword">)</span> <span class="keyword">return</span> <span class="number">0</span>;

    <span class="keyword">while</span><span class="midword">(</span>first &lt;= last <span class="midwordlight">&amp;&amp;</span> last != <span class="midword">(</span><span class="keyworddark">size_t</span><span class="midword">)</span>-<span class="number">1</span><span class="midword">) {</span>
        mid = <span class="midword">(</span>first + last<span class="midword">)</span> / <span class="number">2</span>;
        sort = rules-&gt;type<span class="midword">[</span>rules-&gt;data.data<span class="midword">[</span>mid<span class="midword">]</span>-&gt;type<span class="midword">]</span>.sort;

        v = strncmp<span class="midword">(</span>p, rules-&gt;data.data<span class="midword">[</span>mid<span class="midword">]</span>-&gt;data.data<span class="midword">[</span>sort<span class="midword">]</span>,
            rules-&gt;data.data<span class="midword">[</span>mid<span class="midword">]</span>-&gt;data.len<span class="midword">[</span>sort<span class="midword">])</span>;

        <span class="keyword">if</span><span class="midword">(</span>first == last <span class="midwordlight">&amp;&amp;</span> v<span class="midword">)</span> <span class="keyword">break</span>;

        <span class="keyword">if</span><span class="midword">(</span>v &lt; <span class="number">0</span><span class="midword">)</span> last = mid-<span class="number">1</span>;
        <span class="keyword">else if</span><span class="midword">(</span>v &gt; <span class="number">0</span><span class="midword">)</span> first = mid+<span class="number">1</span>;
        <span class="keyword">else</span> <span class="midword">{</span>
            <span class="midwordlight">*</span>pos = mid;

            <span class="keyword">if</span><span class="midword">(</span>!p<span class="midword">[</span>rules-&gt;data.data<span class="midword">[</span>mid<span class="midword">]</span>-&gt;data.len<span class="midword">[</span>sort<span class="midword">]])</span> <span class="keyword">return</span> <span class="number">2</span>;

            first = mid+<span class="number">1</span>;
        <span class="midword">}</span>
    <span class="midword">}</span>

    <span class="keyword">if</span><span class="midword">(</span><span class="midwordlight">*</span>pos != <span class="midword">(</span><span class="keyworddark">size_t</span><span class="midword">)</span>-<span class="number">1</span><span class="midword">)</span> <span class="keyword">return</span> <span class="number">1</span>;

    <span class="keyword">if</span><span class="midword">(</span>v &lt; <span class="number">0</span><span class="midword">)</span> <span class="midwordlight">*</span>pos = mid;
    <span class="keyword">else</span> <span class="midwordlight">*</span>pos = mid+<span class="number">1</span>;

    <span class="keyword">return</span> <span class="number">0</span>;
<span class="midword">}</span>

<span class="commentdoc">/*! Follows the prev members of rules until a match with \a p is found.
    \param rules The array of rules.
    \param p The string to match with a rule.
    \param pos The closest match found so far.
    \return 1 if a match was found, 0 if not.
*/</span>
<span class="keyword">int</span> find_rule_prev<span class="midword">(</span><span class="keyword">const struct</span> rules_t <span class="midwordlight">*</span>rules, <span class="keyword">const char</span> <span class="midwordlight">*</span>p, <span class="keyworddark">size_t</span> <span class="midwordlight">*</span>pos<span class="midword">) {</span>
    <span class="keyworddark">size_t</span> n = <span class="midwordlight">*</span>pos-<span class="number">1</span>, sort;

    <span class="keyword">if</span><span class="midword">(</span><span class="midwordlight">*</span>pos<span class="midword">) {</span>
        <span class="keyword">while</span><span class="midword">(</span>rules-&gt;data.data<span class="midword">[</span>n<span class="midword">]</span>-&gt;prev != <span class="midword">(</span><span class="keyworddark">size_t</span><span class="midword">)</span>-<span class="number">1</span><span class="midword">) {</span>
            n = rules-&gt;data.data<span class="midword">[</span>n<span class="midword">]</span>-&gt;prev;
            sort = rules-&gt;type<span class="midword">[</span>rules-&gt;data.data<span class="midword">[</span>n<span class="midword">]</span>-&gt;type<span class="midword">]</span>.sort;

            <span class="keyword">if</span><span class="midword">(</span>!strncmp<span class="midword">(</span>p, rules-&gt;data.data<span class="midword">[</span>n<span class="midword">]</span>-&gt;data.data<span class="midword">[</span>sort<span class="midword">]</span>,
                rules-&gt;data.data<span class="midword">[</span>n<span class="midword">]</span>-&gt;data.len<span class="midword">[</span>sort<span class="midword">])) {</span>

                <span class="midwordlight">*</span>pos = n;
                <span class="keyword">return</span> <span class="number">1</span>;
            <span class="midword">}</span>
        <span class="midword">}</span>
    <span class="midword">}</span>

    <span class="keyword">return</span> <span class="number">0</span>;
<span class="midword">}</span>

<span class="commentdoc">/*! Copies the open file \a from to the filename \a fn. Rewinds the file
    pointer \a from beforehand. \a fn is opened via open_file().
    \param from The open file stream used as a source, to copy from.
    \param fn A string containing the filename for the destination, to copy to.
*/</span>
<span class="keyword">void</span> copy_file<span class="midword">(</span><span class="keyworddark">FILE</span> <span class="midwordlight">*</span>from, <span class="keyword">const char</span> <span class="midwordlight">*</span>fn<span class="midword">) {</span>
    <span class="keyworddark">FILE</span> <span class="midwordlight">*</span>to = open_file<span class="midword">(</span>fn, <span class="string">"w"</span><span class="midword">)</span>;
    <span class="keyword">int</span> c;

    <span class="keyword">if</span><span class="midword">(</span>!to<span class="midword">)</span> <span class="keyword">return</span>;

    rewind<span class="midword">(</span>from<span class="midword">)</span>;  <span class="comment">/* Rewind the file pointer to the beginning. */</span>

    <span class="keyword">while</span><span class="midword">((</span>c = getc<span class="midword">(</span>from<span class="midword">))</span> != EOF<span class="midword">) {</span>
        putc<span class="midword">(</span>c, to<span class="midword">)</span>;
    <span class="midword">}</span>

    <span class="keyword">if</span><span class="midword">(</span>to != stdout<span class="midword">)</span> fclose<span class="midword">(</span>to<span class="midword">)</span>;
<span class="midword">}</span>

<span class="commentdoc">/*! Returns true if \a p is a string representation of an integral number. A
    number is one or more digits followed by a character that is not a period.
    Thus floating point numbers are excluded.
    \param p The string that may contain a number.
    \return True if the string \a p represents an integral number.
*/</span>
<span class="keyword">int</span> is_number<span class="midword">(</span><span class="keyword">const char</span> <span class="midwordlight">*</span>p<span class="midword">) {</span>
    <span class="keyword">int</span> n = <span class="number">0</span>;

    <span class="keyword">while</span><span class="midword">(</span>isdigit<span class="midword">(</span><span class="midwordlight">*</span>p<span class="midword">))</span> p ++, n = <span class="number">1</span>;

    <span class="keyword">return</span> n <span class="midwordlight">&amp;&amp; *</span>p != <span class="string">'.'</span>;
<span class="midword">}</span>

<span class="commentdoc">/*! Returns true if \a p is a string representation of a floating-point number.
    A floating-point number is one or more optional digits plus a period plus
    one or more optional digits. (At least one digit must be present.)
    \param p The string to examine for a floating-point number.
    \return True if the string \a p represents a floating-point number.
*/</span>
<span class="keyword">int</span> is_fpnumber<span class="midword">(</span><span class="keyword">const char</span> <span class="midwordlight">*</span>p<span class="midword">) {</span>
    <span class="keyword">int</span> n = <span class="number">0</span>;  <span class="comment">/* True if there was a digit before the period. */</span>

    <span class="keyword">while</span><span class="midword">(</span>isdigit<span class="midword">(</span><span class="midwordlight">*</span>p<span class="midword">))</span> p ++, n = <span class="number">1</span>;

    <span class="keyword">return</span> <span class="midwordlight">*</span>p == <span class="string">'.'</span> <span class="midwordlight">&amp;&amp;</span> <span class="midword">(</span>n || isdigit<span class="midword">(</span>p<span class="midword">[</span><span class="number">1</span><span class="midword">]))</span>;
<span class="midword">}</span>

<span class="commentdoc">/*! Prints any digits, periods and underscores starting from the beginning of
    the string \a p to \a out. It stops printing characters when one that
    doesn't meet the criteria is found. \a p is incremented to that character.
    \param p The string to read characters from and to advance.
    \param out The output stream to write the characters to.
*/</span>
<span class="keyword">void</span> print_number<span class="midword">(</span><span class="keyword">char</span> <span class="midwordlight">**</span>p, <span class="keyworddark">FILE</span> <span class="midwordlight">*</span>out<span class="midword">) {</span>
    <span class="keyword">while</span><span class="midword">(</span>isalnum<span class="midword">(</span><span class="midwordlight">**</span>p<span class="midword">)</span> || <span class="midwordlight">**</span>p == <span class="string">'.'</span> || <span class="midwordlight">**</span>p == <span class="string">'_'</span><span class="midword">) {</span>
        fputc<span class="midword">(</span><span class="midwordlight">*</span><span class="midword">(</span><span class="midwordlight">*</span>p<span class="midword">)</span>++, out<span class="midword">)</span>;
    <span class="midword">}</span>
<span class="midword">}</span>

<span class="commentdoc">/*! Returns true if the string \a p is escaped. A character is escaped if it
    has an odd number of backslashes preceding it. \a start indicates the start
    of the string so that the function can calculate this without going before
    the beginning of the string.
    \param start The start of the string.
    \param p The position in \a start that the function counts backslashes
        preceding.
    \return True if there are an odd number of backslashes preceding the
        position \a p in the string \a start.
*/</span>
<span class="keyword">int</span> is_backslashed<span class="midword">(</span><span class="keyword">const char</span> <span class="midwordlight">*</span>start, <span class="keyword">const char</span> <span class="midwordlight">*</span>p<span class="midword">) {</span>
    <span class="keyworddark">size_t</span> x = <span class="number">0</span>;

    <span class="keyword">while</span><span class="midword">(</span>p &gt; start <span class="midwordlight">&amp;&amp; *</span><span class="midword">(</span>--p<span class="midword">)</span> == <span class="string">'\\'</span><span class="midword">)</span> x ++;

    <span class="keyword">return</span> x % <span class="number">2</span>;
<span class="midword">}</span>

<span class="commentdoc">/*! Shifts the string \a p to the left, deleting the first character (*p).
    \param p The string to delete the first character from.
*/</span>
<span class="keyword">void</span> remove_char<span class="midword">(</span><span class="keyword">char</span> <span class="midwordlight">*</span>p<span class="midword">) {</span>
    <span class="keyword">for</span><span class="midword">(</span> ; <span class="midwordlight">*</span>p; p++<span class="midword">)</span> <span class="midwordlight">*</span>p = <span class="midwordlight">*</span><span class="midword">(</span>p+<span class="number">1</span><span class="midword">)</span>;
<span class="midword">}</span>

<span class="commentdoc">/*! Returns true if the character \a c is a letter or an underscore (a "word"
    character).
    \param c The character to examine.
    \return True if the character \a c is a word character: a letter or an
        underscore.
*/</span>
<span class="keyword">int</span> is_word<span class="midword">(</span><span class="keyword">int</span> c<span class="midword">) {</span>
    <span class="keyword">return</span> c == <span class="string">'_'</span> || isalnum<span class="midword">(</span>c<span class="midword">)</span>;
<span class="midword">}</span>

<span class="commentdoc">/*! Returns true if the character before \a p is a word character (by calling
    is_word()); if p is the start of the string (equal to \a line), returns 0.
    \param line The start of the string.
    \param p The position in \a line to check the character before.
    \return True if the character before \a p is a word character; false if p
        is the start of the string.
*/</span>
<span class="keyword">int</span> is_word_prev<span class="midword">(</span><span class="keyword">const char</span> <span class="midwordlight">*</span>line, <span class="keyword">const char</span> <span class="midwordlight">*</span>p<span class="midword">) {</span>
    <span class="keyword">return</span> p == line ? <span class="number">0</span> : is_word<span class="midword">(</span><span class="midwordlight">*</span><span class="midword">(</span>p-<span class="number">1</span><span class="midword">))</span>;
<span class="midword">}</span>

<span class="commentdoc">/*! Removes shell-style (# to EOL) comments from the string \a s. Called to
    strip comments from rules.
    \param s The string to remove comments from.
*/</span>
<span class="keyword">void</span> remove_comments<span class="midword">(</span><span class="keyword">char</span> <span class="midwordlight">*</span>s<span class="midword">) {</span>
    <span class="keyword">char</span> <span class="midwordlight">*</span>p;

    <span class="keyword">for</span><span class="midword">(</span>p = s; <span class="midword">(</span>p = strchr<span class="midword">(</span>p, <span class="string">'#'</span><span class="midword">))</span>; p ++<span class="midword">) {</span>
        <span class="keyword">if</span><span class="midword">(</span>!is_backslashed<span class="midword">(</span>s, p<span class="midword">)) {</span>
            <span class="comment">/*while(p &gt; s &amp;&amp; isspace(*(p-1))) p --;*/</span>
            <span class="midwordlight">*</span>p = <span class="number">0</span>;

            <span class="keyword">break</span>;
        <span class="midword">}</span>
    <span class="midword">}</span>
<span class="midword">}</span>

<span class="commentdoc">/*! Returns the position of the separator for a variable, or NULL if the passed
    string is not a valid variable string.
    \param s The string that contains the possible variable. It consists of
        alphanumeric characters followed by an \c = followed by any other
        characters.
*/</span>
<span class="keyword">char</span> <span class="midwordlight">*</span>is_var<span class="midword">(</span><span class="keyword">char</span> <span class="midwordlight">*</span>s<span class="midword">) {</span>
    <span class="keyword">char</span> <span class="midwordlight">*</span>p = s;

    <span class="keyword">while</span><span class="midword">(</span><span class="midwordlight">*</span>p++<span class="midword">) {</span>
        <span class="keyword">if</span><span class="midword">(</span>!is_word<span class="midword">(</span><span class="midwordlight">*</span>p<span class="midword">)</span> <span class="midwordlight">&amp;&amp;</span> !isdigit<span class="midword">(</span><span class="midwordlight">*</span>p<span class="midword">)) {</span>
            <span class="keyword">if</span><span class="midword">(</span><span class="midwordlight">*</span>p == <span class="string">'='</span><span class="midword">) {</span>
                <span class="keyword">return</span> is_backslashed<span class="midword">(</span>s, p<span class="midword">)</span> ? <span class="number">0</span> : p;
            <span class="midword">}</span>
            <span class="keyword">else return</span> <span class="number">0</span>;
        <span class="midword">}</span>
    <span class="midword">}</span>

    <span class="keyword">return</span> <span class="number">0</span>;
<span class="midword">}</span>

<span class="commentdoc">/*! Returns true if s represents a filename which starts with "./" or ".\\".
    \param s The filename to look at.
    \return True if \a s starts with the current directory, "./" or ".\\".
*/</span>
<span class="keyword">int</span> is_current_dir<span class="midword">(</span><span class="keyword">const char</span> <span class="midwordlight">*</span>s<span class="midword">) {</span>
    <span class="keyword">return</span> <span class="midwordlight">*</span>s == <span class="string">'.'</span> <span class="midwordlight">&amp;&amp;</span> <span class="midword">(</span>s<span class="midword">[</span><span class="number">1</span><span class="midword">]</span> == <span class="string">'/'</span> || s<span class="midword">[</span><span class="number">1</span><span class="midword">]</span> == <span class="string">'\\'</span><span class="midword">)</span>;
<span class="midword">}</span>

<span class="commentdoc">/*! Prints \a len chars from \a *p to out. \a p is advanced to the next
    character (*p+len).
    \param p The string to advance and print.
    \param len The number of characters from \a p to print/advance.
    \param out The output file stream to write the characters to.
*/</span>
<span class="keyword">void</span> print_chars<span class="midword">(</span><span class="keyword">char</span> <span class="midwordlight">**</span>p, <span class="keyworddark">size_t</span> len, <span class="keyworddark">FILE</span> <span class="midwordlight">*</span>out<span class="midword">) {</span>
    <span class="keyword">while</span><span class="midword">(</span>len --<span class="midword">)</span> fputc<span class="midword">(</span><span class="midwordlight">*</span><span class="midword">(</span><span class="midwordlight">*</span>p<span class="midword">)</span>++, out<span class="midword">)</span>;
<span class="midword">}</span>

<span class="commentdoc">/*! Adds a function to the list of type_func functions.
    \param func The function list to add \a n to.
    \param which The function number to add to \a func.
    \param type The type of the function being added to the list.
*/</span>
<span class="keyword">void</span> add_to_funclist<span class="midword">(</span><span class="keyword">struct</span> funclist_t <span class="midwordlight">*</span>func, <span class="keyworddark">size_t</span> which, <span class="keyword">enum</span> type_t type<span class="midword">) {</span>
    <span class="keyworddark">size_t</span> <span class="midwordlight">*</span>f = realloc<span class="midword">(</span>func-&gt;which, <span class="midword">(</span>func-&gt;number + <span class="number">1</span><span class="midword">)</span> <span class="midwordlight">*</span> <span class="keyword">sizeof</span><span class="midword">(</span><span class="keyworddark">size_t</span><span class="midword">))</span>;
    <span class="keyword">enum</span> type_t <span class="midwordlight">*</span>t;

    <span class="keyword">if</span><span class="midword">(</span>!f<span class="midword">)</span> out_of_memory<span class="midword">(</span>__FILE__, __LINE__<span class="midword">)</span>;
    func-&gt;which = f;

    t = realloc<span class="midword">(</span>func-&gt;type, <span class="midword">(</span>func-&gt;number + <span class="number">1</span><span class="midword">)</span> <span class="midwordlight">*</span> <span class="keyword">sizeof</span><span class="midword">(</span><span class="keyword">enum</span> type_t<span class="midword">))</span>;
    <span class="keyword">if</span><span class="midword">(</span>!t<span class="midword">)</span> out_of_memory<span class="midword">(</span>__FILE__, __LINE__<span class="midword">)</span>;
    func-&gt;type = t;

    func-&gt;which<span class="midword">[</span>func-&gt;number<span class="midword">]</span> = which;
    func-&gt;type<span class="midword">[</span>func-&gt;number<span class="midword">]</span> = type;

    func-&gt;number ++;
<span class="midword">}</span>

<span class="commentdoc">/*! Removes the most recent function (on the bottom) from the function list
    \a func. (The function list stores the offset of the rule within the rules
    structure, not a function pointer.)
    \param func The function list to remove a function from.
*/</span>
<span class="keyword">void</span> remove_from_funclist<span class="midword">(</span><span class="keyword">struct</span> funclist_t <span class="midwordlight">*</span>func<span class="midword">) {</span>
    <span class="keyworddark">size_t</span> <span class="midwordlight">*</span>f;
    <span class="keyword">enum</span> type_t <span class="midwordlight">*</span>t;

    <span class="keyword">if</span><span class="midword">(</span>func-&gt;number &gt; <span class="number">1</span><span class="midword">) {</span>
        func-&gt;number --;

        f = realloc<span class="midword">(</span>func-&gt;which, func-&gt;number <span class="midwordlight">*</span> <span class="keyword">sizeof</span><span class="midword">(</span><span class="keyworddark">size_t</span><span class="midword">))</span>;
        <span class="keyword">if</span><span class="midword">(</span>!f<span class="midword">)</span> out_of_memory<span class="midword">(</span>__FILE__, __LINE__<span class="midword">)</span>;
        func-&gt;which = f;

        t = realloc<span class="midword">(</span>func-&gt;type, func-&gt;number <span class="midwordlight">*</span> <span class="keyword">sizeof</span><span class="midword">(</span><span class="keyword">enum</span> type_t<span class="midword">))</span>;
        <span class="keyword">if</span><span class="midword">(</span>!t<span class="midword">)</span> out_of_memory<span class="midword">(</span>__FILE__, __LINE__<span class="midword">)</span>;
        func-&gt;type = t;
    <span class="midword">}</span>
    <span class="keyword">else</span> <span class="midword">{</span>
        free<span class="midword">(</span>func-&gt;which<span class="midword">)</span>;
        free<span class="midword">(</span>func-&gt;type<span class="midword">)</span>;
        func-&gt;which = <span class="number">0</span>;
        func-&gt;type = <span class="number">0</span>;
        func-&gt;number = <span class="number">0</span>;
    <span class="midword">}</span>

    func-&gt;nest = <span class="number">1</span>;
<span class="midword">}</span>

<span class="commentdoc">/*! Adds a whitespace character to the list of whitespace characters.
    \param list The structure containing the list of whitespace characters.
    \param c The character to add.
*/</span>
<span class="keyword">void</span> add_ws_rulelist<span class="midword">(</span><span class="keyword">struct</span> rulelist_t <span class="midwordlight">*</span>list, <span class="keyword">char</span> c<span class="midword">) {</span>
    <span class="keyword">char</span> <span class="midwordlight">*</span>p;

    p = realloc<span class="midword">(</span>list-&gt;ws, list-&gt;wslen + <span class="number">2</span><span class="midword">)</span>;
    <span class="keyword">if</span><span class="midword">(</span>!p<span class="midword">)</span> out_of_memory<span class="midword">(</span>__FILE__, __LINE__<span class="midword">)</span>;
    list-&gt;ws = p;

    list-&gt;ws<span class="midword">[</span>list-&gt;wslen ++<span class="midword">]</span> = c;
    list-&gt;ws<span class="midword">[</span>list-&gt;wslen<span class="midword">]</span> = <span class="number">0</span>;
<span class="midword">}</span>

<span class="commentdoc">/*! Prints the whitespace in the whitespace list (if any), clearing the list.
    \param list The structure containing the list of whitespace characters.
    \param out The file stream to print the characters to.
*/</span>
<span class="keyword">void</span> print_ws_rulelist<span class="midword">(</span><span class="keyword">struct</span> rulelist_t <span class="midwordlight">*</span>list, <span class="keyworddark">FILE</span> <span class="midwordlight">*</span>out<span class="midword">) {</span>
    <span class="keyword">if</span><span class="midword">(</span>list-&gt;ws<span class="midword">) {</span>
        fputs<span class="midword">(</span>list-&gt;ws, out<span class="midword">)</span>;

        free<span class="midword">(</span>list-&gt;ws<span class="midword">)</span>;
        list-&gt;ws = <span class="number">0</span>;
        list-&gt;wslen = <span class="number">0</span>;
    <span class="midword">}</span>
<span class="midword">}</span>

<span class="commentdoc">/*! Starts a tag, ignoring tags of the same kind in sequence. That is, if two
    keywords with the same precede-with occur in a row, don't close the tag
    only to start it again.
    \param from The text to print before (now) if the previous tag wasn't the
        same as it.
    \param to The text to print after if \a from doesn't match list-&gt;from.
    \param list The structure containing the previous tag.
    \param out The output file stream to write everything to.
*/</span>
<span class="keyword">void</span> append_rulelist<span class="midword">(</span><span class="keyword">const char</span> <span class="midwordlight">*</span>from, <span class="keyword">const char</span> <span class="midwordlight">*</span>to, <span class="keyword">struct</span> rulelist_t <span class="midwordlight">*</span>list,
    <span class="keyworddark">FILE</span> <span class="midwordlight">*</span>out<span class="midword">) {</span>

    <span class="keyword">if</span><span class="midword">(</span>!from<span class="midword">) {</span>
        <span class="keyword">if</span><span class="midword">(</span>list-&gt;to<span class="midword">) {</span>
            fputs<span class="midword">(</span>list-&gt;to, out<span class="midword">)</span>;
            list-&gt;to = <span class="number">0</span>;
            list-&gt;from = <span class="number">0</span>;

            print_ws_rulelist<span class="midword">(</span>list, out<span class="midword">)</span>;
        <span class="midword">}</span>
    <span class="midword">}</span>
    <span class="keyword">else if</span><span class="midword">(</span>!list-&gt;from || strcmp<span class="midword">(</span>from, list-&gt;from<span class="midword">)) {</span>
        <span class="keyword">if</span><span class="midword">(</span>list-&gt;to<span class="midword">)</span> fputs<span class="midword">(</span>list-&gt;to, out<span class="midword">)</span>;

        print_ws_rulelist<span class="midword">(</span>list, out<span class="midword">)</span>;

        fputs<span class="midword">(</span>from, out<span class="midword">)</span>;
        list-&gt;from = from;
        list-&gt;to = to;
    <span class="midword">}</span>
    <span class="keyword">else</span> print_ws_rulelist<span class="midword">(</span>list, out<span class="midword">)</span>;
<span class="midword">}</span>

<span class="commentdoc">/*! Removes the newline characters, if any, off of the end of \a str. \a flen
    is adjusted accordingly. (Newline characters are '\\n' and '\\r', to
    support CRLF newlines under UNIX systems.)
    \param str The string to remove newline characters from the end of.
    \param flen The length of the string \a str, decreased with each character
        removed.
*/</span>
<span class="keyword">void</span> chomp_newline<span class="midword">(</span><span class="keyword">char</span> <span class="midwordlight">*</span>str, <span class="keyworddark">size_t</span> <span class="midwordlight">*</span>flen<span class="midword">) {</span>
    <span class="keyword">while</span><span class="midword">(</span><span class="midwordlight">*</span>flen <span class="midwordlight">&amp;&amp;</span> <span class="midword">(</span>str<span class="midword">[</span><span class="midwordlight">*</span>flen-<span class="number">1</span><span class="midword">]</span> == <span class="string">'\n'</span> || str<span class="midword">[</span><span class="midwordlight">*</span>flen-<span class="number">1</span><span class="midword">]</span> == <span class="string">'\r'</span><span class="midword">)) {</span>
        str<span class="midword">[</span>--<span class="midword">(</span><span class="midwordlight">*</span>flen<span class="midword">)]</span> = <span class="number">0</span>;
    <span class="midword">}</span>
<span class="midword">}</span>

<span class="comment">/*--------------------------------------------*\
 | type_func functions which implement rules. |
\*--------------------------------------------*/</span>

<span class="keyword">int</span> type_keyword<span class="midword">(</span><span class="keyword">struct</span> onerule_t <span class="midwordlight">*</span>rule, <span class="keyword">struct</span> typefunc_t <span class="midwordlight">*</span>tf<span class="midword">) {</span>
    <span class="keyword">if</span><span class="midword">(</span>!tf-&gt;iw <span class="midwordlight">&amp;&amp;</span> !is_word<span class="midword">((</span><span class="midwordlight">*</span>tf-&gt;p<span class="midword">)[</span>rule-&gt;data.len<span class="midword">[</span><span class="number">0</span><span class="midword">]])) {</span>
        <span class="keyword">return</span> type_midword<span class="midword">(</span>rule, tf<span class="midword">)</span>;
    <span class="midword">}</span>

    <span class="keyword">return</span> <span class="number">0</span>;
<span class="midword">}</span>

<span class="keyword">int</span> type_midword<span class="midword">(</span><span class="keyword">struct</span> onerule_t <span class="midwordlight">*</span>rule, <span class="keyword">struct</span> typefunc_t <span class="midwordlight">*</span>tf<span class="midword">) {</span>
    <span class="keyworddark">size_t</span> x;

    <span class="keyword">if</span><span class="midword">(</span>!strncmp<span class="midword">(</span>rule-&gt;data.data<span class="midword">[</span><span class="number">0</span><span class="midword">]</span>, <span class="midwordlight">*</span>tf-&gt;p, rule-&gt;data.len<span class="midword">[</span><span class="number">0</span><span class="midword">])) {</span>
        <span class="keyword">if</span><span class="midword">(</span>!tf-&gt;func.number<span class="midword">) {</span>
            append_rulelist<span class="midword">(</span>rule-&gt;data.data<span class="midword">[</span><span class="number">1</span><span class="midword">]</span>,
                rule-&gt;data.data<span class="midword">[</span>rule-&gt;data.number-<span class="number">1</span><span class="midword">]</span>, tf-&gt;list, tf-&gt;out<span class="midword">)</span>;
        <span class="midword">}</span>

        <span class="keyword">if</span><span class="midword">(</span>rule-&gt;data.number == <span class="number">3</span><span class="midword">) {</span>
            print_chars<span class="midword">(</span>tf-&gt;p, rule-&gt;data.len<span class="midword">[</span><span class="number">0</span><span class="midword">]</span>, tf-&gt;out<span class="midword">)</span>;
        <span class="midword">}</span>
        <span class="keyword">else</span> <span class="midword">{</span>
            <span class="keyword">for</span><span class="midword">(</span>x = <span class="number">0</span>; x &lt; rule-&gt;data.len<span class="midword">[</span><span class="number">0</span><span class="midword">]</span>; x ++<span class="midword">) {</span>
                <span class="midword">(</span><span class="midwordlight">*</span>tf-&gt;p<span class="midword">)</span>++;
            <span class="midword">}</span>

            fputs<span class="midword">(</span>rule-&gt;data.data<span class="midword">[</span><span class="number">2</span><span class="midword">]</span>, tf-&gt;out<span class="midword">)</span>;
        <span class="midword">}</span>

        <span class="keyword">return</span> <span class="number">1</span>;
    <span class="midword">}</span>

    <span class="keyword">return</span> <span class="number">0</span>;
<span class="midword">}</span>

<span class="keyword">int</span> type_comment_end<span class="midword">(</span><span class="keyword">struct</span> onerule_t <span class="midwordlight">*</span>rule, <span class="keyword">struct</span> typefunc_t <span class="midwordlight">*</span>tf<span class="midword">) {</span>
    <span class="keyword">if</span><span class="midword">(</span>rule-&gt;data.number == <span class="number">3</span><span class="midword">) {</span>
        <span class="keyword">if</span><span class="midword">(</span>tf-&gt;type == TYPE_COMMENT || tf-&gt;type == TYPE_NESTCOM<span class="midword">) {</span>
            <span class="keyword">if</span><span class="midword">((</span><span class="midwordlight">**</span>tf-&gt;p == <span class="string">'\n'</span> || <span class="midwordlight">**</span>tf-&gt;p == <span class="string">'\r'</span><span class="midword">)</span>
                <span class="midwordlight">&amp;&amp;</span> !is_backslashed<span class="midword">(</span><span class="midwordlight">*</span>tf-&gt;p - tf-&gt;n, <span class="midwordlight">*</span>tf-&gt;p<span class="midword">)) {</span>

                fputs<span class="midword">(</span>rule-&gt;data.data<span class="midword">[</span><span class="number">2</span><span class="midword">]</span>, tf-&gt;out<span class="midword">)</span>;

                <span class="keyword">return</span> -<span class="number">1</span>;
            <span class="midword">}</span>
        <span class="midword">}</span>
        <span class="keyword">else if</span><span class="midword">(</span>!strncmp<span class="midword">(</span>rule-&gt;data.data<span class="midword">[</span><span class="number">0</span><span class="midword">]</span>, <span class="midwordlight">*</span>tf-&gt;p, rule-&gt;data.len<span class="midword">[</span><span class="number">0</span><span class="midword">])) {</span>
            print_chars<span class="midword">(</span>tf-&gt;p, rule-&gt;data.len<span class="midword">[</span><span class="number">0</span><span class="midword">]</span>, tf-&gt;out<span class="midword">)</span>;

            <span class="keyword">if</span><span class="midword">(</span>tf-&gt;func.number == <span class="number">1</span><span class="midword">)</span> fputs<span class="midword">(</span>rule-&gt;data.data<span class="midword">[</span><span class="number">2</span><span class="midword">]</span>, tf-&gt;out<span class="midword">)</span>;

            <span class="keyword">return</span> -<span class="number">1</span>;
        <span class="midword">}</span>
    <span class="midword">}</span>
    <span class="keyword">else if</span><span class="midword">(</span>!strncmp<span class="midword">(</span>rule-&gt;data.data<span class="midword">[</span><span class="number">1</span><span class="midword">]</span>, <span class="midwordlight">*</span>tf-&gt;p, rule-&gt;data.len<span class="midword">[</span><span class="number">1</span><span class="midword">])) {</span>
        print_chars<span class="midword">(</span>tf-&gt;p, rule-&gt;data.len<span class="midword">[</span><span class="number">1</span><span class="midword">]</span>, tf-&gt;out<span class="midword">)</span>;

        <span class="keyword">if</span><span class="midword">(</span>tf-&gt;type != TYPE_STRING || tf-&gt;func.number == <span class="number">1</span><span class="midword">) {</span>
            fputs<span class="midword">(</span>rule-&gt;data.data<span class="midword">[</span><span class="number">3</span><span class="midword">]</span>, tf-&gt;out<span class="midword">)</span>;
        <span class="midword">}</span>

        <span class="keyword">return</span> -<span class="number">1</span>;
    <span class="midword">}</span>

    <span class="keyword">if</span><span class="midword">(</span>tf-&gt;pos <span class="midwordlight">&amp;</span> POS_END<span class="midword">) {</span>
        <span class="keyword">if</span><span class="midword">(</span>tf-&gt;type != TYPE_STRING || tf-&gt;func.number == <span class="number">1</span><span class="midword">) {</span>
            fputs<span class="midword">(</span>rule-&gt;data.data<span class="midword">[</span>rule-&gt;data.number-<span class="number">1</span><span class="midword">]</span>, tf-&gt;out<span class="midword">)</span>;
        <span class="midword">}</span>

        <span class="keyword">return</span> -<span class="number">1</span>;
    <span class="midword">}</span>

    <span class="keyword">return</span> <span class="number">0</span>;
<span class="midword">}</span>

<span class="keyword">int</span> type_comment<span class="midword">(</span><span class="keyword">struct</span> onerule_t <span class="midwordlight">*</span>rule, <span class="keyword">struct</span> typefunc_t <span class="midwordlight">*</span>tf<span class="midword">) {</span>
    <span class="keyword">if</span><span class="midword">(</span>tf-&gt;func.number <span class="midwordlight">&amp;&amp;</span> tf-&gt;func.which<span class="midword">[</span>tf-&gt;func.number-<span class="number">1</span><span class="midword">]</span> == tf-&gt;number
        <span class="midwordlight">&amp;&amp;</span> tf-&gt;func.type<span class="midword">[</span>tf-&gt;func.number-<span class="number">1</span><span class="midword">]</span> == tf-&gt;type<span class="midword">) {</span>

        <span class="keyword">if</span><span class="midword">(</span>type_comment_end<span class="midword">(</span>rule, tf<span class="midword">))</span> <span class="keyword">return</span> -<span class="number">1</span>;
    <span class="midword">}</span>

    <span class="keyword">if</span><span class="midword">(</span>tf-&gt;func.nest
        <span class="midwordlight">&amp;&amp;</span> !strncmp<span class="midword">(</span>rule-&gt;data.data<span class="midword">[</span><span class="number">0</span><span class="midword">]</span>, <span class="midwordlight">*</span>tf-&gt;p, rule-&gt;data.len<span class="midword">[</span><span class="number">0</span><span class="midword">])) {</span>

        append_rulelist<span class="midword">(</span><span class="number">0</span>, <span class="number">0</span>, tf-&gt;list, tf-&gt;out<span class="midword">)</span>;

        <span class="keyword">if</span><span class="midword">(</span>tf-&gt;type != TYPE_STRING || !tf-&gt;func.number<span class="midword">) {</span>
            fputs<span class="midword">(</span>rule-&gt;data.data<span class="midword">[</span>rule-&gt;data.number-<span class="number">2</span><span class="midword">]</span>, tf-&gt;out<span class="midword">)</span>;
        <span class="midword">}</span>

        print_chars<span class="midword">(</span>tf-&gt;p, rule-&gt;data.len<span class="midword">[</span><span class="number">0</span><span class="midword">]</span>, tf-&gt;out<span class="midword">)</span>;

        add_to_funclist<span class="midword">(</span><span class="midwordlight">&amp;</span>tf-&gt;func, tf-&gt;number, tf-&gt;type<span class="midword">)</span>;
        tf-&gt;func.nest = <span class="midword">(</span>tf-&gt;type == TYPE_NESTCOM<span class="midword">)</span>;

        <span class="keyword">return</span> <span class="number">1</span>;
    <span class="midword">}</span>

    <span class="keyword">return</span> <span class="number">0</span>;
<span class="midword">}</span>

<span class="keyword">int</span> type_string<span class="midword">(</span><span class="keyword">struct</span> onerule_t <span class="midwordlight">*</span>rule, <span class="keyword">struct</span> typefunc_t <span class="midwordlight">*</span>tf<span class="midword">) {</span>
    <span class="keyword">if</span><span class="midword">(</span>tf-&gt;func.nest || !is_backslashed<span class="midword">(</span><span class="midwordlight">*</span>tf-&gt;p - tf-&gt;n, <span class="midwordlight">*</span>tf-&gt;p<span class="midword">)) {</span>
        <span class="keyword">return</span> type_comment<span class="midword">(</span>rule, tf<span class="midword">)</span>;
    <span class="midword">}</span>

    <span class="keyword">return</span> <span class="number">0</span>;
<span class="midword">}</span>

<span class="keyword">int</span> type_nestcom<span class="midword">(</span><span class="keyword">struct</span> onerule_t <span class="midwordlight">*</span>rule, <span class="keyword">struct</span> typefunc_t <span class="midwordlight">*</span>tf<span class="midword">) {</span>
    <span class="keyword">return</span> type_comment<span class="midword">(</span>rule, tf<span class="midword">)</span>;
<span class="midword">}</span>

<span class="keyword">int</span> type_number<span class="midword">(</span><span class="keyword">struct</span> onerule_t <span class="midwordlight">*</span>rule, <span class="keyword">struct</span> typefunc_t <span class="midwordlight">*</span>tf<span class="midword">) {</span>
    <span class="keyword">if</span><span class="midword">(</span>!tf-&gt;iw <span class="midwordlight">&amp;&amp;</span> is_number<span class="midword">(</span><span class="midwordlight">*</span>tf-&gt;p<span class="midword">)) {</span>
        <span class="keyword">if</span><span class="midword">(</span>!tf-&gt;func.number<span class="midword">) {</span>
            append_rulelist<span class="midword">(</span>rule-&gt;data.data<span class="midword">[</span><span class="number">0</span><span class="midword">]</span>, rule-&gt;data.data<span class="midword">[</span><span class="number">1</span><span class="midword">]</span>, tf-&gt;list,
                tf-&gt;out<span class="midword">)</span>;
        <span class="midword">}</span>

        print_number<span class="midword">(</span>tf-&gt;p, tf-&gt;out<span class="midword">)</span>;

        <span class="keyword">return</span> <span class="number">1</span>;
    <span class="midword">}</span>

    <span class="keyword">return</span> <span class="number">0</span>;
<span class="midword">}</span>

<span class="keyword">int</span> type_fpnumber<span class="midword">(</span><span class="keyword">struct</span> onerule_t <span class="midwordlight">*</span>rule, <span class="keyword">struct</span> typefunc_t <span class="midwordlight">*</span>tf<span class="midword">) {</span>
    <span class="keyword">if</span><span class="midword">(</span>!tf-&gt;iw <span class="midwordlight">&amp;&amp;</span> is_fpnumber<span class="midword">(</span><span class="midwordlight">*</span>tf-&gt;p<span class="midword">)) {</span>
        <span class="keyword">if</span><span class="midword">(</span>!tf-&gt;func.number<span class="midword">) {</span>
            append_rulelist<span class="midword">(</span>rule-&gt;data.data<span class="midword">[</span><span class="number">0</span><span class="midword">]</span>, rule-&gt;data.data<span class="midword">[</span><span class="number">1</span><span class="midword">]</span>, tf-&gt;list,
                tf-&gt;out<span class="midword">)</span>;
        <span class="midword">}</span>

        print_number<span class="midword">(</span>tf-&gt;p, tf-&gt;out<span class="midword">)</span>;

        <span class="keyword">return</span> <span class="number">1</span>;
    <span class="midword">}</span>

    <span class="keyword">return</span> <span class="number">0</span>;
<span class="midword">}</span>

<span class="keyword">int</span> type_start<span class="midword">(</span><span class="keyword">struct</span> onerule_t <span class="midwordlight">*</span>rule, <span class="keyword">struct</span> typefunc_t <span class="midwordlight">*</span>tf<span class="midword">) {</span>
    <span class="keyword">if</span><span class="midword">(</span>tf-&gt;pos <span class="midwordlight">&amp;</span> POS_START <span class="midwordlight">&amp;&amp;</span> !tf-&gt;n<span class="midword">) {</span>
        tf-&gt;pos <span class="midwordlight">&amp;</span>= ~POS_START;
        fputs<span class="midword">(</span>rule-&gt;data.data<span class="midword">[</span><span class="number">0</span><span class="midword">]</span>, tf-&gt;out<span class="midword">)</span>;
    <span class="midword">}</span>

    <span class="keyword">return</span> <span class="number">0</span>;
<span class="midword">}</span>

<span class="keyword">int</span> type_end<span class="midword">(</span><span class="keyword">struct</span> onerule_t <span class="midwordlight">*</span>rule, <span class="keyword">struct</span> typefunc_t <span class="midwordlight">*</span>tf<span class="midword">) {</span>
    <span class="keyword">if</span><span class="midword">(</span>tf-&gt;pos <span class="midwordlight">&amp;</span> POS_END <span class="midwordlight">&amp;&amp;</span> !<span class="midwordlight">**</span>tf-&gt;p<span class="midword">) {</span>
        tf-&gt;pos <span class="midwordlight">&amp;</span>= ~POS_END;
        fputs<span class="midword">(</span>rule-&gt;data.data<span class="midword">[</span><span class="number">0</span><span class="midword">]</span>, tf-&gt;out<span class="midword">)</span>;
    <span class="midword">}</span>

    <span class="keyword">return</span> <span class="number">0</span>;
<span class="midword">}</span>
</pre></body></html>
